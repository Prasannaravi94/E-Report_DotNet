/*
FusionCharts JavaScript Library
Copyright FusionCharts Technologies LLP
License Information at <http://www.fusioncharts.com/license>

@version 3.4.0-alpha.5

@attributions (infers respective third-party copyrights)
Raphael 2.1.0 (modified as 'Red Raphael') <http://raphaeljs.com/license.html>
JSON v2 <http://www.JSON.org/js.html>
Firebug Lite 1.3.0 <http://getfirebug.com/firebuglite>
*/
(function () {
    if (!window.FusionCharts || !window.FusionCharts.version) {
        var d = window, n = d.document, E = d.navigator, u = { window: d }, l = u.modules = {}, b = u.interpreters = {}, P = Object.prototype.toString, c = /msie/i.test(E.userAgent) && !d.opera, J = /loaded|complete/, a = !!n.createElementNS && !!n.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect, B = !1, N = function () { var a = u.ready; u.ready = !0; u.raiseEvent && (u.readyNotified = !0, u.raiseEvent("ready", { version: u.core.version, now: !a }, u.core)); u.readyNow = !a }, t = function (a,
b) { var f, c; if (b instanceof Array) for (f = 0; f < b.length; f += 1) "object" !== typeof b[f] ? a[f] = b[f] : ("object" !== typeof a[f] && (a[f] = b[f] instanceof Array ? [] : {}), t(a[f], b[f])); else for (f in b) "object" === typeof b[f] ? (c = P.call(b[f]), "[object Object]" === c ? ("object" !== typeof a[f] && (a[f] = {}), t(a[f], b[f])) : "[object Array]" === c ? (a[f] instanceof Array || (a[f] = []), t(a[f], b[f])) : a[f] = b[f]) : a[f] = b[f]; return a }; u.extend = function (a, b, f, c) { var s; f && a.prototype && (a = a.prototype); if (!0 === c) t(a, b); else for (s in b) a[s] = b[s]; return a };
        u.uniqueId = function () { return "chartobject-" + (u.uniqueId.lastId += 1) }; u.uniqueId.lastId = 0; u.policies = { options: { chartTypeSourcePath: ["typeSourcePath", ""], product: ["product", "v3"], insertMode: ["insertMode", "replace"], safeMode: ["safeMode", !0], overlayButton: ["overlayButton", void 0], containerBackgroundColor: ["containerBackgroundColor", "#ffffff"], containerBackgroundOpacity: ["containerBackgroundOpacity", 1], chartType: ["type", void 0] }, attributes: { lang: ["lang", "EN"], "class": ["className", "FusionCharts"], id: ["id",
void 0]
        }, width: ["width", "400"], height: ["height", "300"], src: ["swfUrl", ""]
        }; b.stat = "swfUrl id width height debugMode registerWithJS backgroundColor scaleMode lang detectFlashVersion autoInstallRedirect".split(" "); u.parsePolicies = function (a, b, f) { var c, t, d; for (t in b) if (u.policies[t] instanceof Array) d = f[b[t][0]], a[t] = void 0 === d ? b[t][1] : d; else for (c in "object" !== typeof a[t] && (a[t] = {}), b[t]) d = f[b[t][c][0]], a[t][c] = void 0 === d ? b[t][c][1] : d }; u.parseCommands = function (a, c, f) {
            var h, t; "string" === typeof c && (c =
b[c] || []); h = 0; for (t = c.length; h < t; h++) a[c[h]] = f[h]; return a
        }; u.core = function (g) {
            if (!(this instanceof u.core)) { if (1 === arguments.length && g instanceof Array && "private" === g[0]) { if (l[g[1]]) return; l[g[1]] = {}; g[3] instanceof Array && (u.core.version[g[1]] = g[3]); return "function" === typeof g[2] ? g[2].call(u, l[g[1]]) : u } if (1 === arguments.length && "string" === typeof g) return u.core.items[g]; u.raiseError && u.raiseError(this, "25081840", "run", "", new SyntaxError('Use the "new" keyword while creating a new FusionCharts object')) } var t =
{}; this.__state = {}; 1 === arguments.length && "object" === typeof arguments[0] ? t = arguments[0] : (u.parseCommands(t, b.stat, arguments), u.core.options.sensePreferredRenderer && t.swfUrl && t.swfUrl.match && !t.swfUrl.match(/[^a-z0-9]+/ig) && (t.type = t.swfUrl)); 1 < arguments.length && "object" === typeof arguments[arguments.length - 1] && (delete t[b.stat[arguments.length - 1]], u.extend(t, arguments[arguments.length - 1])); this.id = "undefined" === typeof t.id ? this.id = u.uniqueId() : t.id; this.args = t; u.core.items[this.id] instanceof u.core &&
u.raiseWarning(this, "06091847", "param", "", Error('A FusionChart oject with the specified id "' + this.id + '" already exists. Renaming it to ' + (this.id = u.uniqueId()))); t.type && t.type.toString && !u.renderer.userSetDefault && (c || a) && (t.renderer = t.renderer || "javascript"); u.parsePolicies(this, u.policies, t); this.attributes.id = this.id; this.resizeTo(t.width, t.height, !0); u.raiseEvent("beforeInitialize", t, this); u.core.items[this.id] = this; u.core.defaultOptions = u.core.options; u.raiseEvent("initialized", t, this); return this
        };
        u.core.prototype = {}; u.core.prototype.constructor = u.core; u.extend(u.core, { id: "FusionCharts", version: ["3", "4", "0", "alpha", "5"], items: {}, options: { sensePreferredRenderer: !0, chartTypeSourcePath: "" }, getObjectReference: function (a) { return u.core.items[a].ref }, register: function (a) { var b; switch (a && a.toString && a.toString().toLowerCase()) { case "module": b = u.core.apply(u.core, Array.prototype.slice.call(arguments, 1)) } return b } }); d.FusionCharts = u.core; d.FusionMaps && d.FusionMaps.legacy && (u.core(["private", "modules.core.geo",
d.FusionMaps.legacy, d.FusionMaps.version]), B = !0); J.test(n.readyState) || n.loaded ? (u.ready = !0, setTimeout(N, 1)) : function () {
    function a() { arguments.callee.done || (arguments.callee.done = !0, f && clearTimeout(f), B || (d.FusionMaps && d.FusionMaps.legacy && u.core(["private", "modules.core.geo", d.FusionMaps.legacy, d.FusionMaps.version]), d.FusionMaps = u.core), setTimeout(N, 1)) } function b() { J.test(n.readyState) ? a() : f = setTimeout(b, 10) } var f, t; n.addEventListener ? n.addEventListener("DOMContentLoaded", a, !1) : n.attachEvent &&
d.attachEvent("onLoad", a); if (c) try { "https:" === d.location.protocol ? n.write('<script id="__ie_onload_fusioncharts" defer="defer" src="//:">\x3c/script>') : n.write('<script id="__ie_onload_fusioncharts" defer="defer" src="javascript:void(0)">\x3c/script>'), t = n.getElementById("__ie_onload_fusioncharts"), t.onreadystatechange = function () { "complete" == this.readyState && a() } } catch (s) { } /WebKit/i.test(E.userAgent) && (f = setTimeout(b, 10)); d.onload = function (b) { return function () { a(); b && b.call && b.call(d) } } (d.onload)
} ();
        d.FusionMaps = u.core
    } 
})();
FusionCharts.register("module", ["private", "modules.mantle.errormanager", function () {
    var d = this, n = d.window, E = { type: "TypeException", range: "ValueRangeException", impl: "NotImplementedException", param: "ParameterException", run: "RuntimeException", comp: "DesignTimeError", undefined: "UnspecifiedException" }, u = function (b, l, c, J, a, B) {
        var N = "#" + l + " " + (b ? b.id : "unknown-source") + J + " " + B + " >> "; a instanceof Error ? (a.name = E[c], a.module = "FusionCharts" + J, a.level = B, a.message = N + a.message, N = a.message, n.setTimeout(function () {
            throw a;
        }, 0)) : N += a; l = { id: l, nature: E[c], source: "FusionCharts" + J, message: N }; d.raiseEvent(B, l, b); if ("function" === typeof n["FC_" + B]) n["FC_" + B](l)
    }, l; d.raiseError = function (b, d, c, l, a) { u(b, d, c, l, a, "Error") }; d.raiseWarning = function (b, d, c, l, a) { u(b, d, c, l, a, "Warning") }; l = { outputHelpers: { text: function (b, d) { l.outputTo("#" + b.eventId + " [" + (b.sender.id || b.sender).toString() + '] fired "' + b.eventType + '" event. ' + ("error" === b.eventType || "warning" === b.eventType ? d.message : "")) }, event: function (b, d) { this.outputTo(b, d) }, verbose: function (b,
d) { l.outputTo(b.eventId, b.sender.id, b.eventType, d) } 
    }, outputHandler: function (b, n) { "function" !== typeof l.outputTo ? d.core["debugger"].outputFailed = !0 : (d.core["debugger"].outputFailed = !1, l.currentOutputHelper(b, n)) }, currentOutputHelper: void 0, outputTo: void 0, enabled: !1
    }; l.currentOutputHelper = l.outputHelpers.text; d.extend(d.core, { "debugger": { syncStateWithCharts: !0, outputFormat: function (b) {
        return b && "function" === typeof b.toLowerCase && "function" === typeof l.outputHelpers[b = b.toLowerCase()] ? (l.currentOutputHelper =
l.outputHelpers[b], !0) : !1
    }, outputTo: function (b) { "function" === typeof b ? l.outputTo = b : null === b && (d.core["debugger"].enable(!1), delete l.outputTo) }, enable: function (b, n, c) {
        var J; "object" === typeof b && 1 === arguments.length && (J = b, b = J.state, n = J.outputTo, c = J.outputFormat); "function" === typeof b && ("string" !== typeof n || 2 !== arguments.length && !J || (c = n), n = b, b = !0); if ("boolean" === typeof b && b !== l.enabled) d.core[(l.enabled = b) ? "addEventListener" : "removeEventListener"]("*", l.outputHandler); "function" === typeof n && (l.outputTo =
n); d.core["debugger"].outputFormat(c); return l.enabled
    }, enableFirebugLite: function () { var b; n.console && n.console.firebug ? d.core["debugger"].enable(n.console.log, "verbose") : ((b = n.document.getElementsByTagName("html")) && b[0].setAttribute("debug", "true"), d.loadScript("https://getfirebug.com/firebug-lite.js#overrideConsole=false,startOpened=true", function () { d.core["debugger"].enable(n.console.log, "verbose") }, "{ startOpened: true }", !0, !0)) } 
    }, debugMode: { enabled: function () {
        n.setTimeout(function () {
            throw Error("Deprecated! Please use FusionCharts.debugger.enable instead.");
        }, 0); return d.core["debugger"].enable.apply(d.core["debugger"], arguments)
    } 
    }
    }, !1)
} ]);
FusionCharts.register("module", ["private", "modules.mantle.eventmanager", function () {
    var d = this, n = d.window, E = d.core, u = n.Object.prototype.toString, l = u.call([]), b = function (a, b, g, c) { try { a[0].call(b, g, c || {}) } catch (f) { setTimeout(function () { throw f; }, 0) } }, P = function (a, c, g) { if (a instanceof Array) for (var k = 0, f; k < a.length; k += 1) { if (a[k][1] === c.sender || void 0 === a[k][1]) f = a[k][1] === c.sender ? c.sender : d.core, b(a[k], f, c, g), !0 === c.detached && (a.splice(k, 1), k -= 1, c.detached = !1); if (!0 === c.cancelled) break } }, c = { unpropagator: function () {
        return !1 ===
(this.cancelled = !0)
    }, detacher: function () { return !1 === (this.detached = !0) }, undefaulter: function () { return !1 === (this.prevented = !0) }, listeners: {}, lastEventId: 0, addListener: function (a, b, g) {
        var k, f; if (u.call(a) === l) { k = []; for (f = 0; f < a.length; f += 1) k.push(c.addListener(a[f], b, g)); return k } if ("string" !== typeof a) d.raiseError(g || d.core, "03091549", "param", "::EventTarget.addListener", Error("Unspecified Event Type")); else if ("function" !== typeof b) d.raiseError(g || d.core, "03091550", "param", "::EventTarget.addListener",
Error("Invalid Event Listener")); else return a = a.toLowerCase(), c.listeners[a] instanceof Array || (c.listeners[a] = []), c.listeners[a].push([b, g]), b
    }, removeListener: function (a, b, g) {
        var k; if ("function" !== typeof b) d.raiseError(g || d.core, "03091560", "param", "::EventTarget.removeListener", Error("Invalid Event Listener")); else if (a instanceof Array) for (k = 0; k < a.length; k += 1) c.removeListener(a[k], b, g); else if ("string" !== typeof a) d.raiseError(g || d.core, "03091559", "param", "::EventTarget.removeListener", Error("Unspecified Event Type"));
        else if (a = a.toLowerCase(), a = c.listeners[a], a instanceof Array) for (k = 0; k < a.length; k += 1) a[k][0] === b && a[k][1] === g && (a.splice(k, 1), k -= 1)
    }, triggerEvent: function (a, b, g, k, f, h) {
        if ("string" !== typeof a) d.raiseError(b, "03091602", "param", "::EventTarget.dispatchEvent", Error("Invalid Event Type")); else {
            a = a.toLowerCase(); var s = { eventType: a, eventId: c.lastEventId += 1, sender: b || Error("Orphan Event"), cancelled: !1, stopPropagation: this.unpropagator, prevented: !1, preventDefault: this.undefaulter, detached: !1, detachHandler: this.detacher };
            P(c.listeners[a], s, g); P(c.listeners["*"], s, g); switch (s.prevented) { case !0: if ("function" === typeof h) try { h.call(k || b || n, s, g || {}) } catch (B) { setTimeout(function () { throw B; }, 0) } break; default: if ("function" === typeof f) try { f.call(k || b || n, s, g || {}) } catch (m) { setTimeout(function () { throw m; }, 0) } } return !0
        } 
    } 
    }, J = d.raiseEvent = function (a, b, g, k, f, h) { return c.triggerEvent(a, g, b, k, f, h) }, a = d.legacyEventList = {}, B = {}; d.disposeEvents = function (a) {
        var b, g; for (b in c.listeners) for (g = 0; g < c.listeners[b].length; g += 1) c.listeners[b][g][1] ===
a && c.listeners[b].splice(g, 1)
    }; d.raiseEventWithLegacy = function (b, c, g, k, f, h, s) { var d = a[b]; J(b, c, g, f, h, s); d && "function" === typeof n[d] && setTimeout(function () { n[d].apply(f || n, k) }, 0) }; d.raiseEventGroup = function (a, b, c, k, f, h, s) { var d = k.id, m = a + d; B[m] ? (clearTimeout(B[m]), delete B[m]) : d && m ? B[m] = setTimeout(function () { J(b, c, k, f, h, s); delete B[m] }, 0) : J(b, c, k, f, h, s) }; d.addEventListener = function (a, b) { return c.addListener(a, b) }; d.removeEventListener = function (a, b) { return c.removeListener(a, b) }; d.extend(E, { addEventListener: function (a,
b) { return c.addListener(a, b) }, removeEventListener: function (a, b) { return c.removeListener(a, b) }, ready: function (a, b, c) { d.ready ? (E.ready = function (a, f) { "function" === typeof a && setTimeout(function () { a.call(f || E, b || E) }, 0) }, E.ready(a, c)) : "function" === typeof a && E.addEventListener("ready", function () { E.ready(a, b, c) }); return this } 
    }); E.on = E.addEventListener; d.extend(E.prototype, { addEventListener: function (a, b) { return c.addListener(a, b, this) }, removeEventListener: function (a, b) { return c.removeListener(a, b, this) } });
    E.prototype.on = E.prototype.addEventListener; d.policies.options.events = ["events", {}]; d.addEventListener("beforeInitialize", function (a) { a = a.sender; var b = a.options.events, c; if (b) for (c in b) "function" === typeof b[c] && a.addEventListener(c, b[c]) }); d.ready && !d.readyNotified && (d.readyNotified = !0, d.raiseEvent("ready", { version: d.core.version, now: d.readyNow }, d.core))
} ]);
FusionCharts.register("module", ["private", "modules.mantle.ajax", function () {
    var d = this, n = d.window, E = parseFloat(n.navigator.appVersion.split("MSIE")[1]), u = 5.5 <= E && 7 >= E ? !0 : !1, l = "file:" === n.location.protocol, b = n.ActiveXObject, P = (!b || !l) && n.XMLHttpRequest, c = { objects: 0, xhr: 0, requests: 0, success: 0, failure: 0, idle: 0 }, J = function () {
        var a; if (P) return J = function () { c.xhr++; return new P }, J(); try { a = new b("Msxml2.XMLHTTP"), J = function () { c.xhr++; return new b("Msxml2.XMLHTTP") } } catch (d) {
            try {
                a = new b("Microsoft.XMLHTTP"),
J = function () { c.xhr++; return new b("Microsoft.XMLHTTP") } 
            } catch (l) { a = !1 } 
        } return a
    }; d.core.ajax = { stats: function (a) { return a ? c[a] : d.extend({}, c) }, headers: { "If-Modified-Since": "Sat, 29 Oct 1994 19:43:31 GMT", "X-Requested-With": "XMLHttpRequest", "X-Requested-By": "FusionCharts", Accept: "text/plain, */*", "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8"} }; E = d.ajax = function (a, b) { this.onSuccess = a; this.onError = b; this.open = !1; c.objects++; c.idle++ }; d.extend(E.prototype, { headers: d.core.ajax.headers,
        transact: function (a, b, N, t) {
            var g = this, k = g.xmlhttp, f = g.headers, h = g.onError, s = g.onSuccess; a = "POST" === a; var sa, m; if (!k || u) k = J(), g.xmlhttp = k; k.onreadystatechange = function () { try { 4 === k.readyState && (!k.status && l || 200 <= k.status && 300 > k.status || 304 === k.status || 1223 === k.status || 0 === k.status ? (s && s(k.responseText, g, t, b), c.success++) : h && (h(Error("XmlHttprequest Error"), g, t, b), c.failure++), c.idle--, g.open = !1) } catch (a) { h && h(a, g, t, b), n.FC_DEV_ENVIRONMENT && setTimeout(function () { throw a; }, 0), c.failure++ } }; try {
                k.open(a ?
"POST" : "GET", b, !0); k.overrideMimeType && k.overrideMimeType("text/plain"); if (a) if ("string" === typeof N) sa = N; else { sa = []; for (m in N) sa.push(m + "=" + (N[m] + "").replace(/\=/g, "%3D").replace(/\&/g, "%26")); sa = sa.join("&") } else sa = null; for (m in f) k.setRequestHeader(m, f[m]); k.send(sa); c.requests++; c.idle++; g.open = !0
            } catch (z) { d.raiseError(d.core, "1110111515A", "run", "XmlHttprequest Error", z.message) } return k
        }, get: function (a, b) { return this.transact("GET", a, void 0, b) }, post: function (a, b, c) {
            return this.transact("POST",
a, b, c)
        }, abort: function () { var a = this.xmlhttp; this.open = !1; return a && "function" === typeof a.abort && a.readyState && 0 !== a.readyState && a.abort() }, dispose: function () { this.open && this.abort(); delete this.onError; delete this.onSuccess; delete this.xmlhttp; delete this.open; c.objects--; return null } 
    })
} ]);
FusionCharts.register("module", ["private", "modules.mantle.runtime;1.1", function () {
    var d = this, n = d.window, E = /(^|[\/\\])(fusioncharts\.js)([\?#].*)?$/ig, u = /[\\\"<>;&]/, l = /^[^\S]*?(sf|f|ht)(tp|tps):\/\//i, b = {}, P = {}, c = {}, J = {}, a = d.purgeDOM = function (b) { var c = b.attributes, d, f; if (c) for (d = c.length - 1; 0 <= d; d -= 1) f = c[d].name, "function" === typeof b[f] && (b[f] = null); if (c = b.childNodes) for (c = c.length, d = 0; d < c; d += 1) a(b.childNodes[d]) }, B = function (a, b, c) {
        var f, h; for (f in a) if (a[f] instanceof Array) b[a[f][0]] = c[f]; else for (h in a[f]) b[a[f][h][0]] =
c[f][h]
    }, N = /^(FusionCharts|FusionWidgets|FusionMaps)/; d.getScriptBaseUri = function (a) { var b = n.document.getElementsByTagName("script"), c = b.length, f, h; for (h = 0; h < c; h += 1) if (f = b[h].getAttribute("src"), void 0 !== f && null !== f && null !== f.match(a)) return f.replace(a, "$1") }; d.core.options.scriptBaseUri = function () { var a = d.getScriptBaseUri(E); return void 0 === a ? (d.raiseError(FusionCharts, "1603111624", "run", ">GenericRuntime~scriptBaseUri", "Unable to locate FusionCharts script source location (URL)."), "") : a } (); d.isXSSSafe =
function (a, b) { return b && null !== l.exec(a) ? !1 : null === u.exec(a) }; d.loadScript = function (a, g, k, f, h) {
    if (!a) return !1; var s = g && g.success || g, l = g && g.failure, m, z = { type: "script", success: !1 }, H = function () { J[m] = clearTimeout(J[m]); z.success ? s && s(a, m) : l && l(a, m); d.raiseEvent("externalresourceload", z, d.core) }; h = h ? "" : d.core.options.scriptBaseUri; m = h + a; d.isXSSSafe(m, !1) || (m = "function" === typeof n.encodeURIComponent ? n.encodeURIComponent(m) : n.escape(m)); z.path = h; z.src = m; z.file = a; if (!0 === c[m] && f) return z.success = !0, z.notReloaded =
!0, "function" === typeof g && (g(), d.raiseEvent("externalresourceload", z, d.core)), !0; if (b[m] && f) return !1; b[m] = !0; P[m] && P[m].parentNode && P[m].parentNode.removeChild(P[m]); g = P[m] = n.document.createElement("script"); g.type = "text/javascript"; g.src = m; k && (g["\v" === "v" ? "text" : "innerHTML"] = k); "function" === typeof s && (c[m] = !1, J[m] = clearTimeout(J[m]), g.onload = function () { c[m] = !0; z.success = !0; H() }, g.onerror = function () { c[m] = !1; b[m] = !1; H() }, g.onreadystatechange = function () {
    if ("complete" === this.readyState || "loaded" ===
this.readyState) c[m] = !0, z.success = !0, H()
}); n.document.getElementsByTagName("head")[0].appendChild(g); "function" === typeof l && (J[m] = setTimeout(function () { c[m] || H() }, d.core.options.html5ResourceLoadTimeout || 15E3)); return !0
}; d.capitalizeString = function (a, b) { return a ? a.replace(b ? /(^|\s)([a-z])/g : /(^|\s)([a-z])/, function (a, b, c) { return b + c.toUpperCase() }) : a }; d.extend(d.core, { clone: function (a, b) {
    var c = typeof a, f, h = d.extend({}, this.args, !1, !1); B(d.policies, h, this); B(d.renderer.getRendererPolicy(this.options.renderer),
h, this); delete h.id; delete h.animate; delete h.stallLoad; f = h.link; h = d.extend({}, h, !1, !1); h.link = f; switch (c) { case "object": d.extend(h, a); break; case "boolean": b = a } return b ? h : new d.core(h)
}, isActive: function () { if (!this.ref || n.document.getElementById(this.id) !== this.ref || "function" !== typeof this.ref.signature) return !1; try { return N.test(this.ref.signature()) } catch (a) { return !1 } }, chartType: function (a, b) {
    var c = this.src, f = !0 === b, h = this.options, s; "string" === typeof a && (c = a.replace(/[\?\#][\s\S]*$/g, ""), s = null !==
c.match(/\.swf\s*?$/ig), c = c.replace(/\.swf\s*?$/ig, ""), h.chartType = c.replace(/^[\s\S]*\//ig, "").replace(/^fcmap_/i, ""), h.chartTypeSourcePath = -1 === c.indexOf("/") ? d.core.options.chartTypeSourcePath || "" : c.replace(/[^\/]*?$/ig, ""), this.src = ((d.core.options.scriptBaseUri || "") + (h.chartTypeSourcePath || d.core.options.chartTypeSourcePath || "")).replace(/\/\s*$/g, "") + "/" + h.chartType.replace(/\.swf\s*?$/ig, "") + ".swf", s && (d.raiseWarning(this, "08101320181", "comp", "FusionCharts#chartType", 'Chart type has ".swf" in alias and as such has been deprecated. Please use chart type alias.'),
h.chartTypeSourcePath = d.core.options.chartTypeSourcePath || ""), b = "object" === typeof b ? b : {}, void 0 !== b.dataSource && null !== b.dataSource ? this.setChartData(b.dataSource, b.dataFormat, b.dataConfiguration) : this.isActive() && !f && this.render()); return (h.chartType || "").toLowerCase()
} 
}, !0); n.getChartFromId = function (a) {
    d.raiseWarning(this, "11133001041", "run", "GenericRuntime~getObjectFromId()", 'Use of deprecated getChartFromId() or getMapFromId(). Replace with "FusionCharts()" or FusionCharts.items[].'); return d.core.items[a] instanceof
d.core ? d.core.items[a].ref : n.swfobject && n.swfobject.getObjectById(a)
}; n.getMapFromId = n.getChartFromId
} ]);
FusionCharts.register("module", ["private", "api.printmanager", function () {
    var d = this; d.extend(d.core, { printManager: { configure: function () { d.raiseWarning(d.core, "28141714", "impl", ".printManager.configure", "PrintManager is deprecated") }, isReady: function () { d.raiseWarning(d.core, "28141714", "impl", ".printManager.isReady", "PrintManager is deprecated"); return !1 }, enabled: function () { d.raiseWarning(d.core, "28141714", "impl", ".printManager.enabled", "PrintManager is deprecated"); return !1 }, managedPrint: function () {
        d.raiseWarning(d.core,
"28141714", "impl", ".printManager.managedPrint", "PrintManager is deprecated")
    } 
    }
    }, !1)
} ]);
FusionCharts.register("module", ["private", "modules.interface.renderer", function () {
    var d = this, n = d.window, E = n.document, u = function () { d.raiseError(this, "25081845", "run", "::RendererManager", Error("No active renderer")) }, l = d.FusionChartsDOMInsertModes = { REPLACE: "replace", APPEND: "append", PREPEND: "prepend" }, b = { undefined: { render: u, remove: u, update: u, resize: u, config: u, policies: {}} }, P = {}, c = function (a) {
        return function () {
            var b = this.ref; if (void 0 === b || null === b || "function" !== typeof b[a]) d.raiseError(this, "25081617",
"run", "~" + a + "()", "ExternalInterface call failed. Check whether chart has been rendered."); else return b[a].apply(b, arguments)
        } 
    }, J = function (a, b) { return "function" === typeof a[b] ? function () { return a[b].apply(a, arguments) } : a[b] }, a = function (a, b) { var c = E.getElementById(a), f = b.id || b.getAttribute("id"), h, s; if (null === c) return !1; if (a === f) return !0; f = b.getElementsByTagName("*"); h = 0; for (s = f.length; h < s; h++) if (f[h] === c) return !1; return !0 }, B = /[^\%\d]*$/ig, N; d.policies.options.containerElementId = ["renderAt", void 0];
    d.policies.options.renderer = ["renderer", void 0]; d.normalizeCSSDimension = function (a, b, c) {
        a = void 0 === a ? c.offsetWidth || parseFloat(c.style.width) : a; b = void 0 === b ? c.offsetHeight || parseFloat(c.style.height) : b; var f = {}, h = c.style, s; h.width = a = a.toString ? a.toString() : "0"; h.height = b = b.toString ? b.toString() : "0"; if ((f.widthIsRelative = a.match(/^\s*\d*\.?\d*\%\s*$/) && !a.match(/^\s*0\%\s*$/)) && 0 === c.offsetWidth) for (s = c; s = s.offsetParent; ) if (0 < s.offsetWidth) {
            a = (s.offsetWidth * parseFloat(a.match(/\d*/)[0]) / 100).toString();
            break
        } if ((f.heightIsRelative = b.match(/^\s*\d*\.?\d*\%\s*$/) && !b.match(/^\s*0\%\s*$/)) && 20 >= c.offsetHeight) for (s = c; s = s.offsetParent; ) if (0 < s.offsetHeight) { b = (s.offsetHeight * parseFloat(b.match(/\d*/)[0]) / 100).toString(); break } f.width = a.replace ? a.replace(/^\s*(\d*\.?\d*)\s*$/ig, "$1px") : a; f.height = b.replace ? b.replace(/^\s*(\d*\.?\d*)\s*$/ig, "$1px") : b; h.width = f.width; h.height = f.height; f.pixelWidth = f.widthIsRelative ? c.offsetWidth : parseInt(f.width, 10) || 0; f.pixelHeight = f.heightIsRelative ? c.offsetHeight : parseInt(f.height,
10) || 0; return f
    }; N = d.renderer = { register: function (a, c) { if (!a || "function" !== typeof a.toString) throw Error("#03091436 ~renderer.register() Invalid value for renderer name."); a = a.toString().toLowerCase(); if (void 0 !== b[a]) return d.raiseError(d.core, "03091438", "param", "::RendererManager>register", 'Duplicate renderer name specified in "name"'), !1; b[a] = c; return !0 }, userSetDefault: !1, setDefault: function (a) {
        if (!a || "function" !== typeof a.toString) return d.raiseError(d.core, "25081731", "param", "::RendererManager>setDefault",
'Invalid renderer name specified in "name"'), !1; if (void 0 === b[a = a.toString().toLowerCase()]) return d.raiseError(d.core, "25081733", "range", "::RendererManager>setDefault", "The specified renderer does not exist."), !1; this.userSetDefault = !1; d.policies.options.renderer = ["renderer", a]; return !0
    }, notifyRender: function (a) {
        var b = d.core.items[a && a.id]; b && (!1 !== a.success || a.silent) || d.raiseError(d.core.items[a.id], "25081850", "run", "::RendererManager", Error("There was an error rendering the chart. Enable FusionCharts JS debugger for more information."));
        if (b.ref = a.ref) a.ref.FusionCharts = d.core.items[a.id]; d.raiseEvent("internal.DOMElementCreated", {}, b)
    }, protectedMethods: { options: !0, attributes: !0, src: !0, ref: !0, constructor: !0, signature: !0, link: !0, addEventListener: !0, removeEventListener: !0 }, getRenderer: function (a) { return b[a] }, getRendererPolicy: function (a) { a = b[a].policies; return "object" === typeof a ? a : {} }, currentRendererName: function () { return d.policies.options.renderer[1] }, update: function (a) {
        P[a.id].update.apply(a, Array.prototype.slice.call(arguments,
1))
    }, render: function (a) { P[a.id].render.apply(a, Array.prototype.slice.call(arguments, 1)) }, remove: function (a) { P[a.id].remove.apply(a, Array.prototype.slice.call(arguments, 1)) }, resize: function (a) { P[a.id].resize.apply(a, Array.prototype.slice.call(arguments, 1)) }, config: function (a) { P[a.id].config.apply(a, Array.prototype.slice.call(arguments, 1)) }, dispose: function (a) { P[a.id].dispose.apply(a, Array.prototype.slice.call(arguments, 1)) } 
    }; d.addEventListener("beforeInitialize", function (a) {
        a = a.sender; var c = a.options.renderer.toLowerCase(),
k; "string" === typeof a.options.renderer && void 0 === b[c] && (a.options.renderer = d.policies.options.renderer[1]); a.options.renderer = c; P[a.id] = b[a.options.renderer]; !0 !== P[a.id].initialized && "function" === typeof P[a.id].init && (P[a.id].init(), P[a.id].initialized = !0); d.parsePolicies(a, P[a.id].policies || {}, a.args); for (k in P[a.id].prototype) a[k] = P[a.id].prototype[k]; for (k in P[a.id].events) a.addEventListener(k, P[a.id].events[k])
    }); d.addEventListener("loaded", function (a) {
        var b = a.sender; a = a.sender.ref; var k, f;
        b instanceof d.core && delete b.__state.rendering; if (void 0 !== a && null !== a && "function" === typeof a.getExternalInterfaceMethods) { try { k = a.getExternalInterfaceMethods(), k = "string" === typeof k ? k.split(",") : [] } catch (h) { k = [], d.raiseError(b, "13111126041", "run", "RendererManager^Loaded", Error("Error while retrieving data from the chart-object." + (h.message && 0 <= h.message.indexOf("NPObject") ? " Possible cross-domain security restriction." : ""))) } for (f = 0; f < k.length; f += 1) a = k[f], void 0 === b[a] && (b[a] = c(a)) } 
    }); d.addEventListener("loaded",
function (a) { if (a.sender.ref) { var b = a.sender, c = N.protectedMethods, f = N.getRenderer(b.options.renderer).protectedMethods, h; for (h in a.sender) if (f && !c[h] && !f[h] && void 0 === b.ref[h]) try { b.ref[h] = J(a.sender, h) } catch (s) { } } }); d.legacyEventList.resized = "FC_Resized"; d.extend(d.core.prototype, { render: function (b, c, k) {
    var f = this, h, s, B; if ((B = n[this.id]) && B.FusionCharts && B.FusionCharts === this || (B = this.ref) && B.FusionCharts && B.FusionCharts === this) d.renderer.dispose(this), B === n[this.id] && (n[this.id] = void 0); void 0 !==
n[this.id] && d.raiseError(this, "25081843", "comp", ".render", Error("#25081843:IECompatibility() Chart Id is same as a JavaScript variable name. Variable naming error. Please use unique name forchart JS variable, chart-id and container id.")); k ? "function" !== typeof k && (k = void 0) : "function" === typeof c ? (k = c, c = void 0) : c || "function" !== typeof b || (k = b, b = void 0); c = (c || this.options.insertMode).toLowerCase() || l.REPLACE; void 0 === b && (b = this.options.containerElementId); "string" === typeof b && (b = E.getElementById(b));
    if (void 0 === b || null === b) return d.raiseError(this, "03091456", "run", ".render()", Error("Unable to find the container DOM element.")), this; if (a(this.id, b)) return d.raiseError(this, "05102109", "run", ".render()", Error("A duplicate object already exists with the specific Id: " + this.id)), this; h = E.createElement(this.options.containerElementType || "span"); h.setAttribute("id", this.id); if ("append" !== c && "prepend" !== c) for (; b.hasChildNodes(); ) b.removeChild(b.firstChild); "prepend" === c && b.firstChild ? b.insertBefore(h,
b.firstChild) : b.appendChild(h); this.options.containerElement = b; this.options.containerElementId = b.id; if (c = h.style) c.position = "relative", c.textAlign = "left", c.lineHeight = "100%", c.display = "inline-block", c.zoom = "1", c.fontWeight = "normal", c.fontVariant = "normal", c.fontStyle = "normal", c.textDecoration = "none", c["*DISPLAY"] = "inline", c.padding = "0", c.margin = "0", c.border = "none"; c = d.normalizeCSSDimension(this.width, this.height, h); this.__state.renderedWidth = c.pixelWidth; this.__state.renderedHeight = c.pixelHeight; this.__state.rendering =
!0; d.raiseEvent("beforeRender", s = { container: b, width: this.width, height: this.height, renderer: this.options.renderer }, this, void 0, function (a, b) { d.renderer.render(f, h, function () { d.renderer.notifyRender.apply(this, arguments); if (k) try { k.call(a.sender, b.container) } catch (c) { setTimeout(function () { throw c; }) } }) }, function () { d.raiseEvent("renderCancelled", s, f) }); return this
}, remove: function () { d.renderer.remove(this); return this }, resizeTo: function (a, b, c) {
    var f = this, h = f.width, s = f.height, l = f.__state; "object" === typeof a &&
(c = b, b = a.h, a = a.w); a = null === a || void 0 === a ? h : a.toString().replace(B, ""); b = null === b || void 0 === b ? s : b.toString().replace(B, ""); !0 !== c ? d.raiseEvent("beforeresize", { currentWidth: h, currentHeight: s, newWidth: a, newHeight: b }, f, void 0, function () {
    f.width = a; f.height = b; d.renderer.resize(f, { width: a, height: b }); d.raiseEventWithLegacy("resized", { width: f.width, height: f.height, prevWidth: h, prevHeight: s, pixelWidth: f.ref && f.ref.offsetWidth || 0, pixelHeight: f.ref && f.ref.offsetHeight || 0, originalWidth: l.renderedWidth, originalHeight: l.renderedHeight },
f, [f.id, f.width, f.height])
}, function () { d.raiseEvent("resizecancelled", { currentWidth: h, currentHeight: s, cancelledTargetWidth: a, cancelledTargetHeight: b }, f) }) : (f.width = a, f.height = b); return this
}, dispose: function () { var a = this, b = {}; d.raiseEvent("beforeDispose", b, a, void 0, function () { d.renderer.dispose(a); d.raiseEvent("disposed", b, a); d.disposeEvents(a); delete d.core.items[a.id]; for (var c in a) a.hasOwnProperty(c) && delete a[c]; a.disposed = !0 }, function () { d.raiseEvent("disposeCancelled", b, a) }) }, configure: function (a,
b) { var c; a && ("string" === typeof a ? (c = {}, c[a] = b) : c = a, d.renderer.config(this, c)) } 
}); d.extend(d.core, { setCurrentRenderer: function () { var a = N.setDefault.apply(N, arguments); N.userSetDefault = !0; return a }, getCurrentRenderer: function () { return N.currentRendererName.apply(N, arguments) }, render: function (a, b) { return a instanceof d.core ? (a.render(b), a) : (new d.core(a)).render(b) } }, !1)
} ]);
FusionCharts.register("module", ["private", "modules.interface.transcoder", function () {
    var d = this, n = d.window, E = d.transcoders = {}, u = {}, l = n.dc = {}, b = /url$/i, P = d._interactiveCharts = { selectscatter: [!0, !1], dragcolumn2d: [!0, !0], dragarea: [!0, !0], dragline: [!0, !0], dragnode: [!0, !0] }, c = function (b, c, s, g) { var k = s.obj; s = s.args; s.dataSource = b; s.xmlHttpRequestObject = c; s.source = "XmlHttpRequest"; s.url = g; d.raiseEvent("dataLoadRequestCompleted", s, k, void 0, a, B) }, J = function (a, b, c) {
        var g = c.obj; c = c.args; c.error = a; c.httpStatus =
b.xhr && b.xhr.status ? b.xhr.status : -1; c.xmlHttpRequestObject = b; d.raiseEvent("dataLoadError", c, g); "function" === typeof n.FC_DataLoadError && n.FC_DataLoadError(g.id, c)
    }, a = function (a, b) { a.sender.setChartData(b.dataSource, b.dataFormat, b.config, b.successcallback, b.silent) }, B = function (a, b) { d.raiseEvent("dataLoadCancelled", b, a.sender); b.xmlHttpRequestObject.abort() }, N = function (a, b) {
        var s = a.sender, g = s.__state, k = b.url; s.options.dataSource = b.url; g.dhmXhrObj || (g.dhmXhrObj = new d.ajax(c, J)); g.dhmXhrObj.get("function" ===
typeof n.decodeURIComponent ? n.decodeURIComponent(k) : n.unescape(k), { obj: s, args: b })
    }, t = function (a, b) { var c = a.sender, g = c.__state; d.raiseEvent("dataLoadRequestCancelled", b, c); g && g.dhmXhrObj && g.dhmXhrObj.abort() }, g = function (a, b) {
        var c = a.sender, g = c.__state, k = c.id; u[k] = b; l[k] && delete l[k]; l[k] = {}; g.dataReady = void 0; g.dataAvailable = !0; !0 !== b.silent && (!0 !== c.options.safeMode || !0 !== g.rendering || c.isActive() ? (delete g.args, d.renderer.update(c, b)) : (g.updatePending = b, d.raiseWarning(c, "23091255", "run", "::DataHandler~update",
"Renderer update was postponed due to async loading."))); d.raiseEvent("dataUpdated", b, c, void 0, b.successcallback)
    }, k = function (a, b) { d.raiseEvent("dataUpdateCancelled", b, a.sender, void 0, b.failurecallback) }; d.dataFormats = {}; d.policies.options.dataSource = ["dataSource", void 0]; d.policies.options.dataFormat = ["dataFormat", void 0]; d.policies.options.dataConfiguration = ["dataConfiguration", void 0]; d.policies.options.showDataLoadingMessage = ["showDataLoadingMessage", !1]; d.addDataHandler = function (a, b) {
        if ("string" !==
typeof a || void 0 !== E[a.toLowerCase()]) d.raiseError(d.core, "03091606", "param", "::DataManager.addDataHandler", Error("Invalid Data Handler Name")); else { var c = {}, g = a.toLowerCase(); E[g] = b; b.name = a; c["set" + a + "Data"] = function (b, c, h) { return this.setChartData(b, a, c, h) }; b.transportable && (c["set" + a + "Url"] = function (b, c, h) { return this.setChartDataUrl(b, a, c, h) }, d.dataFormats[a + "URL"] = g + "Url"); c["get" + a + "Data"] = function () { return this.getChartData(a) }; d.dataFormats[a] = g; d.extend(d.core, c, !0) } 
    }; d.extend(d.core.prototype,
{ setChartDataUrl: function (a, c, g, k, m) { if (void 0 === c || null === c || "function" !== typeof c.toString) c = this.options.dataFormat, d.raiseWarning(this, "03091609", "param", "FusionCharts#setChartDataUrl", "Invalid Data Format. Reverting to current data format - " + c); c = c.toString().toLowerCase(); c = b.test(c) ? c.slice(0, -3) : c; d.raiseEvent("dataLoadRequested", { source: "XmlHttpRequest", url: a, dataFormat: c, silent: !!m, config: g, successcallback: k }, this, void 0, N, t) }, setChartData: function (a, c, s, l, m) {
    var z = this.options, H, M; if (void 0 ===
c || null === c || "function" !== typeof c.toString) c = z.dataFormat, d.raiseWarning(this, "03091610", "param", "FusionCharts#setChartData", "Invalid Data Format. Reverting to current data format - " + c); c = c.toString().toLowerCase(); b.test(c) ? this.setChartDataUrl(a, c, s, l, m) : (z.dataSource = a, H = c, z.dataFormat = c, M = E[H], "undefined" === typeof M ? d.raiseError(d.core, "03091611", "param", "FusionCharts#setChartData", Error("Data Format not recognized")) : (c = (c = d.renderer && d.renderer.getRenderer(z.renderer || d.renderer.currentRendererName())) &&
c.dataFormat, s = c === H ? M.passthrough ? M.passthrough(a, s) : { data: a} : M.encode(a, this, s || z.dataConfiguration) || {}, s["native"] = c === H, s.format = s["native"] ? c : "xml", s.dataFormat = H, s.dataSource = a, s.silent = !!m, "function" === typeof l && (s.successcallback = l), d.raiseEvent("beforeDataUpdate", s, this, void 0, g, k)))
}, getChartData: function (a, b) {
    var c = this.options, g = this.id, k; if (void 0 === a || "function" !== typeof a.toString || void 0 === (k = E[a = a.toString().toLowerCase()])) d.raiseError(this, "25081543", "param", "~getChartData()",
Error('Unrecognized data-format specified in "format"')); else return l[g][a] ? c = l[g][a] : u[g] ? (a === u[g].format ? l[g][a] = u[g] : (l[g].xml || (l[g].xml = "xml" === u[g].format ? u[g] : E[u[g].format].encode(u[g].data, this, c.dataConfiguration)), l[g][a] || (l[g][a] = k.decode(l[g].xml.data, this, c.dataConfiguration))), c = l[g][a]) : c = { error: Error("Data not defined") }, !0 === Boolean(b) ? c : c.data
}, dataReady: function (a) { return a ? this.__state.dataAvailable : this.__state.dataReady } 
}); d.extend(d.core, { transcodeData: function (a, b, c, g,
k) { if (b && "function" === typeof b.toString && c && "function" === typeof c.toString && void 0 !== E[c = c.toString().toLowerCase()] && void 0 !== E[b = b.toString().toLowerCase()]) return a = E[b].encode(a, this, k), c = E[c].decode(a.data, this, k), c.error instanceof Error || (c.error = a.error), g ? c : c.data; d.raiseError(this, "14090217", "param", "transcodeData()", Error("Unrecognized data-format specified during transcoding.")) } 
}, !1); d.getRenderer && !d.getRenderer("flash") || d.addEventListener("DataLoadRequested", function (a) {
    var b = a.sender;
    b.options && "flash" === b.options.renderer && b.options.useLegacyXMLTransport && a.preventDefault()
}); d.addEventListener("beforeInitialize", function (a) {
    a = a.sender; var b = a.options, c = b.dataSource, g = d.renderer && d.renderer.getRenderer(b.renderer); delete u[a.id]; l[a.id] = {}; if (void 0 !== c && null !== c) {
        a.__state.dataSetDuringConstruction = !0; if ("string" !== typeof b.dataFormat) switch (typeof c) {
            case "function": c = b.dataSource = c.call(a, b.dataConfiguration); b.dataFormat = "JSON"; break; case "string": b.dataFormat = /^\s*?\{[\s\S]*\}\s*?$/g.test(a.options.dataFormat) ?
"JSON" : "XML"; break; case "object": b.dataFormat = "JSON"
        } a.setChartData(c, b.dataFormat, void 0, void 0, !0)
    } else g && (a.__state.dataSetDuringConstruction = !1, d.raiseWarning(a, "1810131922A", "param", ":dataHandler~event:beforeInitialize", "Data source was not defined during construction, hence set to blank renderer default - " + g.dataFormat), a.setChartData("", g.dataFormat, void 0, void 0, !0), a.__state.dataAvailable = !1)
}); d.addEventListener("beforeDispose", function (a) {
    var b = a.sender; delete u[a.sender.id]; delete l[a.sender.id];
    b && b.__state && b.__state.dhmXhrObj && b.__state.dhmXhrObj.abort()
}); d.addEventListener("disposed", function (a) { delete l[a.sender.id] }); d.addEventListener("loaded", function (a) { a = a.sender; a instanceof d.core && void 0 !== a.__state.updatePending && (d.renderer.update(a, a.__state.updatePending), delete a.__state.updatePending) }); d.addEventListener(["dataLoadError", "dataInvalid"], function (a) { a.sender.__state.dataAvailable = !1 }); d.addEventListener("loaded", function (a) {
    a = a.sender; var b = a.__state, c, g, k; k = function (a,
b) { return function (c) { return !1 === c ? b.apply(this) : this.ref.getUpdatedXMLData ? d.core.transcodeData(this.ref.getUpdatedXMLData(), "xml", a) : this.getData ? this.getData(a) : b.apply(this) } }; if (a.chartType && P[a.chartType()] && P[a.chartType()][0]) { for (c in d.transcoders) g = d.transcoders[c].name, g = "get" + g + "Data", a[g] = k(c, a.constructor.prototype[g]), a[g]._dynamicdatarouter = !0; b.dynamicDataRoutingEnabled = !0 } else if (b.dynamicDataRoutingEnabled) {
        for (c in d.transcoders) g = d.transcoders[c].name, g = "get" + g + "Data", a.hasOwnProperty(g) &&
a[g]._dynamicdatarouter && delete a[g]; b.dynamicDataRoutingEnabled = !1
    } 
})
} ]); "object" !== typeof JSON && (JSON = {});
(function () {
    function d(a) { return 10 > a ? "0" + a : a } function n(a) { l.lastIndex = 0; return l.test(a) ? '"' + a.replace(l, function (a) { var b = c[a]; return "string" === typeof b ? b : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4) }) + '"' : '"' + a + '"' } function E(a, c) {
        var d, l, g, k, f = b, h, s = c[a]; s && "object" === typeof s && "function" === typeof s.toJSON && (s = s.toJSON(a)); "function" === typeof J && (s = J.call(c, a, s)); switch (typeof s) {
            case "string": return n(s); case "number": return isFinite(s) ? String(s) : "null"; case "boolean": case "null": return String(s);
            case "object": if (!s) return "null"; b += P; h = []; if ("[object Array]" === Object.prototype.toString.apply(s)) { k = s.length; for (d = 0; d < k; d += 1) h[d] = E(d, s) || "null"; g = 0 === h.length ? "[]" : b ? "[\n" + b + h.join(",\n" + b) + "\n" + f + "]" : "[" + h.join(",") + "]"; b = f; return g } if (J && "object" === typeof J) for (k = J.length, d = 0; d < k; d += 1) "string" === typeof J[d] && (l = J[d], (g = E(l, s)) && h.push(n(l) + (b ? ": " : ":") + g)); else for (l in s) Object.prototype.hasOwnProperty.call(s, l) && (g = E(l, s)) && h.push(n(l) + (b ? ": " : ":") + g); g = 0 === h.length ? "{}" : b ? "{\n" + b + h.join(",\n" +
b) + "\n" + f + "}" : "{" + h.join(",") + "}"; b = f; return g
        } 
    } "function" !== typeof Date.prototype.toJSON && (Date.prototype.toJSON = function () { return isFinite(this.valueOf()) ? this.getUTCFullYear() + "-" + d(this.getUTCMonth() + 1) + "-" + d(this.getUTCDate()) + "T" + d(this.getUTCHours()) + ":" + d(this.getUTCMinutes()) + ":" + d(this.getUTCSeconds()) + "Z" : null }, String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function () { return this.valueOf() }); var u = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
l = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, b, P, c = { "\b": "\\b", "\t": "\\t", "\n": "\\n", "\f": "\\f", "\r": "\\r", '"': '\\"', "\\": "\\\\" }, J; "function" !== typeof JSON.stringify && (JSON.stringify = function (a, c, d) { var l; P = b = ""; if ("number" === typeof d) for (l = 0; l < d; l += 1) P += " "; else "string" === typeof d && (P = d); if ((J = c) && "function" !== typeof c && ("object" !== typeof c || "number" !== typeof c.length)) throw Error("JSON.stringify"); return E("", { "": a }) });
    "function" !== typeof JSON.parse && (JSON.parse = function (a, b) {
        function c(a, d) { var f, h, s = a[d]; if (s && "object" === typeof s) for (f in s) Object.prototype.hasOwnProperty.call(s, f) && (h = c(s, f), void 0 !== h ? s[f] = h : delete s[f]); return b.call(a, d, s) } var d; a = String(a); u.lastIndex = 0; u.test(a) && (a = a.replace(u, function (a) { return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4) })); if (/^[\],:{}\s]*$/.test(a.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
"]").replace(/(?:^|:|,)(?:\s*\[)+/g, ""))) return d = eval("(" + a + ")"), "function" === typeof b ? c({ "": d }, "") : d; throw new SyntaxError("JSON.parse");
    })
})();
FusionCharts.register("module", ["private", "modules.data.json", function () {
    var d = this, n = d.window, E = n.document, u = function (b) { return null === b || void 0 === b || "function" !== typeof b.toString ? "" : b = b.toString().replace(/&/g, "&amp;").replace(/\'/g, "&#39;").replace(/\"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;") }, l, b; void 0 === n.JSON && d.raiseError(this, "1113062012", "run", "JSONDataHandler", Error("Could not find library support for JSON parsing.")); d.policies.options.allowIESafeXMLParsing = ["_allowIESafeXMLParsing",
!0]; l = function () {
    var b = { set: !0, trendlines: !0, vtrendlines: !0, line: { trendlines: !0, vtrendlines: !0 }, data: !0, dataset: !0, lineset: !0, categories: !0, category: !0, linkeddata: !0, application: !0, definition: !0, axis: !0, connectors: !0, connector: { connectors: !0 }, trendset: !0, row: { rows: !0 }, column: { columns: !0 }, label: { labels: !0 }, color: { colorrange: !0 }, dial: { dials: !0 }, pointer: { pointers: !0 }, point: { trendpoints: !0 }, process: { processes: !0 }, task: { tasks: !0 }, milestone: { milestones: !0 }, datacolumn: { datatable: !0 }, text: { datacolumn: !0 },
        item: { legend: !0 }, alert: { alerts: !0 }, groups: { annotations: !0 }, items: { groups: !0, data: !0 }, shapes: !0, shape: { shapes: !0 }, entitydef: !0, entity: { entitydef: !0}
    }, c = { chart: "linkedchart", map: "linkedmap", set: "data", vline: { chart: "data", graph: "data", dataset: "data", categories: "category", linkedchart: "data" }, apply: { application: "application" }, style: { definition: "definition" }, marker: { application: "application", definition: "definition", data: "items" }, entity: { entitydef: "entitydef", data: "data" }, shape: { shapes: "shapes" }, connector: { connectors: { chart: "connector",
        linkedchart: "connector", map: "connectors", linkedmap: "connectors"
    }
    }, annotationgroup: { annotations: "groups" }, annotation: { groups: "items"}
    }, l = { vline: { vline: "true"} }, a = { chart: !0, map: !0, graph: !0 }, B = { dataset: "data", categories: "category" }, N = { target: "target", value: "value" }, t = { styles: { definition: !0, application: !0 }, chart: { value: !0, target: !0 }, graph: { value: !0, target: !0 }, linkedchart: { value: !0, target: !0 }, markers: { definition: !0, application: !0, shapes: !0, connectors: !0, data: !0 }, map: { entitydef: !0, data: !0 }, linkedmap: { entitydef: !0,
        data: !0
    }
    }, g, k; g = { append: function (a, c, g, d) { !b[g] || !0 !== b[g] && !0 !== b[g][d] ? c[g] = a : (c[g] instanceof Array || (c[g] = []), c[g].push(a)) }, child: function (b, h, k, n) {
        var m, z, H, M, $, C; for (m = 0; m < h.length; m += 1) switch (H = h[m], z = H.nodeName.toLowerCase(), H.nodeType) {
            case 1: M = g.attr(H.attributes); C = a[z]; !0 === C && ($ = M, M = {}, M[z] = $); C = l[z]; "object" === typeof C && d.extend(M, C); if (C = c[z]) if ("object" === typeof C && "object" === typeof C[k]) for ($ in $ = void 0, C[k]) { if (n[$]) { z = C[k][$]; break } } else "object" === typeof C && "string" === typeof C[k] ?
z = C[k] : "string" === typeof C && (z = C); H.childNodes.length && ((C = t[k]) && C[z] ? g.child(b, H.childNodes, z, n) : g.child(M, H.childNodes, z, n)); (C = t[k]) && C[z] || g.append(M, b, z, k); break; case 3: if (C = N[k]) z = C, M = H.data, g.append(M, b, z, k); C = B[k]; "string" === typeof C && n.chart && parseInt(n.chart.compactdatamode, 10) && (z = C, M = H.data, b[z] = b[z] ? b[z] + M : M)
        } 
    }, attr: function (a) { var b, c = {}; if (!a || !a.length) return c; for (b = 0; b < a.length; b += 1) c[a[b].nodeName.toLowerCase()] = a[b].value || a[b].nodeValue; return c } 
    }; k = function (a) {
        var b = {}, c, l,
m, z, H, M, B, C, J; if ("object" !== typeof a && a && "function" !== typeof a.toString) return k.errorObject = new TypeError("xml2json.parse()"), b; a = a.toString().replace(/<\!--[\s\S]*?--\x3e/g, "").replace(/<\?xml[\s\S]*?\?>/ig, "").replace(/&(?!([^;\n\r]+?;))/g, "&amp;$1"); a = a.replace(/^\s\s*/, ""); for (var t = /\s/, N = a.length; t.test(a.charAt(N -= 1)); ); a = a.slice(0, N + 1); if (!a) return b; try {
            n.DOMParser ? c = (new n.DOMParser).parseFromString(a, "text/xml") : E.body && d.core.options.allowIESafeXMLParsing ? (l = E.createElement("xml"), l.innerHTML =
a, E.body.appendChild(l), c = l.XMLDocument, E.body.removeChild(l)) : (c = new n.ActiveXObject("Microsoft.XMLDOM"), c.async = "false", c.loadXML(a)); if (!(c && c.childNodes && 1 === c.childNodes.length && (m = c.childNodes[0]) && m.nodeName && (z = m.nodeName.toLowerCase())) || "chart" !== z && "map" !== z && "graph" !== z) return k.errorObject = new TypeError("xml2json.parse()"), b; if ("graph" === z) {
                H = c.createElement("chart"); for (J = (B = m.attributes) && B.length || 0; J--; ) H.setAttribute(B[J].name, B[J].value), B.removeNamedItem(B[J].name); if (J = (C = m.childNodes) &&
C.length || 0) J -= 1, M = m.removeChild(C[J]), H.appendChild(M); for (; J--; ) M = m.removeChild(C[J]), H.insertBefore(M, H.firstChild); c.replaceChild(H, m); m = H
            } 
        } catch (u) { k.errorObject = u } m ? (m.attributes && (b[z] = g.attr(m.attributes)), m.childNodes && g.child(b, m.childNodes, z, b), delete k.errorObject) : k.errorObject = new TypeError("xml2json.parse()"); return b
    }; return function (a) { delete k.errorObject; return { data: k(a), error: k.errorObject} } 
} (); b = function () {
    var b, c; b = { items: { explode: { data: "set", groups: { annotations: "annotationgroup" },
        items: { groups: "annotation"}
    }, text: { chart: { target: "target", value: "value" }, graph: { target: "target", value: "value"} }, dsv: { dataset: { data: "dataset" }, categories: { category: "categories"} }, attr: { chart: { chart: "chart" }, graph: { graph: "graph" }, map: { map: "map" }, linkedmap: { map: "map" }, linkedchart: { chart: "chart"} }, group: { styles: { definition: "style", application: "apply" }, map: { data: "entity", entitydef: "entity" }, markers: { definition: "marker", application: "marker", shapes: "shape", connectors: "connector", items: "marker"} }, tag: { markers: { items: "data"}}
    },
        qualify: function (b, a, c) { return "object" === typeof this.items[b][c] ? this.items[b][c][a] : this.items[b][c] } 
    }; c = function (d, a, l, n) {
        var t = "", g = "", k = "", f = "", h, s, sa; a && "function" === typeof a.toLowerCase && (a = a.toLowerCase()); if (void 0 === l && d[a]) for (h in d[a]) s = h.toLowerCase(), "compactdatamode" === s && (n.applyDSV = 1 == d[a][h]); if (d instanceof Array) for (h = 0; h < d.length; h += 1) k = "string" === typeof d[h] ? k + u(d[h]) : k + c(d[h], a, l, n); else {
            for (h in d) s = h.toLowerCase(), d[h] instanceof Array && (sa = b.qualify("group", s, a)) ? (k = b.qualify("tag",
s, a) || s, g += "<" + k + ">" + c(d[h], sa, a, n) + "</" + k + ">") : "object" === typeof d[h] ? (sa = b.qualify("attr", s, a)) ? (f = c(d[h], sa, a, n).replace(/\s*\/\>/ig, ""), a = s) : g += c(d[h], s, a, n) : n.applyDSV && (sa = b.qualify("dsv", s, a)) ? g += d[h] : (sa = b.qualify("text", s, a)) ? (k = b.qualify("tag", s, a) || sa, g += "<" + k + ">" + d[h] + "</" + k + ">") : "vline" === s && Boolean(d[h]) ? a = "vline" : t += " " + s + '="' + u(d[h]).toString().replace(/\"/ig, "&quot;") + '"'; if (sa = b.qualify("explode", l, a)) a = sa; k = a; k = ("" !== f ? f : "<" + k) + t + ("" !== g ? ">" + g + "</" + k + ">" : " />")
        } return k
    }; return function (b) {
        delete c.errorObject;
        if (b && "string" === typeof b) try { b = JSON.parse(b) } catch (a) { c.errorObject = a } return { data: c(b, b && b.graph ? "graph" : b && b.map ? "map" : "chart", void 0, {}), error: c.errorObject}
    } 
} (); d.addDataHandler("JSON", { encode: b, decode: l, passthrough: function (b) { var c = { data: {} }; if (!b) return c; if ("string" !== typeof b) try { b = JSON.stringify(b) } catch (d) { return c.error = d, c } try { c.data = JSON.parse(b.replace(/"([^"]+)":/g, function (a, b) { return '"' + b.toLowerCase() + '":' })) } catch (a) { c.error = a } return c }, transportable: !0 })
} ]);
FusionCharts.register("module", ["private", "modules.data.xml", function () { var d = function (d) { return { data: d, error: void 0} }; this.addDataHandler("XML", { encode: d, decode: d, transportable: !0 }) } ]);
FusionCharts.register("module", ["private", "modules.data.csv", function () {
    var d = this, n = d.window, E = d.core, u = n.parseInt, l = n.parseFloat, b = function (b) { return b }, P; P = function (b) { this.data = []; this.columnCount = this.rowCount = 0; this.configure(b) }; P.decodeLiterals = function (b, d) { return void 0 !== b && null !== b && b.toString ? b.replace("{tab}", "\t").replace("{quot}", '"').replace("{apos}", "'") : d }; P.prototype.set = function (b, d, a) {
        var l; if (this.rowCount <= b) { for (l = this.rowCount; l <= b; l += 1) this.data[l] = []; this.rowCount = b + 1 } this.columnCount <=
d && (this.columnCount = d + 1); this.data[b][d] = a
    }; P.prototype.setRow = function (b, d) { var a; if (this.rowCount <= b) { for (a = this.rowCount; a <= b; a += 1) this.data[a] = []; this.rowCount = b + 1 } this.columnCount < d.length && (this.columnCount = d.length); this.data[b] = d }; P.prototype.get = function (b, d) { var a = this.data; return a[b] && a[b][d] }; P.prototype.configure = function (b) {
        var d = P.decodeLiterals; this.delimiter = d(b.delimiter, ","); this.qualifier = d(b.qualifier, '"'); this.eolCharacter = d(b.eolCharacter, "\r\n"); this.numberFormatted = !!u(b.numberFormatted,
0)
    }; P.prototype.clear = function () { this.data = []; this.columnCount = this.rowCount = 0 }; P.prototype.toString = function () { var b, d, a = ""; for (b = 0; b < this.rowCount; b += 1) d = this.qualifier + this.data[b].join(this.qualifier + this.delimiter + this.qualifier) + this.qualifier, a += '""' === d ? this.eolCharacter : d + this.eolCharacter; 0 < this.rowCount && (a = a.slice(0, a.length - 2)); return a }; d.addDataHandler("CSV", { encode: function (b, l) {
        d.raiseError(l, "0604111215A", "run", "::CSVDataHandler.encode()", "FusionCharts CSV data-handler only supports encoding of data.");
        throw Error("FeatureNotSupportedException()");
    }, decode: function (c) {
        var d = E.transcodeData(c, "xml", "json") || {}, a, B, n, t, g, k, f, h = d.chart || d.map || d.graph || {}, s = Boolean(h.exporterrorcolumns || 0), u = d.categories && d.categories[0] && d.categories[0].category || []; t = d.map && !d.chart; var m = !1, z = !1, H = !1, M = !1; a = !1; var $ = b, C = {}, V, ba, da, xa, ua, S, ca, ha, w, Q, K; g = 0; c = new P({ separator: h.exportdataseparator, qualifier: h.exportdataqualifier, numberFormatted: h.exportdataformattedval }); E.formatNumber && c.numberFormatted && ($ = function (a) {
            return E.formatNumber(a,
h)
        }); if (t) C.geo = !0, c.setRow(0, ["Id", " Short Name", "Long Name", "Value", "Formatted Value"]); else if (void 0 !== (V = d.dials && d.dials.dial || d.pointers && d.pointers.pointer || d.value)) if (C.gauge = !0, "string" === typeof V) c.set(0, 0, $(V)), C.singlevalue = !0, "string" === typeof d.target && (c.set(0, 1, $(d.target)), C.bullet = !0); else for (c.setRow(0, ["Id", "Value"]), C.multivalue = !0, t = 0, k = 1, g = V.length; t < g; t += 1, k += 1) c.setRow(k, [k, $(V[t].value)]); else if (V = d.dataset || !(d.data instanceof Array) && []) {
            C.multiseries = !0; B = 1; if (ba =
d.lineset) V = V.concat(ba), C.lineset = !0; if (da = d.axis) V = V.concat(da), C.multiaxis = !0; S = V.length; ua = u.length; if (!(S = V.length)) { for (t = 0; t < ua; t += 1) ca = u[t], c.set(t + 1, 0, ca.label || ca.name); C.multilevel = !0 } for (t = 0; t < S; t += 1) for (ha = V, ha[t].dataset ? (ha = ha[t].dataset, n = 0, xa = ha.length) : (ha = V, n = t, xa = n + 1); n < xa && !m && !H; n += 1, B += 1) {
                w = ha[n]; c.set(0, B, w.seriesname); "string" === typeof w.data && (C.compactdata = !0, w.data = w.data.split(h.dataseparator || "|")); k = g = 0; for (Q = w.data && w.data.length || 0; g < Q || g < ua; g += 1) {
                    ca = u[g]; a = k + 1; K =
w.data && w.data[k] || {}; if (void 0 !== K.x && void 0 !== K.y) { m = C.xy = !0; break } if (void 0 !== K.open || void 0 !== K.high || void 0 !== K.close || void 0 !== K.low) { M = C.ohlc = !0; break } if (void 0 !== K.rowid && void 0 !== K.columnid) { H = C.heatmap = !0; break } if (g < ua && !ca.vline) { c.set(a, 0, ca.label || ca.name); ca = l(K ? K.value : ""); ca = isNaN(ca) ? "" : $(ca); c.set(a, B, ca); if (z || s || K.errorvalue) z || c.set(0, B + 1, "Error"), f = 1, c.set(a, B + 1, $(K.errorvalue)); k += 1 } 
                } f && (B += f, f = 0)
            } ba && (V = V.slice(0, -ba.length)); da && (V = V.slice(0, -da.length))
        } else if (V = d.data) {
            c.set(0,
1, h.yaxisname || "Value"); C.singleseries = !0; a = "1" == h.showsumatend; t = 0; for (ua = V.length; t < ua; t += 1) K = V[t], K.vline || (ca = l(K.value ? K.value : ""), c.setRow(t + 1, [K.label || K.name, isNaN(ca) ? "" : (g += ca, $(ca))])); a && (C.summation = !0, c.setRow(t + 1, [h.sumlabel || "Total", $(g)]))
        } if (M) for (c.clear(), c.setRow(0, ["Open", "Close", "High", "Low"]), t = 0, a = 1, V = d.dataset, xa = V.length; t < xa; t += 1) for (g = 0, w = V[t] && V[t].data || [], S = w.length; g < S; g += 1, a += 1) K = w[g] || {}, c.setRow(g + 1, [$(K.open), $(K.close), $(K.high), $(K.low)]); else if (m) for (c.clear(),
z = !1, f = 0, c.setRow(0, ["Series", "x", "y"]), t = 0, a = 1, V = d.dataset, xa = V.length; t < xa; t += 1) for (g = 0, w = V[t] && V[t].data || [], S = w.length; g < S; g += 1, a += 1) {
            K = w[g] || {}; ca = [V[t].seriesname, $(K.x), $(K.y)]; void 0 !== K.z && (ca.push($(K.z)), f || (c.set(0, 3, "z"), f = 1)); if (z || s || void 0 !== K.errorvalue || void 0 !== K.horizontalerrorvalue || void 0 !== K.verticalerrorvalue) d = $(K.errorvalue), ca.push(K.errorvalue, void 0 === K.horizontalerrorvalue ? d : $(K.horizontalerrorvalue), void 0 === K.verticalerrorvalue ? d : $(K.verticalerrorvalue)), z || (c.set(0,
f + 3, "Error"), c.set(0, f + 4, "Horizontal Error"), c.set(0, f + 5, "Vertical Error")), z = C.error = !0; c.setRow(a, ca)
        } else if (H) {
            c.clear(); s = {}; z = {}; t = 0; g = 1; u = d.rows && d.rows.row || []; for (f = u.length; t < f; t += 1, g += 1) ca = u[t], ca.id && (s[ca.id.toLowerCase()] = g, c.set(g, 0, ca.label || ca.id)); t = 0; g = 1; u = d.columns && d.columns.column || []; for (f = u.length; t < f; t += 1, g += 1) ca = u[t], ca.id && (z[ca.id.toLowerCase()] = g, c.set(0, g, ca.label || ca.id)); w = d.dataset && d.dataset[0] && d.dataset[0].data || []; t = 0; for (f = w.length; t < f; t += 1) K = w[t], a = K.rowid.toLowerCase(),
B = K.columnid.toLowerCase(), s[a] || (s[a] = c.rowCount, c.set(c.rowCount, 0, K.rowid)), z[B] || (z[B] = c.columnCount, c.set(0, c.columnCount, K.columnid)), c.set(s[a], z[B], $(K.value))
        } V = u = ba = da = null; 0 < c.rowCount && void 0 === c.get(0, 0) && c.set(0, 0, h.xaxisname || "Label"); return { data: c.toString(), error: void 0, predictedFormat: C}
    }, transportable: !1
    }); E.addEventListener("Loaded", function (b) { b = b.sender; "javascript" !== b.options.renderer || b.getDataAsCSV || (b.getDataAsCSV = b.ref.getDataAsCSV = b.getCSVData) })
} ]);
FusionCharts.register("module", ["private", "modules.renderer.js", function () {
    var d = this, n = d.window, E = n.document, u = d.core.options, l = /msie/i.test(n.navigator.userAgent) && !n.opera, b = Boolean(n.SVGAngle || E.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1")), P = function () { }, c = d.hcLib = { cmdQueue: [] }, J = c.moduleCmdQueue = { base: [], charts: [], powercharts: [], widgets: [], maps: [] }, a = c.moduleDependencies = {}, B = c.moduleMeta = { base: "fusioncharts.js", charts: "fusioncharts.charts.js", powercharts: "fusioncharts.powercharts.js",
        widgets: "fusioncharts.widgets.js", maps: "fusioncharts.maps.js"
    }, N = {}, t = c.getMetaSentence = function () { var a = {}; return function (b) { b = b && b.replace(/(^\s*)|(\s*$)/g, "") || ""; return a[b] || (a[b] = { key: b, subject: b.replace(/[^\/]*?$/ig, ""), predicate: b.replace(/^.*\//ig, "") }) } } (), g = c.getDependentModuleName = function (b) { var c = [], d, g; b = t(b).predicate; for (d in a) void 0 !== (g = a[d][b]) && (c[g] = d); return c }, k = c.hasModule = function (a) {
        var b, c; if (a instanceof Array) {
            b = 0; for (c = a.length; b < c; b += 1) if (!Boolean(d.modules["modules.renderer.js-" +
t(a[b]).predicate])) return !1; return !0
        } return Boolean(d.modules["modules.renderer.js-" + t(a).predicate])
    }, f = c.loadModule = function (a, b, c, g) {
        a instanceof Array || (a = [a]); var f = a.length, h = 0, s; s = function () {
            if (h >= f) b && b(); else {
                var m = a[h], l = m && m.match(/[^\/]*$/i)[0], t = B[m]; h += 1; if (m) { if (k(l)) { s(); return } if (N[l]) { d.raiseError(g || d.core, "1112201445A", "run", "JavaScriptRenderer~loadModule() ", "required resources are absent or blocked from loading."); c && c(l); return } } else c && c(l); m = d.core.options["html5" + d.capitalizeString(l) +
"Src"]; d.loadScript(void 0 === m ? t : m, { success: function () { k(l) ? s() : c && c(l) }, failure: c && function () { c(l) } }, void 0, !0)
            } 
        }; s()
    }, h = c.executeWaitingCommands = function (a) { for (var b; b = a.shift(); ) "object" === typeof b && P[b.cmd].apply(b.obj, b.args) }, s = function (a) { delete a.sender.jsVars._reflowData; a.sender.jsVars._reflowData = {}; delete a.sender.jsVars._reflowClean }, sa = function () {
        var a = function () { }; a.prototype = { LoadDataErrorText: "Error in loading data.", XMLLoadingText: "Retrieving data. Please wait", InvalidXMLText: "Invalid data.",
            ChartNoDataText: "No data to display.", ReadingDataText: "Reading data. Please wait", ChartNotSupported: "Chart type not supported.", PBarLoadingText: "", LoadingText: "Loading chart. Please wait", RenderChartErrorText: "Unable to render chart."
        }; return a.prototype.constructor = a
    } (), m = c.getContainerBackgroundColor = function (a) {
        var d = a.options.containerBackgroundColor, g = a.options.containerBackgroundOpacity; isNaN(g) ? g = a.jsVars.transparent ? 0 : 1 : (g = parseFloat(g), 0 > g ? g = 0 : 1 < g && (g = 1)); d || (d = "#ffffff"); if (l && !b) return g ?
d : "transparent"; d = d.replace(/^#?([a-f0-9]+)/ig, "$1"); d = c.graphics.HEXtoRGB(d); d[3] = g.toString(); return "rgba(" + d.join(",") + ")"
    }; c.injectModuleDependency = function (b, d, g) { var f = !1, h = t(b).subject; b = t(b).predicate; d = void 0 === d ? b : t(d).predicate; a[b] || (a[b] = {}, J[b] || (J[b] = [], c.moduleMeta[b] = h + u.html5ScriptNamePrefix + (d && d.replace && d.replace(/^[\s\S]*\//ig, "").replace(/\?/g, "%3F").replace(/\#/g, "%23").replace(/\:/g, "%3A") || "") + u.html5ScriptNameSuffix), f = !0); a[b][d] = g || 0; return f }; c.needsModule = function (a,
b) { a = t(a).predicate; b = t(b).predicate; return void 0 !== (c.moduleDependencies[a] && c.moduleDependencies[a][b]) }; c.cleanupWaitingCommands = function (a) { for (var b = a.chartType(), b = g(b), c, d = [], f; c = b.shift(); ) { for (c = J[c] || []; f = c.shift(); ) "object" === typeof f && f.obj !== a && d.push(f); c.concat(d); d = [] } }; d.extend(d.core.options, { html5ScriptNameSuffix: ".js", html5ScriptNamePrefix: "fusioncharts." }); d.extend(P, { dataFormat: "json", ready: !1, policies: { jsVars: {}, options: { showChartLoadingMessage: ["showChartLoadingMessage", !0]} },
    init: function () { k("base") ? P.ready = !0 : f("base", function () { P.ready = !0; h(c.cmdQueue) }, void 0, d.core) }, render: function (a) {
        var b = a, d = this.jsVars.msgStore; b && this.options.showChartLoadingMessage && (b.innerHTML = '<small style="display: inline-block; *zoom:1; *display:inline; width: 100%; font-family: Verdana,sans; font-size: 10px; color: #666666; text-align: center; padding-top: ' + (parseInt(b.style.height, 10) / 2 - 5) + 'px">' + (d.PBarLoadingText || d.LoadingText) + "</small>", b.style.backgroundColor = m(this)); c.cmdQueue.push({ cmd: "render",
            obj: this, args: arguments
        })
    }, update: function () { c.cmdQueue.push({ cmd: "update", obj: this, args: arguments }) }, resize: function () { c.cmdQueue.push({ cmd: "resize", obj: this, args: arguments }) }, dispose: function () { var a = c.cmdQueue, b, d; b = 0; for (d = a.length; b < d; b += 1) a[b].obj === this && (a.splice(b, 1), d -= 1, b -= 1) }, load: function () { c.cmdQueue.push({ cmd: "load", obj: this, args: arguments }) }, config: function (a, b) {
        var c, d = this.jsVars, g = d.msgStore, d = d.cfgStore; "string" === typeof a && 1 < arguments.length && (c = a, a = {}, a[c] = b); for (c in a) void 0 !==
g[c] ? g[c] = a[c] : d[c.toLowerCase()] = a[c]
    }, protectedMethods: {}, events: { beforeInitialize: function (a) {
        var b = a.sender, g = b.options; a = b.jsVars; var f; "string" === typeof g.chartType ? f = this.chartType(g.chartType) : "string" === typeof b.src && (d.raiseWarning(b, "08101320151", "comp", ":JavaScriptRenderer~event.beforeInitialize", 'Chart type was set using swfUrl parameter and has been deprecated for JS variant of charts. Use "type" parameter instead.'), f = this.chartType(b.src)); a.fcObj = b; a.msgStore = a.msgStore || new sa; a.cfgStore =
a.cfgStore || {}; a.previousDrawCount = -1; a.drawCount = 0; a._reflowData = {}; b.addEventListener("beforeRender", function (a) { a.sender.jsVars.smartLabel = new c.SmartLabelManager(b.id, E.body || E.getElementsByTagName("body")[0]); a.detachHandler() }); a.userModules instanceof Array || (g = a.userModules, a.userModules = [], "string" === typeof g && (a.userModules = a.userModules.concat(g.split(",")))); c.chartAPI && c.chartAPI[f] || (a.needsLoaderCall = !0)
    }, initialized: function (a) {
        a = a.sender; var b = a.jsVars; b.needsLoaderCall && (delete b.needsLoaderCall,
P.load.call(a))
    }, beforeDataUpdate: s, beforeDispose: function (a) { var b = a.sender.jsVars; b.smartLabel && !b.smartLabel.disposed && b.smartLabel.dispose(); s.apply(this, arguments) }, beforeRender: function (a) { var b = a.sender.jsVars; delete b.drLoadAttempted; delete b.waitingModule; delete b.waitingModuleError; s.apply(this, arguments) }, dataLoadRequested: function (a) {
        a = a.sender; var b = a.jsVars; delete b.loadError; a.ref && a.options.showDataLoadingMessage ? b.hcObj && !b.hasNativeMessage && b.hcObj.showLoading ? b.hcObj.showMessage(b.msgStore.XMLLoadingText) :
a.ref.showChartMessage ? a.ref.showChartMessage("XMLLoadingText") : b.stallLoad = !0 : b.stallLoad = !0
    }, dataLoadRequestCompleted: function (a) { delete a.sender.jsVars.stallLoad }, dataLoadError: function (a) { var b = a.sender, c = b.jsVars; delete c.stallLoad; c.loadError = !0; b.ref && "function" === typeof b.ref.showChartMessage && b.ref.showChartMessage("LoadDataErrorText"); s.apply(this, arguments) } 
    }, _call: function (a, b, c) { a.apply(c || n, b || []) } 
}); d.extend(P.prototype, { getSWFHTML: function () {
    d.raiseWarning(this, "11090611381", "run",
"JavaScriptRenderer~getSWFHTML()", "getSWFHTML() is not supported for JavaScript charts.")
}, addVariable: function () { d.raiseWarning(this, "11090611381", "run", "JavaScriptRenderer~addVariable()", 'Use of deprecated "addVariable()". Replace with "configure()".'); d.core.prototype.configure.apply(this, arguments) }, getXML: function () { d.raiseWarning(this, "11171116291", "run", "JavaScriptRenderer~getXML()", 'Use of deprecated "getXML()". Replace with "getXMLData()".'); return this.getXMLData.apply(this, arguments) },
    setDataXML: function () { d.raiseWarning(this, "11171116292", "run", "JavaScriptRenderer~setDataXML()", 'Use of deprecated "setDataXML()". Replace with "setXMLData()".'); return this.setXMLData.apply(this, arguments) }, setDataURL: function () { d.raiseWarning(this, "11171116293", "run", "JavaScriptRenderer~setDataURL()", 'Use of deprecated "SetDataURL()". Replace with "setXMLUrl()".'); return this.setXMLUrl.apply(this, arguments) }, hasRendered: function () { return !(!this.jsVars.hcObj || !this.jsVars.hcObj.hasRendered) }, setTransparent: function (a) {
        var b;
        if (b = this.jsVars) "boolean" !== typeof a && null !== a && (a = !0), b.transparent = null === a ? !1 : !0 === a ? !0 : !1
    } 
}); d.extend(d.core, { _fallbackJSChartWhenNoFlash: function () { n.swfobject.hasFlashPlayerVersion(d.core.options.requiredFlashPlayerVersion) || d.renderer.setDefault("javascript") }, _enableJSChartsForSelectedBrowsers: function (a) { void 0 !== a && null !== a && d.renderer.setDefault((new RegExp(a)).test(n.navigator.userAgent) ? "javascript" : "flash") }, _doNotLoadExternalScript: function (a) {
    var b, c; for (b in a) c = b.toLowerCase(),
B[c] && (N[c] = Boolean(a[b]))
}, _preloadJSChartModule: function () { throw "NotImplemented()"; } 
}); d.renderer.register("javascript", P); b || l ? d.renderer.setDefault("javascript") : n.swfobject && n.swfobject.hasFlashPlayerVersion && !n.swfobject.hasFlashPlayerVersion(d.core.options.requiredFlashPlayerVersion) && (d.raiseWarning(d.core, "1204111846", "run", "JSRenderer", "Switched to JavaScript as default rendering due to absence of required Flash Player."), d.renderer.setDefault("javascript"))
} ]);
FusionCharts.register("module", ["private", "modules.renderer.js-lib", function () {
    var d = this, n = d.window, E = n.document, u = Boolean(n.SVGAngle || E.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1")), l = /msie/i.test(n.navigator.userAgent) && !n.opera, b = n.parseFloat, P = /\s+/g, c = /^#?/, J = /^rgba/i, a = /[#\s]/ig, B = /\{br\}/ig, N = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i, t = Math.abs, g = Math.pow, k = Math.round, f = g(2, -24), h = Object.prototype.toString, s = void 0 !== E.documentElement.ontouchstart, sa = !/fusioncharts\.com$/i.test(n.location.hostname),
m = Math, z = m.max, H = m.min, M = { pageX: 0, pageY: 0 }, $ = d.hcLib || (d.hcLib = {}), C = function (a) {
    var b = a.data, c = b.chart, q = c.paper, D = a.state, r = a.originalEvent, d = r.target || r.originalTarget || r.srcElement || r.relatedTarget || r.fromElement, g = s && w(a) || M, f = c.elements.resizeBox, h = b.bBox, h = b.ox, k = b.oy, I = b.zoomX, K = b.zoomY, m = b.canvasY, G = b.canvasX, Q = b.canvasW, l = b.canvasH, C = b.canvasX2, B = b.canvasY2, S = b.strokeWidth, n = b.attr, aa = (r.clientX || r.pageX || g.pageX) - b.chartPosLeft, la = (r.clientY || r.pageY || g.pageY) - b.chartPosTop, r = aa - h, g = la -
k; switch (D) {
        case "start": b.oy = la; b.ox = aa; b.allowMove = !1; f || (f = c.elements.resizeBox = q.rect(c.layers.tracker).attr(n)); aa > G && aa < C && la > m && la < B && (b.allowMove = !0); d && d.ishot && (b.allowMove = !1); f.attr({ x: 0, y: 0, width: 0, height: 0 }).show(); break; case "end": h = f.getBBox(); a = { chart: c, selectionLeft: h.x, selectionTop: h.y, selectionHeight: h.height, selectionWidth: h.width, originalEvent: a.originalEvent }; b.isDragged && (b.selectionEnd && b.selectionEnd(a), b.isDragged = 0); f.hide(); delete b.oy; delete b.ox; break; default: if (!b.allowMove) break;
            r = aa - b.ox; g = la - b.oy; h = b.ox; k = b.oy; b.isDragged || (a = { chart: c, selectionLeft: (I ? H(h, h + r) : G) + 0.5 * S, selectionTop: (K ? H(k, k + g) : m) + 0.5 * S, selectionHeight: 0, selectionWidth: 0, originalEvent: a.originalEvent }, b.selectionStart && b.selectionStart(a), b.isDragged = 1); r = -(h - H(h - (h - z(h + r, G)), C)); g = -(k - H(k - (k - z(k + g, m)), B)); f.attr({ x: (I ? H(h, h + r) : G) + 0.5 * S, y: (K ? H(k, k + g) : m) + 0.5 * S, width: I ? t(r) : Q, height: K ? t(g) : l })
    } 
}, V = function (a) {
    var b = a.data; a = a.originalEvent; var c = a.target || a.originalTarget || a.srcElement || a.relatedTarget || a.fromElement,
q = a.type, D = a.layerX, r = a.layerY; void 0 === D && (D = a.pageX - b.chartPosLeft, r = a.pageY - b.chartPosTop); "mousedown" === q && (c.ishot = D > b.canvasX && D < b.canvasX2 && r > b.canvasY && r < b.canvasY2); "mouseup" === q && setTimeout(function () { c.ishot = !1 }, 1)
}, m = function () { var a = "innerWidth", b = "innerHeight", c = E.documentElement || E.body, q = c; "innerWidth" in n ? q = n : (a = "clientWidth", b = "clientHeight"); return function () { return { width: q[a], height: q[b], scrollTop: c.scrollTop, scrollLeft: c.scrollLeft} } } (), ba = function (a, b) {
    var c = { left: a.offsetLeft ||
0, top: a.offsetTop || 0
    }; for (a = a.offsetParent; a; ) c.left += a.offsetLeft || 0, c.top += a.offsetTop || 0, a === E.body || a === E.documentElement || b || (c.left -= a.scrollLeft, c.top -= a.scrollTop), a = a.offsetParent; return c
}, da = function (a) { return a && a.replace(/\$/g, "$$$$") }, xa = function (a, b) { return a || !1 === a || 0 === a ? a : b }, ua = function () { var a, b, c; b = 0; for (c = arguments.length; b < c; b += 1) if ((a = arguments[b]) || !1 === a || 0 === a) return a; return "" }, S = function () {
    var a, b, c; b = 0; for (c = arguments.length; b < c; b += 1) if ((a = arguments[b]) || !1 === a || 0 ===
a) return a
}, ca = function (a, b, c, q) { return $.dem.listen(a, b, c, q) }, ha = function (a, b, c) { return $.dem.unlisten(a, b, c) }, w = function (a) { var b = a.sourceEvent || a.originalEvent; return s && b && b.touches && b.touches[0] || a }, Q = function (a, b) { b = b || {}; var c = s && w(b) || M, q = aa(b.pageX, c.pageX), c = aa(b.pageY, c.pageY), D = ba(a); return { chartX: q - D.left, chartY: c - D.top, pageX: q, pageY: c} }, K = function (a) { return a && a.replace(/^#?([a-f0-9]+)/ig, "#$1") || "none" }, aa = function () {
    var a, b, c; b = 0; for (c = arguments.length; b < c; b += 1) if (((a = arguments[b]) ||
!1 === a || 0 === a) && !isNaN(a = Number(a))) return a
}, ja = function (a, b) { a = a || !1 === a || 0 === a ? Number(a) : NaN; return isNaN(a) ? null : b ? t(a) : a }, I = function (a) { return "string" === typeof a ? a.replace(B, "<br />") : "" }, G = function (a, b) { for (var c = b.length, q = -1; c--; ) if (a === b[c]) { q = c; break } return q }, la = function () { if (Array.isArray) return Array.isArray; var a = Object.prototype.toString, b = a.call([]); return function (c) { return a.call(c) === b } } (), Xa = function (a, b, c, q, D) {
    var r, d, g, f; D ? (q.push(a), D.push(b)) : (q = [a], D = [b]); if (b instanceof Array) for (r =
0; r < b.length; r += 1) { try { d = a[r], g = b[r] } catch (w) { continue } if ("object" !== typeof g) c && void 0 === g || (a[r] = g); else { if (null === d || "object" !== typeof d) d = a[r] = g instanceof Array ? [] : {}; f = G(g, D); -1 !== f ? d = a[r] = q[f] : Xa(d, g, c, q, D) } } else for (r in b) {
        try { d = a[r], g = b[r] } catch (k) { continue } if (null !== g && "object" === typeof g) if (f = h.call(g), "[object Object]" === f) { if (null === d || "object" !== typeof d) d = a[r] = {}; f = G(g, D); -1 !== f ? d = a[r] = q[f] : Xa(d, g, c, q, D) } else "[object Array]" === f ? (null !== d && d instanceof Array || (d = a[r] = []), f = G(g, D),
-1 !== f ? d = a[r] = q[f] : Xa(d, g, c, q, D)) : a[r] = g; else a[r] = g
    } return a
}, ga = function (a, b, c) { if ("object" !== typeof a && "object" !== typeof b) return null; if ("object" !== typeof b || null === b) return a; "object" !== typeof a && (a = b instanceof Array ? [] : {}); Xa(a, b, c); return a }, Aa = function (a, b) {
    var c; if (b instanceof Array) for (c = b.length - 1; 0 <= c; c -= 1) "object" !== typeof b[c] ? !0 === b[c] && a && a.splice && a.splice(c, 1) : h.call(b[c]) === h.call(a[c]) && Aa(a[c], b[c]); else for (c in b) "object" !== typeof b[c] ? !0 === b[c] && a && a.splice && a.splice(c, 1) :
h.call(b[c]) === h.call(a[c]) && Aa(a[c], b[c]); return a
}, za = function () {
    var a = /^@window_/g; return function (b, c) {
        var q = b.replace(/\[[\'\"]/g, ".").replace(/[\'\"]\]/g, "").replace(/\[/g, ".@window_").replace(/\]/g, "").split("."), D = n, r, d; d = ""; var g, f, w; f = q.length; for (w = 0; w < f; w += 1) { g = q[w]; r = D; if (g.match(a)) d = n[g.replace(a, "")], D = D[d]; else { if (void 0 === D || null === D) throw (d || g).replace(a, "") + " is not defined"; D = D[g] } d = g } !D || "function" !== typeof D.call && D !== n.alert ? setTimeout(function () {
            throw g.replace(a, "") + "() is not a function";
        }, 0) : D === n.alert ? D(c) : D.call(r, c)
    } 
} (), Ga = function () { var a = "FusionChartslinkEval" + parseInt(+new Date, 10); return function (b) { try { n[a] = new Function(b), eval('window["' + a + '"]();') } catch (c) { setTimeout(function () { throw c; }, 0) } u ? delete n[a] : n[a] = null } } (), X = function (a, b) { a = Number(a); a = isNaN(a) ? 100 : a; void 0 !== b && (a = a * b / 100); return a % 101 }, ma = function (a, b, c) { a = a.split(","); var q; void 0 !== c && (c = aa(c.split(",")[0])); a[0] = X(a[0], c); for (q = 1; q < b; q += 1) a[q] = a[0] * X(a[q], c) / 100; return a.join(",") }, Ba = function (b, c, d) {
    var q =
0, D = 0, r = 0; d && d.match(J) && (d = d.split(","), q = d[0].slice(d[0].indexOf("(") + 1), D = d[1], r = d[2], c || 0 === c || (c = parseInt(100 * d[3].slice(0, d[3].indexOf(")")), 10))); if (b) if (b.match(J)) d = b.split(","), q = d[0].slice(d[0].indexOf("(") + 1), D = d[1], r = d[2]; else { b = b.replace(a, "").split(",")[0]; switch (b.length) { case 3: b = b[0] + b[0] + b[1] + b[1] + b[2] + b[2]; break; case 6: break; default: b = (b + "FFFFFF").slice(0, 6) } q = parseInt(b.slice(0, 2), 16); D = parseInt(b.slice(2, 4), 16); r = parseInt(b.slice(4, 6), 16) } c || 0 === c || (c = 100); "string" === typeof c &&
(c = c.split(",")[0]); c = parseInt(c, 10) / 100; return "rgba(" + q + "," + D + "," + r + "," + c + ")"
}, W = function () {
    var a = {}; return function (c) {
        var d = (c = c || this) && c.FCcolor || c, q = d.color, D = d.ratio, r = d.angle, g = d.alpha, f = d.r, w = d.cx, h = d.cy, k = d.fx, z = d.fy, I = d.gradientUnits, K = d.x1, s = d.y1, m = d.x2, G = d.y2, Q = 1, l, M, C, S; if ("string" === typeof c) return a[S = "~" + c] || (a[S] = c.replace(/^#?([a-f0-9]{3,6})/ig, "#$1")); q = q || ""; if (!q) return l; S = [q, g, D, r, f, w, h, I, k, z, K, m, s, G].join("_").replace(/[\(\)\s,\xb0#]/g, "_"); if (a[S]) return a[S]; D = D && (D + "").split(",") ||
[]; g = (g || 0 === g) && (g + "").split(",") || []; if (q = q.split(",")) if (l = "", 1 === q.length) C = q[0].replace(/^#?([a-f0-9]{3,6})/ig, "$1"), l = g.length ? "rgba(" + Fa(C).join(",") + "," + 0.01 * b(g[0]) + ")" : C.replace(/^#?([a-f0-9]{3,6})/ig, "#$1"); else {
            c = 0; for (M = q.length; c < M; c++) C = q[c].replace(/^#?([a-f0-9]{3,6})/ig, "$1"), isNaN(D[c]) || (D[c] = b(D[c]), C += ":" + D[c], isNaN(D[c + 1]) || (D[c + 1] = b(D[c + 1]) + D[c])), isNaN(g[c]) || "" === g[c] || (Q = 0.01 * g[c]), q[c] = "rgba(" + Fa(C).join(",") + "," + Q + ")", isNaN(D[c]) || (q[c] = q[c] + ":" + D[c]); l += q.join("-"); if (void 0 !==
f || void 0 !== k || void 0 !== w || d.radialGradient) l = "xr(" + [k, z, f, w, h, I].join() + ")" + l; else { l = "-" + l; if (void 0 !== K || void 0 !== s || void 0 !== m || void 0 !== G) l = "(" + [K, s, m, G, I].join() + ")" + l; void 0 === r && (r = 0); l = 360 - b(r) % 360 + l } 
        } return a[S] = l
    } 
} (), fa = function () { return function () { return "" } } (), Ca = function (b) { return b.replace(a, "").replace(c, "#") }, qa = function (b, c) {
    c = (0 > c || 100 < c ? 100 : c) / 100; b = b.replace(a, ""); var d = parseInt(b, 16), q = Math.floor(d / 65536), D = Math.floor((d - 65536 * q) / 256); return ("000000" + (q * c << 16 | D * c << 8 | (d - 65536 * q -
256 * D) * c).toString(16)).slice(-6)
}, Ya = function (b, c) { c = (0 > c || 100 < c ? 100 : c) / 100; b = b.replace(a, ""); var d = parseInt(b, 16), q = Math.floor(d / 65536), D = Math.floor((d - 65536 * q) / 256); return ("000000" + (256 - (256 - q) * c << 16 | 256 - (256 - D) * c << 8 | 256 - (256 - (d - 65536 * q - 256 * D)) * c).toString(16)).slice(-6) }, Fa = function (a) { a = parseInt(a, 16); var b = Math.floor(a / 65536), c = Math.floor((a - 65536 * b) / 256); return [b, c, Math.floor(a - 65536 * b - 256 * c)] }, Pa = function () {
    var a = { top: { align: "center", verticalAlign: "top", textAlign: "center" }, right: { align: "right",
        verticalAlign: "middle", textAlign: "left"
    }, bottom: { align: "center", verticalAlign: "bottom", textAlign: "center" }, left: { align: "left", verticalAlign: "middle", textAlign: "right"}
    }, b = /([^\,^\s]+)\)$/g, c = function (a, b) { var c; /^(bar|bar3d)$/.test(a) && (this.isBar = !0, this.yPos = "bottom", this.yOppPos = "top", this.xPos = "left", this.xOppPos = "right"); c = parseInt(b.labelstep, 10); this.labelStep = 1 < c ? c : 1; this.showLabel = aa(b.showlabels, b.shownames, 1); this.is3D = /3d$/.test(a) }; c.prototype = { isBar: !1, yPos: "left", yOppPos: "right", xPos: "bottom",
        xOppPos: "top", addAxisGridLine: function (c, d, r, g, f, w, h, k) { var z = "" === r ? !1 : !0, I = 0 < g || 0 < w.match(b)[1] ? !0 : !1, K; if (z || I) I || (w = "rgba(0,0,0,0)", g = 0.1), K = { isGrid: !0, width: g, dashStyle: f, color: w, value: d, zIndex: void 0 === h ? 2 : h }, z && (d = c.opposite ? k ? this.xOppPos : this.yOppPos : k ? this.xPos : this.yPos, d = a[d], K.label = { text: r, style: c.labels.style, textAlign: d.textAlign, align: d.align, verticalAlign: d.verticalAlign, rotation: 0, x: 0, y: 0 }), c.plotLines.push(K); return K }, addAxisAltGrid: function (a, b) {
            if (!this.is3D) {
                var c = aa(a._lastValue,
a.min), d = S(a._altGrid, !1); d && a.plotBands.push({ isGrid: !0, color: a.alternateGridColor, to: b, from: c, zIndex: 1 }); a._lastValue = b; a._altGrid = !d
            } 
        }, addXaxisCat: function (b, c, r, d) { var g = a[b.opposite ? this.xOppPos : this.xPos]; c = { isGrid: !0, width: 0.1, color: "rgba(0,0,0,0)", value: c, label: { text: d, style: b.labels.style, textAlign: g.textAlign, align: g.align, verticalAlign: g.verticalAlign, rotation: 0, x: 0, y: 0} }; 0 !== r % this.labelStep && (c.stepped = !0, c.label.style = b.steppedLabels.style); b.plotLines.push(c) }, addVline: function (a, b,
c, d) {
            d = d._FCconf; var g = d.isBar, f = d.divlineStyle, w = I(b.label), h = Boolean(aa(b.showlabelborder, d.showVLineLabelBorder, 1)), k = Boolean(aa(b.showlabelbackground, 1)), z = S(b.labelhalign, g ? "left" : "center"), K = S(b.labelvalign, g ? "middle" : "bottom").toLowerCase(), s = aa(b.labelposition, 0), m = aa(b.lineposition, 0.5), G = aa(b.showvlines, d.showVLines, 1), l = aa(b.alpha, d.vLineAlpha, 80), Q = S(b.color, d.vLineColor).replace(/^#?/, "#"), M = k ? S(b.labelbgcolor, d.vLineLabelBgColor, "333333").replace(/^#?/, "#") : "", C = S(b.labelcolor, d.vLineLabelColor,
b.color, d.vLineColor).replace(/^#?/, "#"), B = aa(b.thickness, d.vLineThickness, 1), t = 0.5 * B, n = Boolean(Number(S(b.dashed, 0))), H = aa(b.dashlen, 5), la = aa(b.dashgap, 2), u = d.smartLabel, N = parseInt(f.fontSize, 10) + 2, tb = 0, p = aa(b.rotatelabel, d.rotateVLineLabels) ? 270 : 0, m = 0 > m || 1 < m ? 0.5 : m, s = 0 > s || 1 < s ? 0 : s; u.setStyle(f); u = u.getOriSize(w); Q = Ba(Q, G ? l : "0"); if (g) { switch (K) { case "top": N -= u.height + t + 2; break; case "middle": N -= 0.5 * u.height + 1; break; default: N += t } b.labelhalign || (tb -= u.width * s) } else {
                switch (K) {
                    case "top": N = 0.5 * -u.height +
1; break; case "middle": N = 0; break; default: N = 0.5 * u.height
                } switch (z) { case "left": tb += B; break; case "right": tb -= B + 1 } 
            } a.plotLines.push({ isVline: !0, color: Q, width: B, value: c - 1 + m, zIndex: aa(b.showontop, d.showVLinesOnTop) ? 5 : 3, dashStyle: n ? bb(H, la, B) : void 0, label: { text: w, align: g ? "left" : "center", offsetScale: s, rotation: p, y: N, x: tb, textAlign: z, backgroundColor: M, borderWidth: G && h ? "1px" : "", borderType: G && h ? "solid" : "", borderColor: G && h ? C : "", backgroundOpacity: G && k ? S(b.labelbgalpha, d.vLineLabelBgAlpha) / 100 : 0, style: { color: G ?
C : Q, fontSize: f.fontSize, fontFamily: f.fontFamily, lineHeight: f.lineHeight, backgroundColor: M
            }
            }
            })
        } 
    }; return c.prototype.constructor = c
} (), Kb = function () {
    var a = function (a, c, r, d, g) { a = Math.abs(c - a); c = a / (r + 1); b(a, r, d) || (g && Number(c) / Number(d) < (1 < d ? 2 : 0.5) && (d /= 10), c = (Math.floor(c / d) + 1) * d, a = c * (r + 1)); return a }, b = function (a, b, d) { return c(a / (b + 1)) > c(d) ? !1 : !0 }, c = function (a) { a = Math.abs(a); a = String(a); var b = 0, c = a.indexOf("."); -1 != c && (b = a.length - c - 1); return b }; return function (c, d, r, g, w, h, k, z) {
        var I, K, s, m, G, Q, l; c = !0 ===
isNaN(c) || void 0 === c ? 0.1 : c; d = !0 === isNaN(d) || void 0 === d ? 0 : d; c === d && 0 === c && (c = 0.1); w = void 0 === typeof w ? !0 : w; h = void 0 === typeof h ? !0 : h; I = Math.floor(Math.log(Math.abs(c)) / Math.LN10); K = Math.floor(Math.log(Math.abs(d)) / Math.LN10); K = Math.max(K, I); I = Math.pow(10, K); 2 > Math.abs(c) / I && 2 > Math.abs(d) / I && (K--, I = Math.pow(10, K)); K = Math.floor(Math.log(c - d) / Math.LN10); K = Math.pow(10, K); 0 < c - d && 10 <= I / K && (I = K); K = (Math.floor(c / I) + 1) * I; 0 > d ? s = -1 * (Math.floor(Math.abs(d / I)) + 1) * I : h ? s = 0 : (s = Math.floor(Math.abs(d / I) - 1) * I, s = 0 > s ? 0 :
s); w && 0 >= c && (K = 0); w = r || 0 === r ? !0 : !1; h = g || 0 === g ? !0 : !1; c = !1 === w || !0 === w && Number(r) < c && c - Number(r) > f ? K : Number(r); d = !1 === h || !0 === h && Number(g) > d && Number(g) - d > f ? s : Number(g); g = Math.abs(c - d); if (!1 === h && !1 === w && z) if (0 < c && 0 > d) for (z = !1, r = 10 < I ? I / 10 : I, m = a(d, c, k, r, !1), w = m - (k + 1) * r; !1 === z; ) {
            if (w += (k + 1) * r, b(w, k, r)) if (m = w - g, h = w / (k + 1), s = Math.min(Math.abs(d), c), K = s == Math.abs(d) ? -1 : 1, 0 === k) z = !0; else for (Q = 1; Q <= Math.floor((k + 1) / 2); Q++) G = h * Q, !(G - s > m) && G > s && (l = w - G, l / h == Math.floor(l / h) && G / h == Math.floor(G / h) && (g = w, c = -1 == K ?
l : G, d = -1 == K ? -G : -l, z = !0))
        } else z = a(d, c, k, I, !0), m = z - g, g = z, 0 < c ? c += m : d -= m; else if (z && 0 < k) { z = 0; for (r = 1; ; ) { m = k + z * r; m = 0 === m ? 1 : m; if (b(g, m, I)) break; z = -1 == r || z > k ? ++z : z; if (25 < z) { m = 0; break } r = z <= k ? -1 * r : 1 } k = m } return { Max: c, Min: d, Range: g, interval: I, divGap: (c - d) / (k + 1)}
    } 
} (), Na = function () {
    var a = function (a, b) { this.title.y = a.offsetHeight / 2; void 0 !== b && (this.title.text = b) }; a.prototype = { chart: { events: {}, margin: [0, 0, 0, 0], backgroundColor: { FCcolor: { alpha: 0}} }, credits: { href: "http://www.fusioncharts.com?BS=FCHSEvalMark", text: "FusionCharts XT Trial",
        enabled: sa
    }, legend: { enabled: !1 }, title: { text: "", style: { fontFamily: "Verdana,sans", fontSize: "10px", color: "#666666"} }, plotOptions: { series: {} }, series: [{}], exporting: { enabled: !1 }, nativeMessage: !0
    }; return a.prototype.constructor = a
} (), qb = { "true": { "true": { "true": "center", "false": "center" }, "false": { "true": "center", "false": "center"} }, "false": { "true": { "true": "right", "false": "left" }, "false": { "true": "left", "false": "right"}} }, yb = function () {
    return function (a, b, d, q, g, r, w) {
        var f, h = d.trendStyle, k, z, K, s, m, G, Q, l, M, C,
B, t, n, H = r ? "xAxis" : "dataLabels"; if (r ? d.showVLines : d.showTrendlines) for (f = 0, z = a.length; f < z; f += 1) if ((n = a[f]) && n.line) for (k = 0, K = n.line.length; k < K; k += 1) s = n.line[k], C = d.numberFormatter.getCleanValue(S(s.startvalue, s.value, 0)), B = d.numberFormatter.getCleanValue(S(s.endvalue, S(s.startvalue, s.value, 0))), r ? l = b : q && s.parentyaxis && /^s$/i.test(s.parentyaxis) ? (l = b[1], t = 1) : l = b[0], G = l.max, Q = l.min, m = !1, G >= C && G >= B && Q <= C && Q <= B && (q && s.parentyaxis && /^s$/i.test(s.parentyaxis) ? m = "1" !== S(s.valueonleft, d.trendlineValuesOnOpp) :
q || (m = "1" === S(s.valueonright, d.trendlineValuesOnOpp)), G = Boolean(aa(s.istrendzone, r ? 1 : 0)), (Q = (r ? d.showVLineLabels : d.showTrendlineLabels) ? I(S(s.displayvalue, d.numberFormatter[H](m ? B : C, t))) : "") ? (M = C < B, m = { text: Q, textAlign: g ? "center" : m ? "left" : "right", align: g ? qb[G][!w][M] : m ? "right" : "left", verticalAlign: g ? "bottom" : "middle", rotation: 0, x: 0, y: 0, style: h }, Q = S(s.color, d.trendlineColor), s.alwaysVisible = G, Q && (m.style = ga({}, h), m.style.color = Q.replace(c, "#"))) : m = void 0, Q = xa(I(S(s.tooltext, n.tooltext, d.trendLineToolText))),
Q = wb(Q, [7, 15, 16, 17, 18, 19], { startValue: C, startDataValue: d.numberFormatter[H](C, t), endValue: B, endDataValue: d.numberFormatter[H](B, t), axisName: l.title && l.title.text }, s), M = aa(s.thickness, d.trendlineThickness, 1), G ? l.plotBands.push({ isTrend: !0, color: Ba(S(s.color, d.trendlineColor), S(s.alpha, d.trendlineAlpha, 40)), from: C, to: B, label: m, zIndex: d.is3d || "1" !== S(s.showontop, d.showTrendlinesOnTop) ? 3 : 5, tooltext: Q, alwaysVisible: s.alwaysVisible }) : l.plotLines.push({ isTrend: !0, color: Ba(S(s.color, d.trendlineColor, d.trendlineColor),
S(s.alpha, d.trendlineAlpha, 99)), value: C, to: B, width: M, dashStyle: "1" == S(s.dashed, d.trendlinesAreDashed) ? bb(aa(s.dashlen, d.trendlinesDashLen), aa(s.dashgap, d.trendlinesDashGap), M) : void 0, label: m, zIndex: d.is3d || "1" !== S(s.showontop, d.showTrendlinesOnTop) ? 3 : 5, tooltext: Q
}))
    } 
} (), bb = function (a, b, c, d) { return d || void 0 === d ? [a, b] : "" }, hb = function () { }, db = function (a, b, c) {
    var d, g = db[a]; g || (g = function () { }, g.prototype = c instanceof hb ? c : new hb, g.prototype.constructor = g, g = db[a] = new g); c && (g.base = c); g.name = a; for (d in b) switch (typeof b[d]) {
        case "object": if (b[d] instanceof
hb) { g[d] = b[d][d]; break } default: g[d] = b[d]; break; case "undefined": delete g[d]
    } return this instanceof db ? (a = function () { }, a.prototype = g, a.prototype.constructor = a, new a) : g
}, wb = function () {
    var a = [{ regex: /((^|[^\\])((\\)\\)*\$cleanvalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$cleanvalue))/ig, argIndex: 2, argKey: "cleanvalue" }, { regex: /((^|[^\\])((\\)\\)*\$datavalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$datavalue))/ig, argIndex: 2, argKey: "formattedValue" }, { regex: /((^|[^\\])((\\)\\)*\$value)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$value))/ig,
        argIndex: 3, argKey: "value"
    }, { regex: /((^|[^\\])((\\)\\)*\$label)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$label))/ig, argIndex: 2, argKey: "label" }, { regex: /((^|[^\\])((\\)\\)*\$seriesname)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$seriesname))/ig, argIndex: 5, argKey: "seriesname" }, { regex: /((^|[^\\])((\\)\\)*\$yaxisname)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$yaxisname))/ig, argIndex: 2, argKey: "yaxisName" }, { regex: /((^|[^\\])((\\)\\)*\$xaxisname)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$xaxisname))/ig, argIndex: 2,
        argKey: "xaxisName"
    }, { regex: /((^|[^\\])((\\)\\)*\$displayvalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$displayvalue))/ig, argIndex: 3, argKey: "displayvalue" }, { regex: /((^|[^\\])((\\)\\)*\$xdatavalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$xdatavalue))/ig, argIndex: 2, argKey: "xDataValue" }, { regex: /((^|[^\\])((\\)\\)*\$ydatavalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$ydatavalue))/ig, argIndex: 2, argKey: "yDataValue" }, { regex: /((^|[^\\])((\\)\\)*\$xvalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$xvalue))/ig,
        argIndex: 3, argKey: "x"
    }, { regex: /((^|[^\\])((\\)\\)*\$yvalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$yvalue))/ig, argIndex: 3, argKey: "y" }, { regex: /((^|[^\\])((\\)\\)*\$zvalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$zvalue))/ig, argIndex: 3, argKey: "z" }, { regex: /((^|[^\\])((\\)\\)*\$name)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$name))/ig, argIndex: 3, argKey: "name" }, { regex: /((^|[^\\])((\\)\\)*\$percentValue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$percentValue))/ig, argIndex: 2, argKey: "percentValue" }, { regex: /((^|[^\\])((\\)\\)*\$startValue)/ig,
        escapeRegex: /((^|[^\\])((\\)\\)*\\(\$startValue))/ig, argIndex: 2, argKey: "startValue"
    }, { regex: /((^|[^\\])((\\)\\)*\$startDataValue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$startDataValue))/ig, argIndex: 2, argKey: "startDataValue" }, { regex: /((^|[^\\])((\\)\\)*\$endValue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$endValue))/ig, argIndex: 2, argKey: "endValue" }, { regex: /((^|[^\\])((\\)\\)*\$endDataValue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$endDataValue))/ig, argIndex: 2, argKey: "endDataValue" }, { regex: /((^|[^\\])((\\)\\)*\$axisName)/ig,
        escapeRegex: /((^|[^\\])((\\)\\)*\\(\$axisName))/ig, argIndex: 2, argKey: "axisName"
    }, { regex: /((^|[^\\])((\\)\\)*\$cumulativevalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$cumulativevalue))/ig, argIndex: 2, argKey: "cumulativeValue" }, { regex: /((^|[^\\])((\\)\\)*\$cumulativedatavalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$cumulativedatavalue))/ig, argIndex: 2, argKey: "cumulativeDataValue" }, { regex: /((^|[^\\])((\\)\\)*\$cumulativePercentValue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$cumulativePercentValue))/ig,
        argIndex: 2, argKey: "cumulativePercentValue"
    }, { regex: /((^|[^\\])((\\)\\)*\$cumulativepercentdatavalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$cumulativepercentdatavalue))/ig, argIndex: 2, argKey: "cumulativePercentDataValue" }, { regex: /((^|[^\\])((\\)\\)*\$sum)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$sum))/ig, argIndex: 2, argKey: "sum" }, { regex: /((^|[^\\])((\\)\\)*\$unformattedsum)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$unformattedsum))/ig, argIndex: 2, argKey: "unformattedSum" }, { regex: /((^|[^\\])((\\)\\)*\$targetvalue)/ig,
        escapeRegex: /((^|[^\\])((\\)\\)*\\(\$targetvalue))/ig, argIndex: 2, argKey: "targetValue"
    }, { regex: /((^|[^\\])((\\)\\)*\$targetdatavalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$targetdatavalue))/ig, argIndex: 2, argKey: "targetDataValue" }, { regex: /((^|[^\\])((\\)\\)*\$processname)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$processname))/ig, argIndex: 2, argKey: "processName" }, { regex: /((^|[^\\])((\\)\\)*\$start)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$start))/ig, argIndex: 2, argKey: "start" }, { regex: /((^|[^\\])((\\)\\)*\$end)/ig,
        escapeRegex: /((^|[^\\])((\\)\\)*\\(\$end))/ig, argIndex: 2, argKey: "end"
    }, { regex: /((^|[^\\])((\\)\\)*\$percentcomplete)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$percentcomplete))/ig, argIndex: 2, argKey: "percentComplete" }, { regex: /((^|[^\\])((\\)\\)*\$taskpercentcomplete)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$taskpercentcomplete))/ig, argIndex: 2, argKey: "taskPercentComplete" }, { regex: /((^|[^\\])((\\)\\)*\$taskstartdate)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$taskstartdate))/ig, argIndex: 2, argKey: "taskStartDate" },
{ regex: /((^|[^\\])((\\)\\)*\$taskenddate)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$taskenddate))/ig, argIndex: 2, argKey: "taskEndDate" }, { regex: /((^|[^\\])((\\)\\)*\$tasklabel)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$tasklabel))/ig, argIndex: 2, argKey: "taskLabel" }, { regex: /((^|[^\\])((\\)\\)*\$date)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$date))/ig, argIndex: 2, argKey: "date" }, { regex: /((^|[^\\])((\\)\\)*\$percentofprevvalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$percentofprevvalue))/ig, argIndex: 2, argKey: "percentOfPrevValue" },
{ regex: /((^|[^\\])((\\)\\)*\$sname)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$sname))/ig, argIndex: 2, argKey: "sName" }, { regex: /((^|[^\\])((\\)\\)*\$lname)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$lname))/ig, argIndex: 2, argKey: "lName" }, { regex: /((^|[^\\])((\\)\\)*\$fromid)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromid))/ig, argIndex: 2, argKey: "fromId" }, { regex: /((^|[^\\])((\\)\\)*\$fromlabel)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromlabel))/ig, argIndex: 2, argKey: "fromLabel" }, { regex: /((^|[^\\])((\\)\\)*\$toid)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toid))/ig, argIndex: 2, argKey: "toId"
}, { regex: /((^|[^\\])((\\)\\)*\$tolabel)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$tolabel))/ig, argIndex: 2, argKey: "toLabel" }, { regex: /((^|[^\\])((\\)\\)*\$fromxvalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromxvalue))/ig, argIndex: 2, argKey: "fromXValue" }, { regex: /((^|[^\\])((\\)\\)*\$fromyvalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromyvalue))/ig, argIndex: 2, argKey: "fromYValue" }, { regex: /((^|[^\\])((\\)\\)*\$fromxdatavalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromxdatavalue))/ig,
    argIndex: 2, argKey: "fromXDataValue"
}, { regex: /((^|[^\\])((\\)\\)*\$fromydatavalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromydatavalue))/ig, argIndex: 2, argKey: "fromYDataValue" }, { regex: /((^|[^\\])((\\)\\)*\$fromlabel)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromlabel))/ig, argIndex: 2, argKey: "fromLabel" }, { regex: /((^|[^\\])((\\)\\)*\$toxvalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toxvalue))/ig, argIndex: 2, argKey: "toXValue" }, { regex: /((^|[^\\])((\\)\\)*\$toyvalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toyvalue))/ig,
    argIndex: 2, argKey: "toYValue"
}, { regex: /((^|[^\\])((\\)\\)*\$toxdatavalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toxdatavalue))/ig, argIndex: 2, argKey: "toXDataValue" }, { regex: /((^|[^\\])((\\)\\)*\$toydatavalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toydatavalue))/ig, argIndex: 2, argKey: "toYDataValue" }, { regex: /((^|[^\\])((\\)\\)*\$tolabel)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$tolabel))/ig, argIndex: 2, argKey: "toLabel" }, { regex: /((^|[^\\])((\\)\\)*\$openvalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$openvalue))/ig,
    argIndex: 2, argKey: "openValue"
}, { regex: /((^|[^\\])((\\)\\)*\$closevalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$closevalue))/ig, argIndex: 2, argKey: "closeValue" }, { regex: /((^|[^\\])((\\)\\)*\$highvalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$highvalue))/ig, argIndex: 2, argKey: "highValue" }, { regex: /((^|[^\\])((\\)\\)*\$lowvalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$lowvalue))/ig, argIndex: 2, argKey: "lowValue" }, { regex: /((^|[^\\])((\\)\\)*\$opendatavalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$opendatavalue))/ig,
    argIndex: 2, argKey: "openDataValue"
}, { regex: /((^|[^\\])((\\)\\)*\$closedatavalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$closedatavalue))/ig, argIndex: 2, argKey: "closeDataValue" }, { regex: /((^|[^\\])((\\)\\)*\$highdatavalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$highdatavalue))/ig, argIndex: 2, argKey: "highDataValue" }, { regex: /((^|[^\\])((\\)\\)*\$lowdatavalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$lowdatavalue))/ig, argIndex: 2, argKey: "lowDataValue" }, { regex: /((^|[^\\])((\\)\\)*\$maxvalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$maxvalue))/ig,
    argIndex: 2, argKey: "maxValue"
}, { regex: /((^|[^\\])((\\)\\)*\$maxdatavalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$maxdatavalue))/ig, argIndex: 2, argKey: "maxDataValue" }, { regex: /((^|[^\\])((\\)\\)*\$minvalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$minvalue))/ig, argIndex: 2, argKey: "minValue" }, { regex: /((^|[^\\])((\\)\\)*\$mindatavalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$mindatavalue))/ig, argIndex: 2, argKey: "minDataValue" }, { regex: /((^|[^\\])((\\)\\)*\$q1)/ig, argIndex: 2, argKey: "Q1" }, { regex: /((^|[^\\])((\\)\\)*\$unformattedQ1)/ig,
    argIndex: 2, argKey: "unformattedQ1"
}, { regex: /((^|[^\\])((\\)\\)*\$q3)/ig, argIndex: 2, argKey: "Q3" }, { regex: /((^|[^\\])((\\)\\)*\$unformattedQ3)/ig, argIndex: 2, argKey: "unformattedQ3" }, { regex: /((^|[^\\])((\\)\\)*\$median)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$median))/ig, argIndex: 2, argKey: "median" }, { regex: /((^|[^\\])((\\)\\)*\$unformattedMedian)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$unformattedMedian))/ig, argIndex: 2, argKey: "unformattedMedian" }, { regex: /((^|[^\\])((\\)\\)*\$SD)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$SD))/ig,
    argIndex: 2, argKey: "SD"
}, { regex: /((^|[^\\])((\\)\\)*\$unformattedsd)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$unformattedsd))/ig, argIndex: 2, argKey: "unformattedsd" }, { regex: /((^|[^\\])((\\)\\)*\$QD)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$QD))/ig, argIndex: 2, argKey: "QD" }, { regex: /((^|[^\\])((\\)\\)*\$unformattedQD)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$unformattedQD))/ig, argIndex: 2, argKey: "unformattedQD" }, { regex: /((^|[^\\])((\\)\\)*\$MD)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$MD))/ig, argIndex: 2, argKey: "MD" },
{ regex: /((^|[^\\])((\\)\\)*\$unformattedMD)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$unformattedMD))/ig, argIndex: 2, argKey: "unformattedMD" }, { regex: /((^|[^\\])((\\)\\)*\$mean)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$mean))/ig, argIndex: 2, argKey: "mean" }, { regex: /((^|[^\\])((\\)\\)*\$unformattedMean)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$unformattedMean))/ig, argIndex: 2, argKey: "unformattedMean" }, { regex: /((^|[^\\])((\\)\\)*\$unformattedMean)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$unformattedMean))/ig, argIndex: 2,
    argKey: "unformattedMean"
}, { regex: /((^|[^\\])((\\)\\)*\$volumeValue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$volumeValue))/ig, argIndex: 2, argKey: "volumeValue" }, { regex: /((^|[^\\])((\\)\\)*\$volumeDataValue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$volumeDataValue))/ig, argIndex: 2, argKey: "volumeDataValue" }, { regex: /((^|[^\\])((\\)\\)*\$fromXValue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromXValue))/ig, argIndex: 2, argKey: "fromXValue" }, { regex: /((^|[^\\])((\\)\\)*\$fromYValue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromYValue))/ig,
    argIndex: 2, argKey: "fromYValue"
}, { regex: /((^|[^\\])((\\)\\)*\$fromXDataValue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromXDataValue))/ig, argIndex: 2, argKey: "fromXDataValue" }, { regex: /((^|[^\\])((\\)\\)*\$fromYDataValue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromYDataValue))/ig, argIndex: 2, argKey: "fromYDataValue" }, { regex: /((^|[^\\])((\\)\\)*\$fromLabel)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromLabel))/ig, argIndex: 2, argKey: "fromLabel" }, { regex: /((^|[^\\])((\\)\\)*\$toXValue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toXValue))/ig,
    argIndex: 2, argKey: "toXValue"
}, { regex: /((^|[^\\])((\\)\\)*\$toYValue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toYValue))/ig, argIndex: 2, argKey: "toYValue" }, { regex: /((^|[^\\])((\\)\\)*\$toXDataValue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toXDataValue))/ig, argIndex: 2, argKey: "toXDataValue" }, { regex: /((^|[^\\])((\\)\\)*\$toYDataValue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toYDataValue))/ig, argIndex: 2, argKey: "toYDataValue" }, { regex: /((^|[^\\])((\\)\\)*\$tolabel)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$tolabel))/ig,
    argIndex: 2, argKey: "toLabel"
}, { regex: /((^|[^\\])((\\)\\)*\$tlLabel)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$tlLabel))/ig, argIndex: 5, argKey: "tlLabel" }, { regex: /((^|[^\\])((\\)\\)*\$trlabel)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$trlabel))/ig, argIndex: 5, argKey: "trLabel" }, { regex: /((^|[^\\])((\\)\\)*\$bllabel)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$bllabel))/ig, argIndex: 5, argKey: "blLabel" }, { regex: /((^|[^\\])((\\)\\)*\$brlabel)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$brlabel))/ig, argIndex: 5, argKey: "brLabel" },
{ regex: /((^|[^\\])((\\)\\)*\$rowlabel)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$rowlabel))/ig, argIndex: 5, argKey: "rowLabel" }, { regex: /((^|[^\\])((\\)\\)*\$columnlabel)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$columnlabel))/ig, argIndex: 5, argKey: "columnLabel" }, { regex: /((^|[^\\])((\\)\\)*\$errorvalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$errorvalue))/ig, argIndex: 2, argKey: "errorValue" }, { regex: /((^|[^\\])((\\)\\)*\$errordatavalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$errordatavalue))/ig, argIndex: 2, argKey: "errorDataValue" },
{ regex: /((^|[^\\])((\\)\\)*\$errorpercentvalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$errorpercentvalue))/ig, argIndex: 2, argKey: "errorPercentValue" }, { regex: /((^|[^\\])((\\)\\)*\$errorpercentdatavalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$errorpercentdatavalue))/ig, argIndex: 2, argKey: "errorPercentDataValue" }, { regex: /((^|[^\\])((\\)\\)*\$horizontalErrorValue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$horizontalErrorValue))/ig, argIndex: 2, argKey: "horizontalErrorValue" }, { regex: /((^|[^\\])((\\)\\)*\$horizontalErrorDataValue)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$horizontalErrorDataValue))/ig, argIndex: 2, argKey: "horizontalErrorDataValue"
}, { regex: /((^|[^\\])((\\)\\)*\$verticalErrorValue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$verticalErrorValue))/ig, argIndex: 2, argKey: "verticalErrorValue" }, { regex: /((^|[^\\])((\\)\\)*\$verticalErrorDataValue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$verticalErrorDataValue))/ig, argIndex: 2, argKey: "verticalErrorDataValue" }, { regex: /((^|[^\\])((\\)\\)*\$horizontalErrorPercent)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$horizontalErrorPercentValue))/ig,
    argIndex: 2, argKey: "horizontalErrorPercentValue"
}, { regex: /((^|[^\\])((\\)\\)*\$horizontalErrorPercentDataValue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$horizontalErrorPercentDataValue))/ig, argIndex: 2, argKey: "horizontalErrorPercentDataValue" }, { regex: /((^|[^\\])((\\)\\)*\$verticalErrorPercent)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$verticalErrorPercentValue))/ig, argIndex: 2, argKey: "verticalErrorPercentValue" }, { regex: /((^|[^\\])((\\)\\)*\$verticalErrorPercentDataValue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$verticalErrorPercentDataValue))/ig,
    argIndex: 2, argKey: "verticalErrorPercentDataValue"
}, { regex: /((^|[^\\])((\\)\\)*\$xaxispercentvalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$xaxispercentvalue))/ig, argIndex: 2, argKey: "xAxisPercentValue" }, { regex: /((^|[^\\])((\\)\\)*\$percentdatavalue)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$percentdatavalue))/ig, argIndex: 2, argKey: "percentDataValue" }, { regex: /((^|[^\\])((\\)\\)*\$trType)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$trType))/ig, argIndex: 4, argKey: "trtype" }, { regex: /((^|[^\\])((\\)\\)*\$tlType)/ig,
    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$tlType))/ig, argIndex: 4, argKey: "tltype"
}, { regex: /((^|[^\\])((\\)\\)*\$brType)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$brType))/ig, argIndex: 4, argKey: "brtype" }, { regex: /((^|[^\\])((\\)\\)*\$blType)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$blType))/ig, argIndex: 4, argKey: "bltype" }, { regex: /((^|[^\\])((\\)\\)*\$colorRangeLabel)/ig, escapeRegex: /((^|[^\\])((\\)\\)*\\(\$colorRangeLabel))/ig, argIndex: 5, argKey: "colorRangeLabel"}], b = [], c, d = a.length; for (c = 0; c < d; c += 1) b.push(c);
    return function () { var c = arguments[0], d = arguments[1], q, g, w, f, h; !d instanceof Array && (d = b); if (c) for (h = d.length, f = 0; f < h; f += 1) if (w = a[d[f]]) q = da(xa((g = arguments[w.argIndex]) && g[w.argKey], "") + ""), c = c.replace(w.regex, "$2$4" + (w.parsingMethod ? w.parsingMethod(q) : q)), c = c.replace(w.escapeRegex, "$2$4$5"); return c } 
} (); d.core._setLineHeightFactor = function (a) { !(a = b(a)) || 0 > a || ($.lineHeightFactor = a) }; d.extend($, { BLANKSTRINGPLACEHOLDER: "#BLANK#", BLANKSTRING: "", COLOR_BLACK: "000000", COLOR_GLASS: "rgba(255, 255, 255, 0.3)",
    COLOR_WHITE: "FFFFFF", COLOR_TRANSPARENT: "rgba(0,0,0,0)", HASHSTRING: "#", BREAKSTRING: "<br />", STRINGSTRING: "string", OBJECTSTRING: "object", COMMASTRING: ",", ZEROSTRING: "0", SAMPLESTRING: "Ay0", TESTSTR: "Ag", ONESTRING: "1", DECIMALSTRING: ".", STRINGUNDEFINED: "undefined", POSITION_TOP: "top", POSITION_RIGHT: "right", POSITION_BOTTOM: "bottom", POSITION_LEFT: "left", POSITION_CENTER: "center", POSITION_MIDDLE: "middle", POSITION_START: "start", POSITION_END: "end", FC_CONFIG_STRING: "_FCconf", SHAPE_RECT: "rect", HUNDREDSTRING: "100",
    PXSTRING: "px", COMMASPACE: ", ", TEXTANCHOR: "text-anchor", TOUCH_THRESHOLD_PIXELS: 15, CLICK_THRESHOLD_PIXELS: 5, regex: { stripWhitespace: P, dropHash: c, startsRGBA: J, cleanColorCode: a, breakPlaceholder: B, hexcode: /^#?[0-9a-f]{6}/i }, fireEvent: function (a, b, c, d) { $.dem.fire(a, b, c, d) }, plotEventHandler: function (a, b, c) {
        b = b || {}; var q = b.type, g = Q(a.container, b), g = ga(g, this.data("eventArgs")), r = a.logic.fireGroupEvent, w = this.data("groupId"), f = function (a, c) { b.FusionChartsPreventEvent = !0; l && c.toolText && $.toolTip && $.toolTip.preventTooltip() };
        "index" in g && !("dataIndex" in g) && (g.dataIndex = g.index); "value" in g && !("dataValue" in g) && (g.dataValue = g.value); c = S(c, "dataplotclick").toLowerCase(); "dataplotrollover" === c ? (b.FusionChartsPreventEvent = !1, r ? d.raiseEventGroup(w, c, g, a.fusionCharts, void 0, void 0, f) : d.raiseEvent(c, g, a.logic.chartInstance, void 0, void 0, f)) : r && "dataplotclick" !== c ? d.raiseEventGroup(w, c, g, a.fusionCharts) : d.raiseEvent(c, g, a.logic.chartInstance); ("click" === q || "mouseup" === q && "dataplotclick" === c) && a.linkClickFN.call({ link: g.link },
a)
    }, getMouseCoordinate: Q, addEvent: ca, removeEvent: ha, getTouchEvent: w, extend2: ga, deltend: function (a, b) { if ("object" !== typeof a || "object" !== typeof b) return null; Aa(a, b); return a }, imprint: function (a, b, c) { var d; if ("object" !== typeof a || null === a) return b; if ("object" !== typeof b || null === b) return a; for (d in b) if (void 0 === a[d] || !c && null === a[d]) a[d] = b[d]; return a }, pluck: S, pluckNumber: aa, getFirstDefinedValue: function () { var a, b, c; b = 0; for (c = arguments.length; b < c; b += 1) if ((a = arguments[b]) || !1 === a || 0 === a || "" == a) return a },
    createElement: function (a, b, c) { a = E.createElement(a); for (var d in b) a.setAttribute(d, b[d]); c && c.appendChild && c.appendChild(a); return a }, hashify: K, pluckFontSize: function () { var a, b, c; b = 0; for (c = arguments.length; b < c; b += 1) if (((a = arguments[b]) || !1 === a || 0 === a) && !isNaN(a = Number(a))) return 1 > a ? 1 : a; return 1 }, getValidValue: xa, getPosition: ba, getViewPortDimension: m, bindSelectionEvent: function (a, b) {
        b = b || {}; var c = a.options.chart, d = a.container, g = c.zoomType, r = ga({}, b.attr || {}), w = r["stroke-width"] = aa(r.strokeWidth, r["stroke-width"],
1), f = ba(d), h = a.eventListeners || (a.eventListeners = []); b = ga({ chart: a, zoomX: /x/.test(g), zoomY: /y/.test(g), canvasY: a.canvasTop, canvasX: a.canvasLeft, canvasW: a.canvasWidth, canvasH: a.canvasHeight, canvasX2: a.canvasLeft + a.canvasWidth, canvasY2: a.canvasTop + a.canvasHeight, strokeWidth: w, chartPosLeft: f.left, chartPosTop: f.top, attr: r }, b); r.stroke = ua(r.stroke, "rgba(51,153,255,0.8)"); r.fill = ua(r.fill, "rgba(185,213,241,0.3)"); r.ishot = !0; d && (ha(d, "pointerdrag", C), h.push(ca(d, "pointerdrag", C, b))); c.link && (ha(a.container,
"mouseup mousedown", V), h.push(ca(a.container, "mouseup mousedown", V, b)))
    }, createContextMenu: function (a) {
        var b = a.chart, c = b.smartLabel, d = b.logic.hcJSON && b.logic.hcJSON.chart.useRoundEdges, g = $.Raphael, r = function (a) { var b = a.menufillcolor && K(a.menufillcolor), c = a.menulabelcolor && K(a.menulabelcolor), v = a.menufillhovercolor && K(a.menufillhovercolor); a = a.menulabelhovercolor && K(a.menulabelhovercolor); return { attrs: { backgroundColor: b, color: c }, hover: { backgroundColor: v, color: a}} } (b.definition.chart), w = function (a,
b, c) { b = b || {}; a = (a = (a = a && g.tintshade(a.color, 0.7)) && g.getRGB(a)) && "rgb(" + [a.r, a.g, a.b].join() + ")"; return { backgroundColor: b.backgroundHoverColor || c.backgroundColor || a || "rgb(64, 64, 64)", color: b.hoverColor || c.color || "#FFFFFF"} } (a.basicStyle, a.hover, r.hover), f = function (a, b, c) { b = b || {}; return { fontSize: b.fontSize || "12px", color: b.color || c.color || "#000000", backgroundColor: b.backgroundColor || c.backgroundColor || "rgb(255, 255, 255)"} } (a.basicStyle, a.attrs, r.attrs), h = { textAlign: "left", align: "left", paddingLeft: "5px",
    cursor: "pointer", borderWidth: "0px"
}, k = a.items, s = a.position, I = a.verticalPadding || 3, m = a.horizontalPadding || 6, G = {}, Q, M, C, B, S, t, n, H, aa, la, N, J, ca; if (b) Q = ba(b.container); else return !1; B = function () {
    var a = G.items, b = a.length, p = 0, v = 0, A = 0, F, e; G.menuItems || (G.menuItems = []); for (c.setStyle(f); b--; ) F = a[b], F = c.getOriSize(F.text), A || (A = F.height + 2 * I), p += A, v = z(v, F.width + 2 * m); G.height = p; G.width = v; G.itemH = A; this.style.width = v + "px"; G.menuRect || (p = G.menuRect = E.createElement("div"), p.style.border = "1px solid rgb(100, 100, 100)",
d && (p.style.mozBorderRadius = "4px", p.style.webkitBorderRadius = "4px", p.style.borderRadius = "4px", p.style.overflow = "hidden"), l && !u ? p.style.filter = "progid:DXImageTransform.Microsoft.Shadow(Color=#999999,direction=135,strength=3)" : (p.style.mozBoxShadow = "3px 3px 3px #999", p.style.webkitBoxShadow = "3px 3px 3px #999", p.style.boxShadow = "3px 3px 3px #999"), this.appendChild(p)); v = a.length; for (b = 0; b < v; b += 1) if (F = a[b], G.menuItems[b]) G.menuItems[b].label.innerHTML = F.text; else {
        G.menuItems[b] = {}; p = G.menuItems[b].box =
E.createElement("div"); p.style.height = A + "px"; p.style.lineHeight = A + "px"; for (e in h) p.style[e] = h[e]; for (e in f) p.style[e] = f[e]; G.menuRect.appendChild(p); p.innerHTML = F.text; $.dem.listen(p, "click", ca); $.dem.listen(p, "pointerhover", la); G.menuItems[b].box._itemIdx = b
    } for (; G.menuItems[b]; ) G.menuItems[b].box.parentNode.removeChild(G.menuItems[b].box), G.menuItems.splice(b, 1)
}; S = function () {
    C || (C = E.createElement("div"), C.style.position = "absolute", C.style.zIndex = "50", C.style.display = "none", b.container.appendChild &&
b.container.appendChild(C)); return C
}; t = function () { M = setTimeout(G.hide, 800) }; n = function () { M && clearTimeout(M) }; H = function (a) { var c = a.x; a = a.y; var p = { x: c, y: a }, v = G.width, d = G.height, q = b.chartHeight; c + v > b.chartWidth && 0 < c - v && (p.x -= v); a + d > q && 0 < a - d && (p.y -= d); return p }; aa = function () { G.hide() }; la = function (a) { "start" === a.state ? N.call(a.target) : J.call(a.target) }; N = function () { var a = G.menuItems[this._itemIdx], b; n(); for (b in w) a.box.style[b] = w[b] }; J = function () {
    var a = G.menuItems[this._itemIdx], b; for (b in f) a.box.style[b] =
f[b]; t()
}; ca = function (a) { var b = G.items[this._itemIdx]; b.onclick && b.onclick.call(b, a); a.originalEvent.stopPropagation ? a.originalEvent.stopPropagation() : a.originalEvent.cancelBubble = !0; G.hide() }; G.showItem = function (a) { a = this.menuItems[a]; var b = this.height, c = this.itemH; a && a._isHidden && (a.box.style.display = "", this.height = b + c, a._isHidden = !1, a = H(s), this.left = a.x, this.top = a.y) }; G.hideItem = function (a) {
    a = this.menuItems[a]; var b = this.height, c = this.itemH; a && !a._isHidden && (a.box.style.display = "none", this.height =
b - c, a._isHidden = !0, a = H(s), this.left = a.x, this.top = a.y)
}; G.redraw = function () { var a = this.menuContainer; this.items = k; a ? B.call(this.menuContainer) : s && void 0 !== s.x && void 0 !== s.y ? (this.menuContainer = S(), B.call(this.menuContainer), a = H(s), this.left = a.x, this.top = a.y, this.menuContainer.style.left = this.left + "px", this.menuContainer.style.top = this.top + "px") : (this.menuContainer = S(), B.call(this.menuContainer)) }; G.show = function (a) {
    var b = this; a && void 0 !== a.x && void 0 !== a.y ? (a = H(a), b.menuContainer.style.left = a.x + "px",
b.menuContainer.style.top = a.y + "px") : (b.menuContainer.style.left = b.left + "px", b.menuContainer.style.top = b.top + "px"); b.menuContainer.style.display = ""; setTimeout(function () { b.visible = !0; g.click(aa) }, 400)
}; G.hide = function () { this.visible && (this.visible = !1, G.menuContainer.style.display = "none", G.menuContainer.style.left = -G.width + "px", G.menuContainer.style.top = -G.height + "px", g.unclick(aa)) }; G.update = function (a) { a && a.length && (this.items = a, this.redraw()) }; G.updatePosition = function (a) {
    var c = Q.left, p = Q.top; Q =
ba(b.container); a ? (s = a, a = H(a), this.left = a.x, this.top = a.y) : (this.left -= c - Q.left, this.top -= p - Q.top)
}; G.add = function (a) {
    var b = this.menuItems, p = b.length, v; c.setStyle(f); this.width = z(this.width, c.getOriSize(a.text).width); b[p] = {}; b = b[p].box = E.createElement("div"); b.style.height = this.itemH + "px"; b.style.lineHeight = this.itemH + "px"; for (v in h) b.style[v] = h[v]; for (v in f) b.style[v] = f[v]; G.menuRect.appendChild(b); b.innerHTML = a.text; $.dem.listen(b, "click", ca); $.dem.listen(b, "pointerhover", la); G.menuItems[p].box._itemIdx =
p; this.height += this.itemH
}; G.removeItems = function () { for (var a = this.menuItems, b = a && a.length, c; b--; ) c = a[b], $.dem.unlisten(c.box, "click", ca), $.dem.unlisten(c.box, "pointerhover", la), c.box && c.box.parentNode && c.box.parentNode.removeChild(c.box); delete this.menuItems; delete this.items }; G.setPosition = function (a) { void 0 !== a.x && void 0 !== a.y && (this.menuContainer.style.x = a.x, this.menuContainer.style.y = a.y) }; G.destroy = function () { this.removeItems(); this.menuContainer.parentNode.removeChild(this.menuContainer) };
        k && k.length && (G.redraw(), G.hide()); return G
    }, getDefinedColor: function (a, b) { return a || 0 === a || "" === a ? a : b }, getFirstValue: ua, getFirstColor: function (a) { a = a.split(",")[0]; a = a.replace(P, ""); "" == a && (a = "000000"); return a.replace(c, "#") }, getColorCodeString: function (a, b) { var c = "", d, g, r = 0, f = b.split(","); for (g = f.length; r < g; r += 1) d = f[r].split("-"), c = 2 === d.length ? "-1" !== d[0].indexOf("dark") ? c + (Ya(a, 100 - parseInt(d[1], 10)) + ",") : c + (qa(a, 100 - parseInt(d[1], 10)) + ",") : c + (f[r] + ","); return c.substring(0, c.length - 1) }, pluckColor: function (a) {
        if (xa(a)) return a =
a.split(",")[0], a = a.replace(P, ""), "" == a && (a = "000000"), a.replace(c, "#")
    }, toRaphaelColor: W, gradientify: fa, trimString: function (a) { a = a.replace(/^\s\s*/, ""); for (var b = /\s/, c = a.length; b.test(a.charAt(c -= 1)); ); return a.slice(0, c + 1) }, getFirstAlpha: function (a) { a = parseInt(a, 10); if (isNaN(a) || 100 < a || 0 > a) a = 100; return a }, parsePointValue: ja, parseUnsafeString: I, parseTooltext: wb, toPrecision: function (a, b) { var c = g(10, b); return k(a * c) / c }, hasTouch: s, CREDIT_HREF: "http://www.fusioncharts.com?BS=FCHSEvalMark", CREDIT_STRING: "FusionCharts XT Trial",
    getSentenceCase: function (a) { a = a || ""; return a.charAt(0).toUpperCase() + a.substr(1) }, getCrispValues: function (a, b, c) { var d = c % 2 / 2; c = k(a + d) - d; a = k(a + b + d) - d - c; return { position: c, distance: a} }, regescape: function (a) { return a && a.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&") }, regReplaceEscape: da, isArray: la, stubFN: function () { }, falseFN: function () { return !1 }, stableSort: function (a, b) { var c = a.length, d; for (d = 0; d < c; d++) a[d].ssI = d; a.sort(function (a, c) { var d = b(a, c); return 0 === d ? a.ssI - c.ssI : d }); for (d = 0; d < c; d++) delete a[d].ssI },
    hasSVG: u, isIE: l, lineHeightFactor: 1.2, getLinkAction: function (a, b) {
        var c = function (a) { return a }; return function () {
            var q = aa((a.chart || a.map || {}).unescapelinks, 1), g = ua(this.link, ""), r = S(g, this.options && this.options.chart && this.options.chart.link || "", this.series && this.series.chart && this.series.chart.options && this.series.chart.options.chart && this.series.chart.options.chart.link || ""), f = r, w, h, k, z, G, s, I, K, m, Q; void 0 !== r && (q && (r = n.decodeURIComponent ? n.decodeURIComponent(r) : n.unescape(r)), r = r.replace(/^\s+/,
"").replace(/\s+$/, ""), -1 !== r.search(/^[a-z]*\s*[\-\:]\s*/i) && (G = r.split(/\s*[\-\:]\s*/)[0].toLowerCase(), Q = G.length), setTimeout(function () {
    switch (G) {
        case "j": r = r.replace(/^j\s*\-/i, "j-"); w = r.indexOf("-", 2); -1 === w ? za(r.slice(2)) : za(r.substr(2, w - 2).replace(/\s/g, ""), r.slice(w + 1)); break; case "javascript": Ga(r.replace(/^javascript\s*\:/i, "")); break; case "n": r.replace(/^n\s*\-/i, "n-"); n.open(c(r.slice(2), q)); break; case "f": r = r.replace(/^f\s*\-/i, "f-"); w = r.indexOf("-", 2); -1 !== w ? (h = r.substr(2, w - 2)) && n.frames[h] ?
n.frames[h].location = c(r.slice(w + 1), q) : n.open(c(r.slice(w + 1), q), h) : n.open(c(r.slice(2), q)); break; case "p": r = r.replace(/p\s*\-/i, "p-"); w = r.indexOf("-", 2); k = r.indexOf(",", 2); -1 === w && (w = 1); z = c(r.slice(w + 1), q); n.open(z, r.substr(2, k - 2), r.substr(k + 1, w - k - 1)).focus(); break; case "newchart": case "newmap": ":" === r.charAt(Q) && (w = r.indexOf("-", Q + 1), m = r.substring(Q + 1, w), Q = w); w = r.indexOf("-", Q + 1); s = r.substring(Q + 1, w).toLowerCase(); switch (s) {
                case "xmlurl": case "jsonurl": K = r.substring(w + 1, r.length); break; case "xml": case "json": var g =
I = r.substring(w + 1, r.length), D = { chart: {} }, l, g = g.toLowerCase(); if (a.linkeddata) for (l = 0; l < a.linkeddata.length; l += 1) a.linkeddata[l].id.toLowerCase() === g && (D = a.linkeddata[l].linkedchart || a.linkeddata[l].linkedmap); K = D; s = "json"
            } d.raiseEvent("linkedChartInvoked", { alias: m, linkType: s.toUpperCase(), data: K }, b); break; default: n.location.href = r
    } d.raiseEvent("linkClicked", { linkProvided: f, linkInvoked: r, linkAction: G && G.toLowerCase() }, b)
}, 0))
        } 
    }, graphics: { parseAlpha: ma, convertColor: Ba, getDarkColor: qa, getLightColor: Ya,
        mapSymbolName: function (a, b) { var c = "circle"; a = ja(a); 3 <= a && (c = (b ? "spoke_" : "poly_") + a); return c }, getColumnColor: function (a, b, c, d, g, r, w, f, h) {
            var k, z; k = a.split(","); z = b.split(","); r = r.split(","); w = w.split(","); a = a.replace(/\s/g, "").replace(/\,$/, ""); h ? f = { FCcolor: { color: k[0], alpha: z[0]}} : g ? (a = k[0], z = z[0], f = { FCcolor: { color: qa(a, 75) + "," + Ya(a, 10) + "," + qa(a, 90) + "," + Ya(a, 55) + "," + qa(a, 80), alpha: z + "," + z + "," + z + "," + z + "," + z, ratio: "0,11,14,57,18", angle: f ? "90" : "0"} }, r = [qa(a, 70)]) : (b = ma(b, k.length), f = { FCcolor: { color: a,
                alpha: b, ratio: c, angle: f ? -d : d
            }
            }); return [f, { FCcolor: { color: r[0], alpha: w[0]}}]
        }, getAngle: function (a, b, c) { a = 180 * Math.atan(b / a) / Math.PI; 2 == c ? a = 180 - a : 3 == c ? a += 180 : 4 == c && (a = 360 - a); return a }, parseColor: Ca, getValidColor: function (a) { return N.test(Ca(a)) && a }, HSBtoRGB: function (a) {
            var b = a[0], c = 0, d = 0, g = 0, r = [], r = a[1] / 100; a = a[2] / 100; var w = b / 60 - Math.floor(b / 60), f = a * (1 - r), h = a * (1 - w * r), r = a * (1 - (1 - w) * r); switch (Math.floor(b / 60) % 6) {
                case 0: c = a; d = r; g = f; break; case 1: c = h; d = a; g = f; break; case 2: c = f; d = a; g = r; break; case 3: c = f; d = h;
                    g = a; break; case 4: c = r; d = f; g = a; break; case 5: c = a, d = f, g = h
            } return r = [k(255 * c), k(255 * d), k(255 * g)]
        }, RGBtoHSB: function (a) { var b = a[0], c = a[1]; a = a[2]; var d = Math.max(Math.max(b, c), a), g = Math.min(Math.min(b, c), a), r = 0, w = 0; d == g ? r = 0 : d == b ? r = (60 * (c - a) / (d - g) + 360) % 360 : d == c ? r = 60 * (a - b) / (d - g) + 120 : d == a && (r = 60 * (b - c) / (d - g) + 240); w = 0 === d ? 0 : (d - g) / d; return [k(r), k(100 * w), k(d / 255 * 100)] }, RGBtoHex: function (a) { return ("000000" + (a[0] << 16 | a[1] << 8 | a[2]).toString(16)).slice(-6) }, HEXtoRGB: Fa
    }, setImageDisplayMode: function (a, b, c, d, g, r, w, f) {
        var h =
d / 100 * f.width; d = d / 100 * f.height; f = {}; var k, z = r - 2 * g; k = w - 2 * g; var G = function (a, b, c, d, r, q) { var f = {}; switch (a) { case "top": f.y = g; break; case "bottom": f.y = q - d - g; break; case "middle": f.y = (q - d) / 2 } switch (b) { case "left": f.x = g; break; case "right": f.x = r - c - g; break; case "middle": f.x = (r - c) / 2 } return f }; switch (a) {
            case "center": f.width = h; f.height = d; f.y = w / 2 - d / 2; f.x = r / 2 - h / 2; break; case "stretch": f.width = r - 2 * g; f.height = w - 2 * g; f.y = g; f.x = g; break; case "tile": f.width = h; f.height = d; f.tileInfo = {}; f.tileInfo.xCount = a = Math.ceil(z / h);
                f.tileInfo.yCount = k = Math.ceil(k / d); b = G(b, c, h * a, d * k, r, w); f.y = b.y; f.x = b.x; break; case "fit": a = h / d > z / k ? z / h : k / d; f.width = h * a; f.height = d * a; b = G(b, c, f.width, f.height, r, w); f.y = b.y; f.x = b.x; break; case "fill": a = h / d > z / k ? k / d : z / h; f.width = h * a; f.height = d * a; b = G(b, c, f.width, f.height, r, w); f.y = b.y; f.x = b.x; break; default: b = G(b, c, h, d, r, w), f.width = h, f.height = d, f.y = b.y, f.x = b.x
        } return f
    }, setLineHeight: function (a, b) {
        if ("object" !== typeof a) return ""; a.lineHeight || a["line-height"] ? !a.lineHeight && a["line-height"] && (a.lineHeight =
a["line-height"], delete a["line-height"]) : (!a.fontSize && a["font-size"] && (a.fontSize = a["font-size"], delete a["font-size"]), a.lineHeight = (parseFloat(a.fontSize) || b || 10) * $.lineHeightFactor + "px"); return a.lineHeight
    }, supportedStyle: { font: "font", fontFamily: "font-family", "font-family": "font-family", fontWeight: "font-weight", "font-weight": "font-weight", fontSize: "font-size", "font-size": "font-size", lineHeight: "line-height", "line-height": "line-height", textDecoration: "text-decoration", "text-decoration": "text-decoration",
        color: "color", whiteSpace: "white-space", "white-space": "white-space", padding: "padding", margin: "margin", background: "background", backgroundColor: "background-color", "background-color": "background-color", backgroundImage: "background-image", "background-image": "background-image", backgroundPosition: "background-position", "background-position": "background-position", backgroundPositionLeft: "background-position-left", "background-position-left": "background-position-left", backgroundPositionTop: "background-position-top",
        "background-position-top": "background-position-top", backgroundRepeat: "background-repeat", "background-repeat": "background-repeat", border: "border", borderColor: "border-color", "border-color": "border-color", borderStyle: "border-style", "border-style": "border-style", borderThickness: "border-thickness", "border-thickness": "border-thickness", borderTop: "border-top", "border-top": "border-top", borderTopColor: "border-top-color", "border-top-color": "border-top-color", borderTopStyle: "border-top-style", "border-top-style": "border-top-style",
        borderTopThickness: "border-top-thickness", "border-top-thickness": "border-top-thickness", borderRight: "border-right", "border-right": "border-right", borderRightColor: "border-right-color", "border-right-color": "border-right-color", borderRightStyle: "border-right-style", "border-right-style": "border-right-style", borderRightThickness: "border-right-thickness", "border-right-thickness": "border-right-thickness", borderBottom: "border-bottom", "border-bottom": "border-bottom", borderBottomColor: "border-bottom-color",
        "border-bottom-color": "border-bottom-color", borderBottomStyle: "border-bottom-style", "border-bottom-style": "border-bottom-style", borderBottomThickness: "border-bottom-thickness", "border-bottom-thickness": "border-bottom-thickness", borderLeft: "border-left", "border-left": "border-left", borderLeftColor: "border-left-color", "border-left-color": "border-left-color", borderLeftStyle: "border-left-style", "border-left-Style": "border-left-style", borderLeftThickness: "border-left-thickness", "border-left-thickness": "border-left-thickness"
    },
    getAxisLimits: Kb, createTrendLine: yb, getDashStyle: bb, axisLabelAdder: Pa, chartAPI: db, createDialog: Na
})
} ]);
window.FusionCharts && window.FusionCharts.register("module", ["private", "vendor.redraphael", function () {
    var d = this.hcLib, n = window.Raphael, E; (function () {
        (function (d) {
            var l = /[\.\/]/, b = function () { }, n = function (a, b) { return a - b }, c, J, a = { n: {} }, B = function (a, b) {
                a = String(a); var d = J, k = Array.prototype.slice.call(arguments, 2), f = B.listeners(a), h = 0, s, l = [], m = {}, z = [], H = c; c = a; for (var M = J = 0, u = f.length; M < u; M++) "zIndex" in f[M] && (l.push(f[M].zIndex), 0 > f[M].zIndex && (m[f[M].zIndex] = f[M])); for (l.sort(n); 0 > l[h]; ) if (s = m[l[h++]],
z.push(s.apply(b, k)), J) return J = d, z; for (M = 0; M < u; M++) if (s = f[M], "zIndex" in s) if (s.zIndex == l[h]) { z.push(s.apply(b, k)); if (J) break; do if (h++, (s = m[l[h]]) && z.push(s.apply(b, k)), J) break; while (s) } else m[s.zIndex] = s; else if (z.push(s.apply(b, k)), J) break; J = d; c = H; return z.length ? z : null
            }; B._events = a; B.listeners = function (b) { b = b.split(l); var c = a, d, k, f, h, s, B, m, z = [c], n = []; f = 0; for (h = b.length; f < h; f++) { m = []; s = 0; for (B = z.length; s < B; s++) for (c = z[s].n, d = [c[b[f]], c["*"]], k = 2; k--; ) if (c = d[k]) m.push(c), n = n.concat(c.f || []); z = m } return n };
            B.on = function (c, d) { c = String(c); if ("function" != typeof d) return function () { }; for (var g = c.split(l), k = a, f = 0, h = g.length; f < h; f++) k = k.n, k = k.hasOwnProperty(g[f]) && k[g[f]] || (k[g[f]] = { n: {} }); k.f = k.f || []; f = 0; for (h = k.f.length; f < h; f++) if (k.f[f] == d) return b; k.f.push(d); return function (a) { +a == +a && (d.zIndex = +a) } }; B.f = function (a) { var b = [].slice.call(arguments, 1); return function () { B.apply(null, [a, null].concat(b).concat([].slice.call(arguments, 0))) } }; B.stop = function () { J = 1 }; B.nt = function (a) {
                return a ? (new RegExp("(?:\\.|\\/|^)" +
a + "(?:\\.|\\/|$)")).test(c) : c
            }; B.nts = function () { return c.split(l) }; B.off = B.unbind = function (b, c) {
                if (b) {
                    var d = b.split(l), k, f, h, s, n, m, z = [a]; s = 0; for (n = d.length; s < n; s++) for (m = 0; m < z.length; m += h.length - 2) { h = [m, 1]; k = z[m].n; if ("*" != d[s]) k[d[s]] && h.push(k[d[s]]); else for (f in k) k.hasOwnProperty(f) && h.push(k[f]); z.splice.apply(z, h) } s = 0; for (n = z.length; s < n; s++) for (k = z[s]; k.n; ) {
                        if (c) {
                            if (k.f) { m = 0; for (d = k.f.length; m < d; m++) if (k.f[m] == c) { k.f.splice(m, 1); break } !k.f.length && delete k.f } for (f in k.n) if (k.n.hasOwnProperty(f) &&
k.n[f].f) { h = k.n[f].f; m = 0; for (d = h.length; m < d; m++) if (h[m] == c) { h.splice(m, 1); break } !h.length && delete k.n[f].f } 
                        } else for (f in delete k.f, k.n) k.n.hasOwnProperty(f) && k.n[f].f && delete k.n[f].f; k = k.n
                    } 
                } else B._events = a = { n: {}}
            }; B.once = function (a, b) { var c = function () { B.unbind(a, c); return b.apply(this, arguments) }; return B.on(a, c) }; B.version = "0.4.2"; B.toString = function () { return "You are running Eve 0.4.2" }; "undefined" != typeof module && module.exports ? module.exports = B : "undefined" != typeof define ? define("eve", [], function () { return B }) :
d.eve = B
        })(this); (function (d, l) { "function" === typeof define && define.amd ? define(["eve"], function (b) { return l(d, b) }) : l(d, d.eve) })(this, function (d, l) {
            function b(a) {
                var c, e; b._url = ""; if (b.is(a, "function")) return s ? a() : l.on("raphael.DOMload", a); if (b.is(a, $)) return b._engine.create[z](b, a.splice(0, 3 + b.is(a[0], M))).add(a); c = Array.prototype.slice.call(arguments, 0); return b.is(c[c.length - 1], "function") ? (e = c.pop(), s ? e.call(b._engine.create[z](b, c)) : l.on("raphael.DOMload", function () {
                    e.call(b._engine.create[z](b,
c))
                })) : b._engine.create[z](b, arguments)
            } function n() { return this.hex } function c(a, b) {
                for (var c = [], e = 0, p = a.length; p - 2 * !b > e; e += 2) {
                    var d = [{ x: +a[e - 2], y: +a[e - 1] }, { x: +a[e], y: +a[e + 1] }, { x: +a[e + 2], y: +a[e + 3] }, { x: +a[e + 4], y: +a[e + 5]}]; b ? e ? p - 4 == e ? d[3] = { x: +a[0], y: +a[1]} : p - 2 == e && (d[2] = { x: +a[0], y: +a[1] }, d[3] = { x: +a[2], y: +a[3] }) : d[0] = { x: +a[p - 2], y: +a[p - 1]} : p - 4 == e ? d[3] = d[2] : e || (d[0] = { x: +a[e], y: +a[e + 1] }); c.push(["C", (-d[0].x + 6 * d[1].x + d[2].x) / 6, (-d[0].y + 6 * d[1].y + d[2].y) / 6, (d[1].x + 6 * d[2].x - d[3].x) / 6, (d[1].y + 6 * d[2].y - d[3].y) /
6, d[2].x, d[2].y])
                } return c
            } function J(a, b, c, e, p, d, v, A, F) { null == F && (F = 1); F = (1 < F ? 1 : 0 > F ? 0 : F) / 2; for (var r = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816], g = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472], q = 0, f = 0; 12 > f; f++) var w = F * r[f] + F, O = w * (w * (-3 * a + 9 * c - 9 * p + 3 * v) + 6 * a - 12 * c + 6 * p) - 3 * a + 3 * c, w = w * (w * (-3 * b + 9 * e - 9 * d + 3 * A) + 6 * b - 12 * e + 6 * d) - 3 * b + 3 * e, q = q + g[f] * W(O * O + w * w); return F * q } function a(a, b, c, e, p, d, v, A, F) {
                if (!(0 > F || J(a, b, c, e, p, d, v, A) < F)) {
                    var r =
0.5, g = 1 - r, q; for (q = J(a, b, c, e, p, d, v, A, g); 0.01 < Ga(q - F); ) r /= 2, g += (q < F ? 1 : -1) * r, q = J(a, b, c, e, p, d, v, A, g); return g
                } 
            } function B(a, c, e) {
                a = b._path2curve(a); c = b._path2curve(c); for (var p, d, v, A, F, r, g, q, f, w, O = e ? 0 : [], R = 0, h = a.length; R < h; R++) if (f = a[R], "M" == f[0]) p = F = f[1], d = r = f[2]; else {
                    "C" == f[0] ? (f = [p, d].concat(f.slice(1)), p = f[6], d = f[7]) : (f = [p, d, p, d, F, r, F, r], p = F, d = r); for (var k = 0, z = c.length; k < z; k++) if (w = c[k], "M" == w[0]) v = g = w[1], A = q = w[2]; else {
                        "C" == w[0] ? (w = [v, A].concat(w.slice(1)), v = w[6], A = w[7]) : (w = [v, A, v, A, g, q, g, q], v = g,
A = q); var D; var G = f, s = w; D = e; var Z = b.bezierBBox(G), I = b.bezierBBox(s); if (b.isBBoxIntersect(Z, I)) {
                            for (var Z = J.apply(0, G), I = J.apply(0, s), Z = Aa(~ ~(Z / 5), 1), I = Aa(~ ~(I / 5), 1), K = [], m = [], Q = {}, L = D ? 0 : [], l = 0; l < Z + 1; l++) { var Ea = b.findDotsAtSegment.apply(b, G.concat(l / Z)); K.push({ x: Ea.x, y: Ea.y, t: l / Z }) } for (l = 0; l < I + 1; l++) Ea = b.findDotsAtSegment.apply(b, s.concat(l / I)), m.push({ x: Ea.x, y: Ea.y, t: l / I }); for (l = 0; l < Z; l++) for (G = 0; G < I; G++) {
                                var La = K[l], mc = K[l + 1], s = m[G], Ea = m[G + 1], vc = 0.001 > Ga(mc.x - La.x) ? "y" : "x", C = 0.001 > Ga(Ea.x - s.x) ?
"y" : "x", U; U = La.x; var M = La.y, oc = mc.x, Sb = mc.y, n = s.x, B = s.y, S = Ea.x, H = Ea.y; if (Aa(U, oc) < za(n, S) || za(U, oc) > Aa(n, S) || Aa(M, Sb) < za(B, H) || za(M, Sb) > Aa(B, H)) U = void 0; else {
                                    var aa = (U * Sb - M * oc) * (n - S) - (U - oc) * (n * H - B * S), la = (U * Sb - M * oc) * (B - H) - (M - Sb) * (n * H - B * S), T = (U - oc) * (B - H) - (M - Sb) * (n - S); if (T) {
                                        var aa = aa / T, la = la / T, T = +aa.toFixed(2), Ac = +la.toFixed(2); U = T < +za(U, oc).toFixed(2) || T > +Aa(U, oc).toFixed(2) || T < +za(n, S).toFixed(2) || T > +Aa(n, S).toFixed(2) || Ac < +za(M, Sb).toFixed(2) || Ac > +Aa(M, Sb).toFixed(2) || Ac < +za(B, H).toFixed(2) || Ac > +Aa(B,
H).toFixed(2) ? void 0 : { x: aa, y: la}
                                    } else U = void 0
                                } U && Q[U.x.toFixed(4)] != U.y.toFixed(4) && (Q[U.x.toFixed(4)] = U.y.toFixed(4), La = La.t + Ga((U[vc] - La[vc]) / (mc[vc] - La[vc])) * (mc.t - La.t), s = s.t + Ga((U[C] - s[C]) / (Ea[C] - s[C])) * (Ea.t - s.t), 0 <= La && 1.001 >= La && 0 <= s && 1.001 >= s && (D ? L++ : L.push({ x: U.x, y: U.y, t1: za(La, 1), t2: za(s, 1) })))
                            } D = L
                        } else D = D ? 0 : []; if (e) O += D; else { Z = 0; for (I = D.length; Z < I; Z++) D[Z].segment1 = R, D[Z].segment2 = k, D[Z].bez1 = f, D[Z].bez2 = w; O = O.concat(D) } 
                    } 
                } return O
            } function N(a, b, c, e, p, d) {
                null != a ? (this.a = +a, this.b = +b,
this.c = +c, this.d = +e, this.e = +p, this.f = +d) : (this.a = 1, this.c = this.b = 0, this.d = 1, this.f = this.e = 0)
            } function t() { return this.x + sa + this.y + sa + this.width + " Ã— " + this.height } function g(a, b, c, e, p, d) {
                function v(a, b) { var c, Lb, e, p; e = a; for (Lb = 0; 8 > Lb; Lb++) { p = ((r * e + F) * e + A) * e - a; if (Ga(p) < b) return e; c = (3 * r * e + 2 * F) * e + A; if (1E-6 > Ga(c)) break; e -= p / c } c = 0; Lb = 1; e = a; if (e < c) return c; if (e > Lb) return Lb; for (; c < Lb; ) { p = ((r * e + F) * e + A) * e; if (Ga(p - a) < b) break; a > p ? c = e : Lb = e; e = (Lb - c) / 2 + c } return e } var A = 3 * b, F = 3 * (e - b) - A, r = 1 - A - F, g = 3 * c, q = 3 * (p - c) -
g, f = 1 - g - q; return function (a, b) { var c = v(a, b); return ((f * c + q) * c + g) * c } (a, 1 / (200 * d))
            } function k(a, b) { var c = [], e = {}; this.ms = b; this.times = 1; if (a) { for (var p in a) a[m](p) && (e[la(p)] = a[p], c.push(la(p))); c.sort(U) } this.anim = e; this.top = c[c.length - 1]; this.percents = c } function f(a, c, e, p, d, v) {
                e = la(e); var A, F, q, f, w, O, R = a.ms, h = {}, k = {}, z = {}; if (p) for (O = 0, Z = Ma.length; O < Z; O++) { var s = Ma[O]; if (s.el.id == c.id && s.anim == a) { s.percent != e ? (Ma.splice(O, 1), q = 1) : F = s; c.attr(s.totalOrigin); break } } else p = +k; O = 0; for (var Z = a.percents.length; O <
Z; O++) if (a.percents[O] == e || a.percents[O] > p * a.top) { e = a.percents[O]; w = a.percents[O - 1] || 0; R = R / a.top * (e - w); f = a.percents[O + 1]; A = a.anim[e]; break } else p && c.attr(a.anim[a.percents[O]]); if (A) {
                    if (F) F.initstatus = p, F.start = new Date - F.ms * p; else {
                        for (var I in A) if (A[m](I) && (r[m](I) || c.ca[I])) switch (h[I] = c.attr(I), null == h[I] && (h[I] = D[I]), k[I] = A[I], r[I]) {
                            case M: z[I] = (k[I] - h[I]) / R; break; case "colour": h[I] = b.getRGB(h[I]); O = b.getRGB(k[I]); z[I] = { r: (O.r - h[I].r) / R, g: (O.g - h[I].g) / R, b: (O.b - h[I].b) / R }; break; case "path": O =
mc(h[I], k[I]); s = O[1]; h[I] = O[0]; z[I] = []; O = 0; for (Z = h[I].length; O < Z; O++) { z[I][O] = [0]; for (var K = 1, Q = h[I][O].length; K < Q; K++) z[I][O][K] = (s[O][K] - h[I][O][K]) / R } break; case "transform": O = c._; if (Z = oc(O[I], k[I])) for (h[I] = Z.from, k[I] = Z.to, z[I] = [], z[I].real = !0, O = 0, Z = h[I].length; O < Z; O++) for (z[I][O] = [h[I][O][0]], K = 1, Q = h[I][O].length; K < Q; K++) z[I][O][K] = (k[I][O][K] - h[I][O][K]) / R; else Z = c.matrix || new N, O = { _: { transform: O.transform }, getBBox: function () { return c.getBBox(1) } }, h[I] = [Z.a, Z.b, Z.c, Z.d, Z.e, Z.f], Wc(O, k[I]), k[I] =
O._.transform, z[I] = [(O.matrix.a - Z.a) / R, (O.matrix.b - Z.b) / R, (O.matrix.c - Z.c) / R, (O.matrix.d - Z.d) / R, (O.matrix.e - Z.e) / R, (O.matrix.f - Z.f) / R]; break; case "csv": Z = G(A[I])[C](Na); s = G(h[I])[C](Na); if ("clip-rect" == I) for (h[I] = s, z[I] = [], O = s.length; O--; ) z[I][O] = (Z[O] - h[I][O]) / R; k[I] = Z; break; default: for (Z = [][H](A[I]), s = [][H](h[I]), z[I] = [], O = c.ca[I].length; O--; ) z[I][O] = ((Z[O] || 0) - (s[O] || 0)) / R
                        } O = A.easing; I = b.easing_formulas[O]; if (!I) if ((I = G(O).match(bb)) && 5 == I.length) {
                            var L = I; I = function (a) {
                                return g(a, +L[1], +L[2], +L[3],
+L[4], R)
                            } 
                        } else I = pa; O = A.start || a.start || +new Date; s = { anim: a, percent: e, timestamp: O, start: O + (a.del || 0), status: 0, initstatus: p || 0, stop: !1, ms: R, easing: I, from: h, diff: z, to: k, el: c, callback: A.callback, prev: w, next: f, repeat: v || a.times, origin: c.attr(), totalOrigin: d }; Ma.push(s); if (p && !F && !q && (s.stop = !0, s.start = new Date - R * p, 1 == Ma.length)) return pc(); q && (s.start = new Date - s.ms * p); 1 == Ma.length && Qa(pc)
                    } l("raphael.anim.start." + c.id, c, a)
                } 
            } function h(a) { for (var b = 0; b < Ma.length; b++) Ma[b].el.paper == a && Ma.splice(b--, 1) }
            b.upgrade = "1.0.0"; b.version = "2.1.0"; b.eve = l; E = b; var s, sa = " ", m = "hasOwnProperty", z = "apply", H = "concat", M = "number", $ = "array", C = "split", V = Array.prototype.slice, ba = Array.prototype.splice, da = { doc: document, win: d }, xa = Object.prototype[m].call(da.win, "Raphael"), ua = da.win.Raphael, S = da.doc, ca = da.win, ha = b.supportsTouch = "createTouch" in S, w = function () { }; b.ca = b.customAttributes = w.prototype; var Q = function () {
                this.ca = this.customAttributes = new w; this._CustomAttributes = function () { }; this._CustomAttributes.prototype = this.ca;
                this._elementsById = {}; this.id = b._oid++; l("raphael.new", this)
            }, K = b.fn = Q.prototype = b.prototype, aa = { circle: 1, rect: 1, path: 1, ellipse: 1, text: 1, image: 1, group: 1 }, ja = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel"[C](sa), I = b._touchMap = { mousedown: "touchstart", mousemove: "touchmove", mouseup: "touchend" }, G = ca.String, la = ca.parseFloat, Xa = ca.parseInt, ga = ca.Math, Aa = ga.max, za = ga.min, Ga = ga.abs, X = ga.pow, ma = ga.cos, Ba = ga.sin, W = ga.sqrt, fa = ga.round, Ca = ga.PI, qa = Ca /
180, Ya = 180 / Ca, Fa = G.prototype.toLowerCase, Pa = G.prototype.toUpperCase, Kb = ca.Object.prototype.toString, Na = /[, ]+/, qb = /\{(\d+)\}/g; b._ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i; var yb = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i, bb = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
hb = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/, db = /,?([achlmqrstvxz]),?/gi, wb = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
tb = /([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig, mb = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig;
            b._radial_gradient = /^x?r(?:\(([^\)]*?)\))?/; var Fb = { NaN: 1, Infinity: 1, "-Infinity": 1 }, q = { hs: 1, rg: 1 }, D = b._availableAttrs = { "arrow-end": "none", "arrow-start": "none", blur: 0, "clip-rect": "0 0 1e9 1e9", "clip-path": "", cursor: "default", cx: 0, cy: 0, fill: "#fff", "fill-opacity": 1, font: '10px "Arial"', "font-family": '"Arial"', "font-size": "10", "font-style": "normal", "font-weight": 400, gradient: 0, height: 0, href: "about:blank", "letter-spacing": 0, "line-height": 12, "vertical-align": "middle", opacity: 1, path: "M0,0", r: 0, rx: 0, ry: 0,
                src: "", stroke: "#000", "stroke-dasharray": "", "stroke-linecap": "butt", "stroke-linejoin": "butt", "stroke-miterlimit": 0, "stroke-opacity": 1, "stroke-width": 1, target: "_blank", "text-anchor": "middle", visibility: "", title: "", transform: "", rotation: 0, width: 0, x: 0, y: 0
            }, r = b._availableAnimAttrs = { blur: M, "clip-rect": "csv", "clip-path": "path", cx: M, cy: M, fill: "colour", "fill-opacity": M, "font-size": M, height: M, opacity: M, path: "path", r: M, rx: M, ry: M, stroke: "colour", "stroke-opacity": M, "stroke-width": M, transform: "transform", width: M,
                x: M, y: M
            }, L = {}, U = function (a, b) { return la(a) - la(b) }, T = function () { }, pa = function (a) { return a }, ka = b._rectPath = function (a, b, c, e, p) { return p ? [["M", a + p, b], ["l", c - 2 * p, 0], ["a", p, p, 0, 0, 1, p, p], ["l", 0, e - 2 * p], ["a", p, p, 0, 0, 1, -p, p], ["l", 2 * p - c, 0], ["a", p, p, 0, 0, 1, -p, -p], ["l", 0, 2 * p - e], ["a", p, p, 0, 0, 1, p, -p], ["z"]] : [["M", a, b], ["l", c, 0], ["l", 0, e], ["l", -c, 0], ["z"]] }, ia = function (a, b, c, e) { null == e && (e = c); return [["M", a, b], ["m", 0, -e], ["a", c, e, 0, 1, 1, 0, 2 * e], ["a", c, e, 0, 1, 1, 0, -2 * e], ["z"]] }, va = b._getPath = { group: function () { return !1 },
                path: function (a) { return a.attr("path") }, circle: function (a) { a = a.attrs; return ia(a.cx, a.cy, a.r) }, ellipse: function (a) { a = a.attrs; return ia(a.cx, a.cy, a.rx, a.ry) }, rect: function (a) { a = a.attrs; return ka(a.x, a.y, a.width, a.height, a.r) }, image: function (a) { a = a.attrs; return ka(a.x, a.y, a.width, a.height) }, text: function (a) { a = a._getBBox(); return ka(a.x, a.y, a.width, a.height) } 
            }, Ka = b.mapPath = function (a, b) {
                if (!b) return a; var c, e, p, d, v, A, F; a = mc(a); p = 0; for (v = a.length; p < v; p++) for (F = a[p], d = 1, A = F.length; d < A; d += 2) c = b.x(F[d],
F[d + 1]), e = b.y(F[d], F[d + 1]), F[d] = c, F[d + 1] = e; return a
            }; b.pick = function () { for (var a, b = 0, c = arguments.length; b < c; b += 1) if ((a = arguments[b]) || !1 === a || 0 === a) return a }; var ra = b._lastArgIfGroup = function (a, c) { var e = a.length - 1, p = a[e]; if (p && p.constructor === b.el.constructor && "group" === p.type) return c && (a[e] = void 0, delete a[e], ba.call(a, e, 1)), p }, Sa = b._serializeArgs = function (a) {
                var c = a[0], e, p; if (b.is(c, "object") && !b.is(c, "array") && "group" !== c.type) for (e = c, c.path && (pathString = c.path) && !b.is(pathString, "string") && !b.is(pathString[0],
$) && (pathString += ""), c = 1, p = arguments.length; c < p; c += 2) e[arguments[c]] || (e[arguments[c]] = arguments[c + 1]); else for (e = {}, c = 1, p = arguments.length; c < p; c += 2) e[arguments[c]] = a[(c - 1) / 2] || arguments[c + 1]; return e
            }, na = b.merge = function (a, b, c, e, p) {
                var d, v, A, F; p ? (e.push(a), p.push(b)) : (e = [a], p = [b]); if (b instanceof Array) for (d = 0; d < b.length; d += 1) {
                    try { v = a[d], A = b[d] } catch (r) { continue } if ("object" !== typeof A) c && void 0 === A || (a[d] = A); else {
                        if (null === v || "object" !== typeof v) v = a[d] = A instanceof Array ? [] : {}; F = checkCyclicRef(A,
p); -1 !== F ? v = a[d] = e[F] : na(v, A, c, e, p)
                    } 
                } else for (d in b) { try { v = a[d], A = b[d] } catch (g) { continue } if (null !== A && "object" === typeof A) if (F = Kb.call(A), "[object Object]" === F) { if (null === v || "object" !== typeof v) v = a[d] = {}; F = checkCyclicRef(A, p); -1 !== F ? v = a[d] = e[F] : na(v, A, c, e, p) } else "[object Array]" === F ? (null !== v && v instanceof Array || (v = a[d] = []), F = checkCyclicRef(A, p), -1 !== F ? v = a[d] = e[F] : na(v, A, c, e, p)) : a[d] = A; else a[d] = A } return a
            }; b.extend = function (a, b, c) {
                if ("object" !== typeof a && "object" !== typeof b) return null; if ("object" !==
typeof b || null === b) return a; "object" !== typeof a && (a = b instanceof Array ? [] : {}); na(a, b, c); return a
            }; var ya = b.is = function (a, b) { b = Fa.call(b); return "finite" == b ? !Fb[m](+a) : b == $ ? a instanceof Array : "object" !== b || void 0 !== a && null !== a ? "null" == b && null === a || b == typeof a && null !== a || "object" == b && a === Object(a) || "array" == b && Array.isArray && Array.isArray(a) || Kb.call(a).slice(8, -1).toLowerCase() == b : !1 }, Da = b.clone = function (a) { if (Object(a) !== a) return a; var b = new a.constructor, c; for (c in a) a[m](c) && (b[c] = Da(a[c])); return b };
            b.createUUID = function (a, b) { return function () { return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(a, b).toUpperCase() } } (/[xy]/g, function (a) { var b = 16 * ga.random() | 0; return ("x" == a ? b : b & 3 | 8).toString(16) }); b._g = da; b.type = ca.ENABLE_RED_CANVAS && (ca.CanvasRenderingContext2D || S.createElement("canvas").getContext) ? "CANVAS" : ca.SVGAngle || S.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML"; if ("VML" == b.type) {
                var Ua = S.createElement("div"), ta; Ua.innerHTML = '<v:shape adj="1"/>';
                ta = Ua.firstChild; ta.style.behavior = "url(#default#VML)"; if (!ta || "object" != typeof ta.adj) return b.type = ""; Ua = null
            } b.svg = !((b.vml = "VML" == b.type) || (b.canvas = "CANVAS" == b.type)); b._Paper = Q; b._id = 0; b._oid = 0; b.angle = function (a, c, e, p, d, v) { return null == d ? (a -= e, c -= p, a || c ? (ga.atan2(-c, -a) * Ya + 540) % 360 : 0) : b.angle(a, c, d, v) - b.angle(e, p, d, v) }; b.rad = function (a) { return a % 360 * qa }; b.deg = function (a) { return a * Ya % 360 }; b.snapTo = function (a, b, c) {
                var e; ya(c, "finite") || (c = 10); if (ya(a, $)) for (e = a.length; e--; ) { if (Ga(a[e] - b) <= c) return a[e] } else {
                    a =
+a; e = b % a; if (e < c) return b - e; if (e > a - c) return b - e + a
                } return b
            }; b.setWindow = function (a) { l("raphael.setWindow", b, da.win, a); ca = da.win = a; S = da.doc = da.win.document; b._engine.initWin && b._engine.initWin(da.win) }; var cc = function (a) {
                if (b.vml) {
                    var c = /^\s+|\s+$/g, e; try { var p = new ActiveXObject("htmlfile"); p.write("<body>"); p.close(); e = p.body } catch (d) { e = createPopup().document.body } var v = e.createTextRange(); cc = Cb(function (a) {
                        try {
                            e.style.color = G(a).replace(c, ""); var b = v.queryCommandValue("ForeColor"); return "#" + ("000000" +
((b & 255) << 16 | b & 65280 | (b & 16711680) >>> 16).toString(16)).slice(-6)
                        } catch (p) { return "none" } 
                    })
                } else { var A = da.doc.createElement("i"); A.title = "RaphaÃ«l Colour Picker"; A.style.display = "none"; da.doc.body.appendChild(A); cc = Cb(function (a) { A.style.color = a; return da.doc.defaultView.getComputedStyle(A, "").getPropertyValue("color") }) } return cc(a)
            }, Va = function () { return "hsb(" + [this.h, this.s, this.b] + ")" }, ib = function () { return "hsl(" + [this.h, this.s, this.l] + ")" }, cb = function () { return this.hex }, kb = function (a, c, e) {
                null == c &&
ya(a, "object") && "r" in a && "g" in a && "b" in a && (e = a.b, c = a.g, a = a.r); null == c && ya(a, "string") && (e = b.getRGB(a), a = e.r, c = e.g, e = e.b); if (1 < a || 1 < c || 1 < e) a /= 255, c /= 255, e /= 255; return [a, c, e]
            }, hc = function (a, c, e, p) { var d = { r: a *= 255, g: c *= 255, b: e *= 255, hex: b.rgb(a, c, e), toString: cb }; ya(p, "finite") && (d.opacity = p); return d }; b.color = function (a) {
                var c; b.is(a, "object") && "h" in a && "s" in a && "b" in a ? (c = b.hsb2rgb(a), a.r = c.r, a.g = c.g, a.b = c.b, a.hex = c.hex) : b.is(a, "object") && "h" in a && "s" in a && "l" in a ? (c = b.hsl2rgb(a), a.r = c.r, a.g = c.g, a.b =
c.b, a.hex = c.hex) : (b.is(a, "string") && (a = b.getRGB(a)), b.is(a, "object") && "r" in a && "g" in a && "b" in a ? (c = b.rgb2hsl(a), a.h = c.h, a.s = c.s, a.l = c.l, c = b.rgb2hsb(a), a.v = c.b) : (a = { hex: "none" }, a.r = a.g = a.b = a.h = a.s = a.v = a.l = -1)); a.toString = cb; return a
            }; b.hsb2rgb = function (a, b, c, e) { this.is(a, "object") && "h" in a && "s" in a && "b" in a && (c = a.b, b = a.s, a = a.h, e = a.o); var p, d, v; a = 360 * a % 360 / 60; v = c * b; b = v * (1 - Ga(a % 2 - 1)); c = p = d = c - v; a = ~ ~a; c += [v, b, 0, 0, b, v][a]; p += [b, v, v, b, 0, 0][a]; d += [0, 0, b, v, v, b][a]; return hc(c, p, d, e) }; b.hsl2rgb = function (a,
b, c, e) { this.is(a, "object") && "h" in a && "s" in a && "l" in a && (c = a.l, b = a.s, a = a.h); if (1 < a || 1 < b || 1 < c) a /= 360, b /= 100, c /= 100; var p, d, v; a = 360 * a % 360 / 60; v = 2 * b * (0.5 > c ? c : 1 - c); b = v * (1 - Ga(a % 2 - 1)); c = p = d = c - v / 2; a = ~ ~a; c += [v, b, 0, 0, b, v][a]; p += [b, v, v, b, 0, 0][a]; d += [0, 0, b, v, v, b][a]; return hc(c, p, d, e) }; b.rgb2hsb = function (a, b, c) { c = kb(a, b, c); a = c[0]; b = c[1]; c = c[2]; var e, p; e = Aa(a, b, c); p = e - za(a, b, c); a = ((0 == p ? 0 : e == a ? (b - c) / p : e == b ? (c - a) / p + 2 : (a - b) / p + 4) + 360) % 6 * 60 / 360; return { h: a, s: 0 == p ? 0 : p / e, b: e, toString: Va} }; b.rgb2hsl = function (a, b, c) {
    c =
kb(a, b, c); a = c[0]; b = c[1]; c = c[2]; var e, p, d; e = Aa(a, b, c); p = za(a, b, c); d = e - p; a = ((0 == d ? 0 : e == a ? (b - c) / d : e == b ? (c - a) / d + 2 : (a - b) / d + 4) + 360) % 6 * 60 / 360; e = (e + p) / 2; return { h: a, s: 0 == d ? 0 : 0.5 > e ? d / (2 * e) : d / (2 - 2 * e), l: e, toString: ib}
}; b._path2string = function () { return this.join(",").replace(db, "$1") }; var Cb = b._cacher = function (a, b, c) {
    function e() {
        var p = V.call(arguments, 0), d = p.join("â€"), v = e.cache = e.cache || {}, A = e.count = e.count || []; if (v[m](d)) {
            a: for (var p = A, A = d, F = 0, r = p.length; F < r; F++) if (p[F] === A) { p.push(p.splice(F, 1)[0]); break a } return c ?
c(v[d]) : v[d]
        } 1E3 <= A.length && delete v[A.shift()]; A.push(d); v[d] = a[z](b, p); return c ? c(v[d]) : v[d]
    } return e
}; b._preload = function (a, b) { var c = S.createElement("img"); c.style.cssText = "position:absolute;left:-9999em;top:-9999em"; c.onload = function () { b.call(this); this.onload = null; S.body.removeChild(this) }; c.onerror = function () { S.body.removeChild(this) }; S.body.appendChild(c); c.src = a }; b.getRGB = Cb(function (a) {
    var c, e, p, d, v; a && ya(a, "object") && "opacity" in a && (c = a.opacity); if (!a || (a = G(a)).indexOf("-") + 1) return { r: -1,
        g: -1, b: -1, hex: "none", error: 1, toString: n
    }; if ("none" == a) return { r: -1, g: -1, b: -1, hex: "none", toString: n }; !q[m](a.toLowerCase().substring(0, 2)) && "#" !== a.charAt() && (a = cc(a)); if (a = a.match(yb)) {
        a[2] && (d = Xa(a[2].substring(5), 16), p = Xa(a[2].substring(3, 5), 16), e = Xa(a[2].substring(1, 3), 16)); a[3] && (d = Xa((v = a[3].charAt(3)) + v, 16), p = Xa((v = a[3].charAt(2)) + v, 16), e = Xa((v = a[3].charAt(1)) + v, 16)); a[4] && (v = a[4][C](hb), e = la(v[0]), "%" == v[0].slice(-1) && (e *= 2.55), p = la(v[1]), "%" == v[1].slice(-1) && (p *= 2.55), d = la(v[2]), "%" == v[2].slice(-1) &&
(d *= 2.55), "rgba" == a[1].toLowerCase().slice(0, 4) && (c = la(v[3])), v[3] && "%" == v[3].slice(-1) && (c /= 100)); if (a[5]) return v = a[5][C](hb), e = la(v[0]), "%" == v[0].slice(-1) && (e *= 2.55), p = la(v[1]), "%" == v[1].slice(-1) && (p *= 2.55), d = la(v[2]), "%" == v[2].slice(-1) && (d *= 2.55), "deg" != v[0].slice(-3) && "Â°" != v[0].slice(-1) || (e /= 360), "hsba" == a[1].toLowerCase().slice(0, 4) && (c = la(v[3])), v[3] && "%" == v[3].slice(-1) && (c /= 100), b.hsb2rgb(e, p, d, c); if (a[6]) return v = a[6][C](hb), e = la(v[0]), "%" == v[0].slice(-1) && (e *= 2.55), p = la(v[1]), "%" ==
v[1].slice(-1) && (p *= 2.55), d = la(v[2]), "%" == v[2].slice(-1) && (d *= 2.55), "deg" != v[0].slice(-3) && "Â°" != v[0].slice(-1) || (e /= 360), "hsla" == a[1].toLowerCase().slice(0, 4) && (c = la(v[3])), v[3] && "%" == v[3].slice(-1) && (c /= 100), b.hsl2rgb(e, p, d, c); a = { r: e, g: p, b: d, toString: n }; a.hex = "#" + (16777216 | d | p << 8 | e << 16).toString(16).slice(1); b.is(c, "finite") && (a.opacity = c); return a
    } return { r: -1, g: -1, b: -1, hex: "none", error: 1, toString: n}
}, b); b.tintshade = Cb(function (a, c) {
    var e = b.getRGB(a), p; p = 255; 0 > c && (c *= -1, p = 0); 1 < c && (c = 1); p = 0 === c ? e :
{ r: p - (p - e.r) * c, g: p - (p - e.g) * c, b: p - (p - e.b) * c, toString: n }; p.hex = b.rgb(p.r, p.g, p.b); e.error && (p.error = e.error); "opacity" in e ? (p.rgba = "rgba(" + [p.r, p.g, p.b, e.opacity].join() + ")", p.opacity = e.opacity) : p.rgba = "rgb(" + [p.r, p.g, p.b].join() + ")"; return p
}, b); b.hsb = Cb(function (a, c, e) { return b.hsb2rgb(a, c, e).hex }); b.hsl = Cb(function (a, c, e) { return b.hsl2rgb(a, c, e).hex }); b.rgb = Cb(function (a, b, c) { return "#" + (16777216 | c | b << 8 | a << 16).toString(16).slice(1) }); b.getColor = function (a) {
    a = this.getColor.start = this.getColor.start ||
{ h: 0, s: 1, b: a || 0.75 }; var b = this.hsb2rgb(a.h, a.s, a.b); a.h += 0.075; 1 < a.h && (a.h = 0, a.s -= 0.2, 0 >= a.s && (this.getColor.start = { h: 0, s: 1, b: a.b })); return b.hex
}; b.getColor.reset = function () { delete this.start }; b.parsePathString = function (a) {
    if (!a) return null; var c = Za(a); if (c.arr) return v(c.arr); var e = { a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0 }, p = []; b.is(a, $) && b.is(a[0], $) && (p = v(a)); p.length || G(a).replace(wb, function (a, b, c) {
        var d = []; a = b.toLowerCase(); c.replace(mb, function (a, b) { b && d.push(+b) }); "m" == a && 2 < d.length &&
(p.push([b][H](d.splice(0, 2))), a = "l", b = "m" == b ? "l" : "L"); if ("r" == a) p.push([b][H](d)); else for (; d.length >= e[a] && (p.push([b][H](d.splice(0, e[a]))), e[a]); );
    }); p.toString = b._path2string; c.arr = v(p); return p
}; b.parseTransformString = Cb(function (a) { if (!a) return null; var c = []; b.is(a, $) && b.is(a[0], $) && (c = v(a)); c.length || G(a).replace(tb, function (a, b, e) { var p = []; Fa.call(b); e.replace(mb, function (a, b) { b && p.push(+b) }); c.push([b][H](p)) }); c.toString = b._path2string; return c }); var Za = function (a) {
    var b = Za.ps = Za.ps || {};
    b[a] ? b[a].sleep = 100 : b[a] = { sleep: 100 }; setTimeout(function () { for (var c in b) b[m](c) && c != a && (b[c].sleep--, !b[c].sleep && delete b[c]) }); return b[a]
}; b.findDotsAtSegment = function (a, b, c, e, p, d, v, A, F) {
    var r = 1 - F, g = X(r, 3), q = X(r, 2), f = F * F, O = f * F, w = g * a + 3 * q * F * c + 3 * r * F * F * p + O * v, g = g * b + 3 * q * F * e + 3 * r * F * F * d + O * A, q = a + 2 * F * (c - a) + f * (p - 2 * c + a), O = b + 2 * F * (e - b) + f * (d - 2 * e + b), R = c + 2 * F * (p - c) + f * (v - 2 * p + c), f = e + 2 * F * (d - e) + f * (A - 2 * d + e); a = r * a + F * c; b = r * b + F * e; p = r * p + F * v; d = r * d + F * A; A = 90 - 180 * ga.atan2(q - R, O - f) / Ca; (q > R || O < f) && (A += 180); return { x: w, y: g, m: { x: q,
        y: O
    }, n: { x: R, y: f }, start: { x: a, y: b }, end: { x: p, y: d }, alpha: A
    }
}; b.bezierBBox = function (a, c, e, p, d, v, A, F) { b.is(a, "array") || (a = [a, c, e, p, d, v, A, F]); a = vc.apply(null, a); return { x: a.min.x, y: a.min.y, x2: a.max.x, y2: a.max.y, width: a.max.x - a.min.x, height: a.max.y - a.min.y} }; b.isPointInsideBBox = function (a, b, c) { return b >= a.x && b <= a.x2 && c >= a.y && c <= a.y2 }; b.isBBoxIntersect = function (a, c) {
    var e = b.isPointInsideBBox; return e(c, a.x, a.y) || e(c, a.x2, a.y) || e(c, a.x, a.y2) || e(c, a.x2, a.y2) || e(a, c.x, c.y) || e(a, c.x2, c.y) || e(a, c.x, c.y2) || e(a, c.x2,
c.y2) || (a.x < c.x2 && a.x > c.x || c.x < a.x2 && c.x > a.x) && (a.y < c.y2 && a.y > c.y || c.y < a.y2 && c.y > a.y)
}; b.pathIntersection = function (a, b) { return B(a, b) }; b.pathIntersectionNumber = function (a, b) { return B(a, b, 1) }; b.isPointInsidePath = function (a, c, e) { var p = b.pathBBox(a); return b.isPointInsideBBox(p, c, e) && (1 == B(a, [["M", c, e], ["H", p.x2 + 10]], 1) % 2 || 1 == B(a, [["M", c, e], ["V", p.y2 + 10]], 1) % 2) }; b._removedFactory = function (a) { return function () { l("raphael.log", null, "RaphaÃ«l: you are calling to method â€œ" + a + "â€ of removed object", a) } }; var p =
b.pathBBox = function (a) { var b = Za(a); if (b.bbox) return b.bbox; if (!a) return { x: 0, y: 0, width: 0, height: 0, x2: 0, y2: 0 }; a = mc(a); for (var c = 0, e = 0, p = [], d = [], v, A = 0, F = a.length; A < F; A++) v = a[A], "M" == v[0] ? (c = v[1], e = v[2], p.push(c), d.push(e)) : (c = vc(c, e, v[1], v[2], v[3], v[4], v[5], v[6]), p = p[H](c.min.x, c.max.x), d = d[H](c.min.y, c.max.y), c = v[5], e = v[6]); a = za[z](0, p); v = za[z](0, d); p = Aa[z](0, p); d = Aa[z](0, d); d = { x: a, y: v, x2: p, y2: d, width: p - a, height: d - v }; b.bbox = Da(d); return d }, v = function (a) { a = Da(a); a.toString = b._path2string; return a }, A =
b._pathToRelative = function (a) {
    var c = Za(a); if (c.rel) return v(c.rel); b.is(a, $) && b.is(a && a[0], $) || (a = b.parsePathString(a)); var e = [], p = 0, d = 0, A = 0, F = 0, r = 0; "M" == a[0][0] && (p = a[0][1], d = a[0][2], A = p, F = d, r++, e.push(["M", p, d])); for (var g = a.length; r < g; r++) {
        var q = e[r] = [], f = a[r]; if (f[0] != Fa.call(f[0])) switch (q[0] = Fa.call(f[0]), q[0]) {
            case "a": q[1] = f[1]; q[2] = f[2]; q[3] = f[3]; q[4] = f[4]; q[5] = f[5]; q[6] = +(f[6] - p).toFixed(3); q[7] = +(f[7] - d).toFixed(3); break; case "v": q[1] = +(f[1] - d).toFixed(3); break; case "m": A = f[1], F = f[2]; default: for (var O =
1, w = f.length; O < w; O++) q[O] = +(f[O] - (O % 2 ? p : d)).toFixed(3)
        } else for (e[r] = [], "m" == f[0] && (A = f[1] + p, F = f[2] + d), q = 0, O = f.length; q < O; q++) e[r][q] = f[q]; f = e[r].length; switch (e[r][0]) { case "z": p = A; d = F; break; case "h": p += +e[r][f - 1]; break; case "v": d += +e[r][f - 1]; break; default: p += +e[r][f - 2], d += +e[r][f - 1] } 
    } e.toString = b._path2string; c.rel = v(e); return e
}, F = b._pathToAbsolute = function (a) {
    var e = Za(a), p; if (e.abs) return v(e.abs); b.is(a, $) && b.is(a && a[0], $) || (a = b.parsePathString(a)); if (!a || !a.length) return p = ["M", 0, 0], p.toString =
b._path2string, p; var d = 0, A = 0, F = 0, r = 0, q = 0; p = []; "M" == a[0][0] && (d = +a[0][1], A = +a[0][2], F = d, r = A, q++, p[0] = ["M", d, A]); for (var g = 3 == a.length && "M" == a[0][0] && "R" == a[1][0].toUpperCase() && "Z" == a[2][0].toUpperCase(), f, O = q, w = a.length; O < w; O++) {
        p.push(q = []); f = a[O]; if (f[0] != Pa.call(f[0])) switch (q[0] = Pa.call(f[0]), q[0]) {
            case "A": q[1] = f[1]; q[2] = f[2]; q[3] = f[3]; q[4] = f[4]; q[5] = f[5]; q[6] = +(f[6] + d); q[7] = +(f[7] + A); break; case "V": q[1] = +f[1] + A; break; case "H": q[1] = +f[1] + d; break; case "R": for (var R = [d, A][H](f.slice(1)), h = 2, k =
R.length; h < k; h++) R[h] = +R[h] + d, R[++h] = +R[h] + A; p.pop(); p = p[H](c(R, g)); break; case "M": F = +f[1] + d, r = +f[2] + A; default: for (h = 1, k = f.length; h < k; h++) q[h] = +f[h] + (h % 2 ? d : A)
        } else if ("R" == f[0]) R = [d, A][H](f.slice(1)), p.pop(), p = p[H](c(R, g)), q = ["R"][H](f.slice(-2)); else for (R = 0, h = f.length; R < h; R++) q[R] = f[R]; switch (q[0]) { case "Z": d = F; A = r; break; case "H": d = q[1]; break; case "V": A = q[1]; break; case "M": F = q[q.length - 2], r = q[q.length - 1]; default: d = q[q.length - 2], A = q[q.length - 1] } 
    } p.toString = b._path2string; e.abs = v(p); return p
}, e = function (a,
b, c, e) { return [a, b, c, e, c, e] }, Z = function (a, b, c, e, p, d) { var v = 1 / 3, A = 2 / 3; return [v * a + A * c, v * b + A * e, v * p + A * c, v * d + A * e, p, d] }, O = function (a, b, c, e, p, d, v, A, F, r) {
    var q = 120 * Ca / 180, g = qa * (+p || 0), f = [], w, R = Cb(function (a, b, c) { var e = a * ma(c) - b * Ba(c); a = a * Ba(c) + b * ma(c); return { x: e, y: a} }); if (r) I = r[0], w = r[1], d = r[2], h = r[3]; else {
        w = R(a, b, -g); a = w.x; b = w.y; w = R(A, F, -g); A = w.x; F = w.y; ma(qa * p); Ba(qa * p); w = (a - A) / 2; I = (b - F) / 2; h = w * w / (c * c) + I * I / (e * e); 1 < h && (h = W(h), c *= h, e *= h); var h = c * c, k = e * e, h = (d == v ? -1 : 1) * W(Ga((h * k - h * I * I - k * w * w) / (h * I * I + k * w * w))); d =
h * c * I / e + (a + A) / 2; var h = h * -e * w / c + (b + F) / 2, I = ga.asin(((b - h) / e).toFixed(9)); w = ga.asin(((F - h) / e).toFixed(9)); I = a < d ? Ca - I : I; w = A < d ? Ca - w : w; 0 > I && (I = 2 * Ca + I); 0 > w && (w = 2 * Ca + w); v && I > w && (I -= 2 * Ca); !v && w > I && (w -= 2 * Ca)
    } if (Ga(w - I) > q) { var f = w, k = A, z = F; w = I + q * (v && w > I ? 1 : -1); A = d + c * ma(w); F = h + e * Ba(w); f = O(A, F, c, e, p, 0, v, k, z, [w, f, d, h]) } d = w - I; p = ma(I); q = Ba(I); v = ma(w); w = Ba(w); d = ga.tan(d / 4); c = 4 / 3 * c * d; d *= 4 / 3 * e; e = [a, b]; a = [a + c * q, b - d * p]; b = [A + c * w, F - d * v]; A = [A, F]; a[0] = 2 * e[0] - a[0]; a[1] = 2 * e[1] - a[1]; if (r) return [a, b, A][H](f); f = [a, b, A][H](f).join()[C](",");
    r = []; A = 0; for (F = f.length; A < F; A++) r[A] = A % 2 ? R(f[A - 1], f[A], g).y : R(f[A], f[A + 1], g).x; return r
}, R = function (a, b, c, e, p, d, v, A, F) { var r = 1 - F; return { x: X(r, 3) * a + 3 * X(r, 2) * F * c + 3 * r * F * F * p + X(F, 3) * v, y: X(r, 3) * b + 3 * X(r, 2) * F * e + 3 * r * F * F * d + X(F, 3) * A} }, vc = Cb(function (a, b, c, e, p, d, v, A) {
    var F = p - 2 * c + a - (v - 2 * p + c), r = 2 * (c - a) - 2 * (p - c), q = a - c, f = (-r + W(r * r - 4 * F * q)) / 2 / F, F = (-r - W(r * r - 4 * F * q)) / 2 / F, g = [b, A], w = [a, v]; "1e12" < Ga(f) && (f = 0.5); "1e12" < Ga(F) && (F = 0.5); 0 < f && 1 > f && (f = R(a, b, c, e, p, d, v, A, f), w.push(f.x), g.push(f.y)); 0 < F && 1 > F && (f = R(a, b, c, e, p, d, v, A,
F), w.push(f.x), g.push(f.y)); F = d - 2 * e + b - (A - 2 * d + e); r = 2 * (e - b) - 2 * (d - e); q = b - e; f = (-r + W(r * r - 4 * F * q)) / 2 / F; F = (-r - W(r * r - 4 * F * q)) / 2 / F; "1e12" < Ga(f) && (f = 0.5); "1e12" < Ga(F) && (F = 0.5); 0 < f && 1 > f && (f = R(a, b, c, e, p, d, v, A, f), w.push(f.x), g.push(f.y)); 0 < F && 1 > F && (f = R(a, b, c, e, p, d, v, A, F), w.push(f.x), g.push(f.y)); return { min: { x: za[z](0, w), y: za[z](0, g) }, max: { x: Aa[z](0, w), y: Aa[z](0, g)}}
}), mc = b._path2curve = Cb(function (a, b) {
    var c = !b && Za(a); if (!b && c.curve) return v(c.curve); var p = F(a), d = b && F(b), A = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null },
r = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null }, q = function (a, b) {
    var c, p; if (!a) return ["C", b.x, b.y, b.x, b.y, b.x, b.y]; a[0] in { T: 1, Q: 1} || (b.qx = b.qy = null); switch (a[0]) {
        case "M": b.X = a[1]; b.Y = a[2]; break; case "A": a = ["C"][H](O[z](0, [b.x, b.y][H](a.slice(1)))); break; case "S": c = b.x + (b.x - (b.bx || b.x)); p = b.y + (b.y - (b.by || b.y)); a = ["C", c, p][H](a.slice(1)); break; case "T": b.qx = b.x + (b.x - (b.qx || b.x)); b.qy = b.y + (b.y - (b.qy || b.y)); a = ["C"][H](Z(b.x, b.y, b.qx, b.qy, a[1], a[2])); break; case "Q": b.qx = a[1]; b.qy = a[2]; a = ["C"][H](Z(b.x, b.y,
a[1], a[2], a[3], a[4])); break; case "L": a = ["C"][H](e(b.x, b.y, a[1], a[2])); break; case "H": a = ["C"][H](e(b.x, b.y, a[1], b.y)); break; case "V": a = ["C"][H](e(b.x, b.y, b.x, a[1])); break; case "Z": a = ["C"][H](e(b.x, b.y, b.X, b.Y))
    } return a
}, f = function (a, b) { if (7 < a[b].length) { a[b].shift(); for (var c = a[b]; c.length; ) a.splice(b++, 0, ["C"][H](c.splice(0, 6))); a.splice(b, 1); R = Aa(p.length, d && d.length || 0) } }, g = function (a, b, c, e, v) {
    a && b && "M" == a[v][0] && "M" != b[v][0] && (b.splice(v, 0, ["M", e.x, e.y]), c.bx = 0, c.by = 0, c.x = a[v][1], c.y = a[v][2],
R = Aa(p.length, d && d.length || 0))
}, w = 0, R = Aa(p.length, d && d.length || 0); for (; w < R; w++) { p[w] = q(p[w], A); f(p, w); d && (d[w] = q(d[w], r)); d && f(d, w); g(p, d, A, r, w); g(d, p, r, A, w); var h = p[w], I = d && d[w], k = h.length, D = d && I.length; A.x = h[k - 2]; A.y = h[k - 1]; A.bx = la(h[k - 4]) || A.x; A.by = la(h[k - 3]) || A.y; r.bx = d && (la(I[D - 4]) || r.x); r.by = d && (la(I[D - 3]) || r.y); r.x = d && I[D - 2]; r.y = d && I[D - 1] } d || (c.curve = v(p)); return d ? [p, d] : p
}, null, v); b._parseDots = Cb(function (a) {
    for (var c = [], e = 0, p = a.length; e < p; e++) {
        var d = {}, v = a[e].match(/^([^:]*):?([\d\.]*)/);
        d.color = b.getRGB(v[1]); if (d.color.error) return null; d.opacity = d.color.opacity; d.color = d.color.hex; v[2] && (d.offset = v[2] + "%"); c.push(d)
    } e = 1; for (p = c.length - 1; e < p; e++) if (!c[e].offset) { a = la(c[e - 1].offset || 0); v = 0; for (d = e + 1; d < p; d++) if (c[d].offset) { v = c[d].offset; break } v || (v = 100, d = p); v = la(v); for (v = (v - a) / (d - e + 1); e < d; e++) a += v, c[e].offset = a + "%" } return c
}); var Sb = b._tear = function (a, b) { a == b.top && (b.top = a.prev); a == b.bottom && (b.bottom = a.next); a.next && (a.next.prev = a.prev); a.prev && (a.prev.next = a.next) }; b._tofront =
function (a, b) { if (b.top === a) return !1; Sb(a, b); a.next = null; a.prev = b.top; b.top.next = a; b.top = a; return !0 }; b._toback = function (a, b) { if (b.bottom === a) return !1; Sb(a, b); a.next = b.bottom; a.prev = null; b.bottom.prev = a; b.bottom = a; return !0 }; b._insertafter = function (a, b, c, e) { Sb(a, c); a.parent = e; b === e.top && (e.top = a); b.next && (b.next.prev = a); a.next = b.next; a.prev = b; b.next = a }; b._insertbefore = function (a, b, c, e) { Sb(a, c); a.parent = e; b === e.bottom && (e.bottom = a); b.prev && (b.prev.next = a); a.prev = b.prev; b.prev = a; a.next = b }; var Ac = b.toMatrix =
function (a, b) { var c = p(a), e = { _: { transform: "" }, getBBox: function () { return c } }; Wc(e, b); return e.matrix }; b.transformPath = function (a, b) { return Ka(a, Ac(a, b)) }; var Wc = b._extractTransform = function (a, c) {
    if (null == c) return a._.transform; c = G(c).replace(/\.{3}|\u2026/g, a._.transform || ""); var e = b.parseTransformString(c), p = 0, d = 0, v = 0, A = 1, F = 1, r = a._, v = new N; r.transform = e || []; if (e) for (var d = 0, q = e.length; d < q; d++) {
        var f = e[d], g = f.length, w = G(f[0]).toLowerCase(), O = f[0] != w, R = O ? v.invert() : 0, h; "t" == w && 3 == g ? O ? (g = R.x(0, 0), w = R.y(0,
0), O = R.x(f[1], f[2]), R = R.y(f[1], f[2]), v.translate(O - g, R - w)) : v.translate(f[1], f[2]) : "r" == w ? 2 == g ? (h = h || a.getBBox(1), v.rotate(f[1], h.x + h.width / 2, h.y + h.height / 2), p += f[1]) : 4 == g && (O ? (O = R.x(f[2], f[3]), R = R.y(f[2], f[3]), v.rotate(f[1], O, R)) : v.rotate(f[1], f[2], f[3]), p += f[1]) : "s" == w ? 2 == g || 3 == g ? (h = h || a.getBBox(1), v.scale(f[1], f[g - 1], h.x + h.width / 2, h.y + h.height / 2), A *= f[1], F *= f[g - 1]) : 5 == g && (O ? (O = R.x(f[3], f[4]), R = R.y(f[3], f[4]), v.scale(f[1], f[2], O, R)) : v.scale(f[1], f[2], f[3], f[4]), A *= f[1], F *= f[2]) : "m" == w && 7 == g && v.add(f[1],
f[2], f[3], f[4], f[5], f[6]); r.dirtyT = 1; a.matrix = v
    } a.matrix = v; r.sx = A; r.sy = F; r.deg = p; r.dx = d = v.e; r.dy = v = v.f; 1 == A && 1 == F && !p && r.bbox ? (r.bbox.x += +d, r.bbox.y += +v) : r.dirtyT = 1
}, Ea = function (a) { var b = a[0]; switch (b.toLowerCase()) { case "t": return [b, 0, 0]; case "m": return [b, 1, 0, 0, 1, 0, 0]; case "r": return 4 == a.length ? [b, 0, a[2], a[3]] : [b, 0]; case "s": return 5 == a.length ? [b, 1, 1, a[3], a[4]] : 3 == a.length ? [b, 1, 1] : [b, 1] } }, oc = b._equaliseTransform = function (a, c) {
    c = G(c).replace(/\.{3}|\u2026/g, a); a = b.parseTransformString(a) || []; c = b.parseTransformString(c) ||
[]; for (var e = Aa(a.length, c.length), p = [], d = [], v = 0, A, F, r, f; v < e; v++) { r = a[v] || Ea(c[v]); f = c[v] || Ea(r); if (r[0] != f[0] || "r" == r[0].toLowerCase() && (r[2] != f[2] || r[3] != f[3]) || "s" == r[0].toLowerCase() && (r[3] != f[3] || r[4] != f[4])) return; p[v] = []; d[v] = []; A = 0; for (F = Aa(r.length, f.length); A < F; A++) A in r && (p[v][A] = r[A]), A in f && (d[v][A] = f[A]) } return { from: p, to: d}
}; b._getContainer = function (a, c, e, p) {
    var d; d = null != p || b.is(a, "object") ? a : da.doc.getElementById(a); if (null != d) return d.tagName ? null == c ? { container: d, width: d.style.pixelWidth ||
d.offsetWidth, height: d.style.pixelHeight || d.offsetHeight
    } : { container: d, width: c, height: e} : { container: 1, x: a, y: c, width: e, height: p}
}; b.pathToRelative = A; b._engine = {}; b.path2curve = mc; b.matrix = function (a, b, c, e, p, d) { return new N(a, b, c, e, p, d) }; (function (a) {
    function c(a) { return a[0] * a[0] + a[1] * a[1] } function e(a) { var b = W(c(a)); a[0] && (a[0] /= b); a[1] && (a[1] /= b) } a.add = function (a, b, c, e, p, d) {
        var v = [[], [], []], A = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]]; b = [[a, c, p], [b, e, d], [0, 0, 1]]; a && a instanceof N && (b =
[[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]]); for (a = 0; 3 > a; a++) for (c = 0; 3 > c; c++) { for (e = p = 0; 3 > e; e++) p += A[a][e] * b[e][c]; v[a][c] = p } this.a = v[0][0]; this.b = v[1][0]; this.c = v[0][1]; this.d = v[1][1]; this.e = v[0][2]; this.f = v[1][2]
    }; a.invert = function () { var a = this.a * this.d - this.b * this.c; return new N(this.d / a, -this.b / a, -this.c / a, this.a / a, (this.c * this.f - this.d * this.e) / a, (this.b * this.e - this.a * this.f) / a) }; a.clone = function () { return new N(this.a, this.b, this.c, this.d, this.e, this.f) }; a.translate = function (a, b) {
        this.add(1, 0, 0, 1, a,
b)
    }; a.scale = function (a, b, c, e) { null == b && (b = a); (c || e) && this.add(1, 0, 0, 1, c, e); this.add(a, 0, 0, b, 0, 0); (c || e) && this.add(1, 0, 0, 1, -c, -e) }; a.rotate = function (a, c, e) { a = b.rad(a); c = c || 0; e = e || 0; var p = +ma(a).toFixed(9); a = +Ba(a).toFixed(9); this.add(p, a, -a, p, c, e); this.add(1, 0, 0, 1, -c, -e) }; a.x = function (a, b) { return a * this.a + b * this.c + this.e }; a.y = function (a, b) { return a * this.b + b * this.d + this.f }; a.get = function (a) { return +this[G.fromCharCode(97 + a)].toFixed(4) }; a.toString = function () {
        return b.svg ? "matrix(" + [this.get(0), this.get(1),
this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")" : [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join()
    }; a.toMatrixString = function () { return "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")" }; a.toFilter = function () { return "progid:DXImageTransform.Microsoft.Matrix(M11=" + this.get(0) + ", M12=" + this.get(2) + ", M21=" + this.get(1) + ", M22=" + this.get(3) + ", Dx=" + this.get(4) + ", Dy=" + this.get(5) + ", sizingmethod='auto expand')" }; a.offset = function () {
        return [this.e.toFixed(4),
this.f.toFixed(4)]
    }; a.split = function () {
        var a = {}; a.dx = this.e; a.dy = this.f; var p = [[this.a, this.c], [this.b, this.d]]; a.scalex = W(c(p[0])); e(p[0]); a.shear = p[0][0] * p[1][0] + p[0][1] * p[1][1]; p[1] = [p[1][0] - p[0][0] * a.shear, p[1][1] - p[0][1] * a.shear]; a.scaley = W(c(p[1])); e(p[1]); a.shear /= a.scaley; var d = -p[0][1], p = p[1][1]; 0 > p ? (a.rotate = b.deg(ga.acos(p)), 0 > d && (a.rotate = 360 - a.rotate)) : a.rotate = b.deg(ga.asin(d)); a.isSimple = ! +a.shear.toFixed(9) && (a.scalex.toFixed(9) == a.scaley.toFixed(9) || !a.rotate); a.isSuperSimple = ! +a.shear.toFixed(9) &&
a.scalex.toFixed(9) == a.scaley.toFixed(9) && !a.rotate; a.noRotation = ! +a.shear.toFixed(9) && !a.rotate; return a
    }; a.toTransformString = function (a) { a = a || this[C](); return a.isSimple ? (a.scalex = +a.scalex.toFixed(4), a.scaley = +a.scaley.toFixed(4), a.rotate = +a.rotate.toFixed(4), (a.dx || a.dy ? "t" + [a.dx, a.dy] : "") + (1 != a.scalex || 1 != a.scaley ? "s" + [a.scalex, a.scaley, 0, 0] : "") + (a.rotate ? "r" + [a.rotate, 0, 0] : "")) : "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)] } 
})(N.prototype); var fb = navigator.userAgent.match(/Version\/(.*?)\s/) ||
navigator.userAgent.match(/Chrome\/(\d+)/); "Apple Computer, Inc." == navigator.vendor && (fb && 4 > fb[1] || "iP" == navigator.platform.slice(0, 2)) || "Google Inc." == navigator.vendor && fb && 8 > fb[1] ? K.safari = function () { var a = this.rect(-99, -99, this.width + 99, this.height + 99).attr({ stroke: "none" }); setTimeout(function () { a.remove() }); return !0 } : K.safari = T; for (var bd = function () { this.returnValue = !1 }, cd = function () { return this.originalEvent.preventDefault() }, dd = function () { this.cancelBubble = !0 }, Zb = function () { return this.originalEvent.stopPropagation() },
Oc = b.addEvent = function () {
    if (da.doc.addEventListener) return function (a, b, c, e) {
        var p = ha && I[b] ? I[b] : b, d = function (p) { var d = da.doc.documentElement.scrollTop || da.doc.body.scrollTop, v = da.doc.documentElement.scrollLeft || da.doc.body.scrollLeft; if (ha && I[m](b)) for (var A = 0, F = p.targetTouches && p.targetTouches.length; A < F; A++) if (p.targetTouches[A].target == a) { F = p; p = p.targetTouches[A]; p.originalEvent = F; p.preventDefault = cd; p.stopPropagation = Zb; break } return c.call(e, p, p.clientX + v, p.clientY + d) }; a.addEventListener(p, d,
!1); return function () { a.removeEventListener(p, d, !1); return !0 } 
    }; if (da.doc.attachEvent) return function (a, b, c, e) { var p = function (a) { a = a || da.win.event; var b = a.clientX + (da.doc.documentElement.scrollLeft || da.doc.body.scrollLeft), p = a.clientY + (da.doc.documentElement.scrollTop || da.doc.body.scrollTop); a.preventDefault = a.preventDefault || bd; a.stopPropagation = a.stopPropagation || dd; return c.call(e, a, b, p) }; a.attachEvent("on" + b, p); return function () { a.detachEvent("on" + b, p); return !0 } } 
} (), wc = [], Y = function (a) {
    for (var c =
a.clientX, e = a.clientY, p = da.doc.documentElement.scrollTop || da.doc.body.scrollTop, d = da.doc.documentElement.scrollLeft || da.doc.body.scrollLeft, v, A = wc.length; A--; ) {
        v = wc[A]; if (ha) for (var F = a.touches.length, r; F--; ) { if (r = a.touches[F], r.identifier == v.el._drag.id) { c = r.clientX; e = r.clientY; (a.originalEvent ? a.originalEvent : a).preventDefault(); break } } else a.preventDefault(); if (!v.el.removed) {
            var F = b._engine.getNode(v.el), f = F.nextSibling, q = F.parentNode, g = F.style.display; da.win.opera && q.removeChild(F); F.style.display =
"none"; r = v.el.paper.getElementByPoint(c, e); F.style.display = g; da.win.opera && (f ? q.insertBefore(F, f) : q.appendChild(F)); r && l("raphael.drag.over." + v.el.id, v.el, r); c += d; e += p; l("raphael.drag.move." + v.el.id, v.move_scope || v.el, c - v.el._drag.x, e - v.el._drag.y, c, e, a)
        } 
    } 
}, Pc = function (a) { b.unmousemove(Y).unmouseup(Pc); for (var c = wc.length, e; c--; ) e = wc[c], e.el._drag = {}, l("raphael.drag.end." + e.el.id, e.end_scope || e.start_scope || e.move_scope || e.el, a); wc = [] }, ea = b.el = {}, Xc = ja.length; Xc--; ) (function (a) {
    b[a] = ea[a] = function (c,
e) { b.is(c, "function") && (this.events = this.events || [], this.events.push({ name: a, f: c, unbind: Oc(this.shape || this.node || da.doc, a, c, e || this) })); return this }; b["un" + a] = ea["un" + a] = function (b) { for (var c = this.events || [], e = c.length; e--; ) if (c[e].name == a && c[e].f == b) { c[e].unbind(); c.splice(e, 1); !c.length && delete this.events; break } return this } 
})(ja[Xc]); ea.data = function (a, c) {
    var e = L[this.id] = L[this.id] || {}; if (1 == arguments.length) {
        if (b.is(a, "object")) { for (var p in a) a[m](p) && this.data(p, a[p]); return this } l("raphael.data.get." +
this.id, this, e[a], a); return e[a]
    } e[a] = c; l("raphael.data.set." + this.id, this, c, a); return this
}; ea.removeData = function (a) { null == a ? delete L[this.id] : L[this.id] && delete L[this.id][a]; return this }; ea.getData = function () { return Da(L[this.id] || {}) }; var Bc = [], Jc = function () { this.untrack = Oc(da.doc, "mouseup", ed, this) }, ed = function () { this.untrack(); this.untrack = null; return this.fn && this.fn.apply(this.scope || this.el, arguments) }; ea.mouseup = function (a, c, e) {
    if (!e) return b.mouseup.apply(this, arguments); Bc.push(e = { el: this,
        fn: a, scope: c
    }); e.unbind = Oc(this.shape || this.node || da.doc, "mousedown", Jc, e); return this
}; ea.unmouseup = function (a) { for (var c = Bc.length, e; c--; ) Bc[c].el === this && Bc[c].fn === a && (e = Bc[c], e.unbind(), e.untrack && e.untrack(), Bc.splice(c, 1)); return e ? this : b.unmouseup.apply(this, arguments) }; ea.hover = function (a, b, c, e) { return this.mouseover(a, c).mouseout(b, e || c) }; ea.unhover = function (a, b) { return this.unmouseover(a).unmouseout(b) }; var jc = []; ea.drag = function (a, c, e, p, d, v) {
    function A(F) {
        (F.originalEvent || F).preventDefault();
        var r = da.doc.documentElement.scrollTop || da.doc.body.scrollTop, f = da.doc.documentElement.scrollLeft || da.doc.body.scrollLeft; this._drag.x = F.clientX + f; this._drag.y = F.clientY + r; this._drag.id = F.identifier; !wc.length && b.mousemove(Y).mouseup(Pc); wc.push({ el: this, move_scope: p, start_scope: d, end_scope: v }); c && l.on("raphael.drag.start." + this.id, c); a && l.on("raphael.drag.move." + this.id, a); e && l.on("raphael.drag.end." + this.id, e); l("raphael.drag.start." + this.id, d || p || this, F.clientX + f, F.clientY + r, F)
    } this._drag = {}; jc.push({ el: this,
        start: A
    }); this.mousedown(A); return this
}; ea.onDragOver = function (a) { a ? l.on("raphael.drag.over." + this.id, a) : l.unbind("raphael.drag.over." + this.id) }; ea.undrag = function () { for (var a = jc.length; a--; ) jc[a].el == this && (this.unmousedown(jc[a].start), jc.splice(a, 1), l.unbind("raphael.drag.*." + this.id)); !jc.length && b.unmousemove(Y).unmouseup(Pc); delete this._drag }; ea.follow = function (a, c, e) {
    if (a.removed || a.constructor !== b.el.constructor) return this; a.followers.push({ el: this, stalk: e = { before: "insertBefore", after: "insertAfter"}[e],
        cb: c
    }); e && this[e](a); return this
}; ea.unfollow = function (a) { if (a.removed || a.constructor !== b.el.constructor) return this; for (var c = 0, e = a.followers.length; c < e; c++) if (a.followers[c].el === this) { a.followers.splice(c, 1); break } return this }; K.hide = function () { this.canvas.style.visibility = "hidden"; return this }; K.show = function () { this.canvas.style.visibility = ""; return this }; K.group = function () {
    var a = arguments, c = ra(a, !0), a = b._engine.group(this, a[0], c); return this.__set__ && this.__set__.push(a), this._elementsById[a.id] =
a
}; K.circle = function () { var a = arguments, c = ra(a, !0), a = Sa(a, "cx", 0, "cy", 0, "r", 0, "fill", "none", "stroke", "#000"), c = b._engine.circle(this, a, c); return this.__set__ && this.__set__.push(c), this._elementsById[c.id] = c }; K.rect = function () { var a = arguments, c = ra(a, !0), a = Sa(a, "x", 0, "y", 0, "width", 0, "height", 0, "r", 0, "fill", "none", "stroke", "#000"), c = b._engine.rect(this, a, c); return this.__set__ && this.__set__.push(c), this._elementsById[c.id] = c }; K.ellipse = function () {
    var a = arguments, c = ra(a, !0), a = Sa(a, "x", 0, "y", 0, "rx", 0, "ry",
0, "fill", "none", "stroke", "#000"), c = b._engine.ellipse(this, a, c); return this.__set__ && this.__set__.push(c), this._elementsById[c.id] = c
}; K.path = function () { var a = arguments, c = ra(a, !0), a = Sa(a, "path", "", "fill", "none", "stroke", "#000"), c = b._engine.path(this, a, c); return this.__set__ && this.__set__.push(c), this._elementsById[c.id] = c }; K.image = function () {
    var a = arguments, c = ra(a, !0), a = Sa(a, "src", "about:blank", "x", 0, "y", 0, "width", 0, "height", 0); out = b._engine.image(this, a, c); return this.__set__ && this.__set__.push(out),
this._elementsById[out.id] = out
}; K.text = function () { var a = arguments, c = ra(a, !0), a = Sa(a, "x", 0, "y", 0, "text", "", "stroke", "none", "fill", "#000", "text-anchor", "middle", "vertical-align", "middle"), c = b._engine.text(this, a, c); return this.__set__ && this.__set__.push(c), this._elementsById[c.id] = c }; K.set = function (a) { !b.is(a, "array") && (a = ba.call(arguments, 0, arguments.length)); var c = new rc(a); this.__set__ && this.__set__.push(c); return c }; K.setStart = function (a) { this.__set__ = a || this.set() }; K.setFinish = function (a) {
    a = this.__set__;
    delete this.__set__; return a
}; K.setSize = function (a, c) { return b._engine.setSize.call(this, a, c) }; K.setViewBox = function (a, c, e, p, d) { return b._engine.setViewBox.call(this, a, c, e, p, d) }; K.top = K.bottom = null; K.raphael = b; K.getElementByPoint = function (a, b) {
    var c, e, p = this.canvas, d = da.doc.elementFromPoint(a, b); if (da.win.opera && "svg" == d.tagName) {
        e = p.getBoundingClientRect(); c = p.ownerDocument; var v = c.body, A = c.documentElement; c = e.top + (da.win.pageYOffset || A.scrollTop || v.scrollTop) - (A.clientTop || v.clientTop || 0); e = e.left +
(da.win.pageXOffset || A.scrollLeft || v.scrollLeft) - (A.clientLeft || v.clientLeft || 0); v = p.createSVGRect(); v.x = a - e; v.y = b - c; v.width = v.height = 1; c = p.getIntersectionList(v, null); c.length && (d = c[c.length - 1])
    } if (!d) return null; for (; d.parentNode && d != p.parentNode && !d.raphael; ) d = d.parentNode; d == this.canvas.parentNode && (d = p); return d = d && d.raphael ? this.getById(d.raphaelid) : null
}; K.getElementsByBBox = function (a) { var c = this.set(); this.forEach(function (e) { b.isBBoxIntersect(e.getBBox(), a) && c.push(e) }); return c }; K.getById =
function (a) { return this._elementsById[a] || null }; K.forEach = function (a, b) { for (var c = this.bottom; c && !1 !== a.call(b, c); ) c = c.next; return this }; K.getElementsByPoint = function (a, b) { var c = this.set(); this.forEach(function (e) { e.isPointInside(a, b) && c.push(e) }); return c }; ea.isPointInside = function (a, c) { var e = this.realPath = this.realPath || va[this.type](this), p; return b.isPointInsidePath((p = this.attr("transform")) && p.length && b.transformPath(e, p) || e, a, c) }; ea.getBBox = function (a) {
    if (this.removed) return {}; var b = this._;
    if (a) { if (b.dirty || !b.bboxwt) this.realPath = va[this.type](this), b.bboxwt = p(this.realPath), b.bboxwt.toString = t, b.dirty = 0; return b.bboxwt } if (b.dirty || b.dirtyT || !b.bbox) { if (b.dirty || !this.realPath) b.bboxwt = 0, this.realPath = va[this.type](this); b.bbox = p(Ka(this.realPath, this.matrix)); b.bbox.toString = t; b.dirty = b.dirtyT = 0 } return b.bbox
}; ea.clone = function () { if (this.removed) return null; var a = this.paper[this.type]().attr(this.attr()); this.__set__ && this.__set__.push(a); return a }; ea.glow = function (a) {
    if ("text" ==
this.type) return null; a = a || {}; var b = (a.width || 10) + (+this.attr("stroke-width") || 1), c = a.fill || !1, e = a.opacity || 0.5, p = a.offsetx || 0, d = a.offsety || 0; a = a.color || "#000"; for (var v = b / 2, A = this.paper, F = A.set(), r = this.realPath || va[this.type](this), r = this.matrix ? Ka(r, this.matrix) : r, f = 1; f < v + 1; f++) F.push(A.path(r).attr({ stroke: a, fill: c ? a : "none", "stroke-linejoin": "round", "stroke-linecap": "round", "stroke-width": +(b / v * f).toFixed(3), opacity: +(e / v).toFixed(3) })); return F.insertBefore(this).translate(p, d)
}; var Cc = function (c,
e, p, d, v, A, F, r, f) { return null == f ? J(c, e, p, d, v, A, F, r) : b.findDotsAtSegment(c, e, p, d, v, A, F, r, a(c, e, p, d, v, A, F, r, f)) }, Ra = function (a, c) {
    return function (e, p, d) {
        e = mc(e); for (var v, A, F, r, f = "", q = {}, g = 0, w = 0, O = e.length; w < O; w++) {
            F = e[w]; if ("M" == F[0]) v = +F[1], A = +F[2]; else {
                r = Cc(v, A, F[1], F[2], F[3], F[4], F[5], F[6]); if (g + r > p) {
                    if (c && !q.start) {
                        v = Cc(v, A, F[1], F[2], F[3], F[4], F[5], F[6], p - g); f += ["C" + v.start.x, v.start.y, v.m.x, v.m.y, v.x, v.y]; if (d) return f; q.start = f; f = ["M" + v.x, v.y + "C" + v.n.x, v.n.y, v.end.x, v.end.y, F[5], F[6]].join();
                        g += r; v = +F[5]; A = +F[6]; continue
                    } if (!a && !c) return v = Cc(v, A, F[1], F[2], F[3], F[4], F[5], F[6], p - g), { x: v.x, y: v.y, alpha: v.alpha}
                } g += r; v = +F[5]; A = +F[6]
            } f += F.shift() + F
        } q.end = f; v = a ? g : c ? q : b.findDotsAtSegment(v, A, F[0], F[1], F[2], F[3], F[4], F[5], 1); v.alpha && (v = { x: v.x, y: v.y, alpha: v.alpha }); return v
    } 
}, gb = Ra(1), Yc = Ra(), Qc = Ra(0, 1); b.getTotalLength = gb; b.getPointAtLength = Yc; b.getSubpath = function (a, b, c) { if (1E-6 > this.getTotalLength(a) - c) return Qc(a, b).end; a = Qc(a, c, 1); return b ? Qc(a, b).end : a }; ea.getTotalLength = function () {
    if ("path" ==
this.type) return this.node.getTotalLength ? this.node.getTotalLength() : gb(this.attrs.path)
}; ea.getPointAtLength = function (a) { if ("path" == this.type) return Yc(this.attrs.path, a) }; ea.getSubpath = function (a, c) { if ("path" == this.type) return b.getSubpath(this.attrs.path, a, c) }; var ob = b.easing_formulas = { linear: function (a) { return a }, "<": function (a) { return X(a, 1.7) }, ">": function (a) { return X(a, 0.48) }, "<>": function (a) {
    var b = 0.48 - a / 1.04, c = W(0.1734 + b * b); a = c - b; a = X(Ga(a), 1 / 3) * (0 > a ? -1 : 1); b = -c - b; b = X(Ga(b), 1 / 3) * (0 > b ? -1 : 1);
    a = a + b + 0.5; return 3 * (1 - a) * a * a + a * a * a
}, backIn: function (a) { return a * a * (2.70158 * a - 1.70158) }, backOut: function (a) { a -= 1; return a * a * (2.70158 * a + 1.70158) + 1 }, elastic: function (a) { return a == !!a ? a : X(2, -10 * a) * Ba(2 * (a - 0.075) * Ca / 0.3) + 1 }, bounce: function (a) { a < 1 / 2.75 ? a *= 7.5625 * a : a < 2 / 2.75 ? (a -= 1.5 / 2.75, a = 7.5625 * a * a + 0.75) : a < 2.5 / 2.75 ? (a -= 2.25 / 2.75, a = 7.5625 * a * a + 0.9375) : (a -= 2.625 / 2.75, a = 7.5625 * a * a + 0.984375); return a } 
}; ob.easeIn = ob["ease-in"] = ob["<"]; ob.easeOut = ob["ease-out"] = ob[">"]; ob.easeInOut = ob["ease-in-out"] = ob["<>"];
            ob["back-in"] = ob.backIn; ob["back-out"] = ob.backOut; var Ma = [], Qa = d.requestAnimationFrame || d.webkitRequestAnimationFrame || d.mozRequestAnimationFrame || d.oRequestAnimationFrame || d.msRequestAnimationFrame || function (a) { setTimeout(a, 16) }, pc = function () {
                for (var a = +new Date, c = 0; c < Ma.length; c++) {
                    var e = Ma[c]; if (!e.el.removed && !e.paused) {
                        var p = a - e.start, d = e.ms, v = e.easing, A = e.from, F = e.diff, q = e.to, g = e.el, w = {}, O, R = {}, h; e.initstatus ? (p = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * d, e.status = e.initstatus, delete e.initstatus,
e.stop && Ma.splice(c--, 1)) : e.status = (e.prev + p / d * (e.percent - e.prev)) / e.anim.top; if (!(0 > p)) if (p < d) {
                            var I = v(p / d), k; for (k in A) if (A[m](k)) {
                                switch (r[k]) {
                                    case M: O = +A[k] + I * d * F[k]; break; case "colour": O = "rgb(" + [Rc(fa(A[k].r + I * d * F[k].r)), Rc(fa(A[k].g + I * d * F[k].g)), Rc(fa(A[k].b + I * d * F[k].b))].join() + ")"; break; case "path": O = []; p = 0; for (v = A[k].length; p < v; p++) { O[p] = [A[k][p][0]]; q = 1; for (R = A[k][p].length; q < R; q++) O[p][q] = (+A[k][p][q] + I * d * F[k][p][q]).toFixed(4); O[p] = O[p].join(sa) } O = O.join(sa); break; case "transform": if (F[k].real) for (O =
[], p = 0, v = A[k].length; p < v; p++) for (O[p] = [A[k][p][0]], q = 1, R = A[k][p].length; q < R; q++) O[p][q] = A[k][p][q] + I * d * F[k][p][q]; else O = function (a) { return +A[k][a] + I * d * F[k][a] }, O = [["m", O(0), O(1), O(2), O(3), O(4), O(5)]]; break; case "csv": if ("clip-rect" == k) for (O = [], p = 4; p--; ) O[p] = +A[k][p] + I * d * F[k][p]; break; default: for (v = [][H](A[k]), O = [], p = g.ca[k].length; p--; ) O[p] = +v[p] + I * d * F[k][p]
                                } w[k] = O
                            } g.attr(w); (function (a, b, c) { setTimeout(function () { l("raphael.anim.frame." + a, b, c) }) })(g.id, g, e.anim)
                        } else {
                            (function (a, c, e) {
                                setTimeout(function () {
                                    l("raphael.anim.frame." +
c.id, c, e); l("raphael.anim.finish." + c.id, c, e); b.is(a, "function") && a.call(c)
                                })
                            })(e.callback, g, e.anim); g.attr(q); Ma.splice(c--, 1); if (1 < e.repeat && !e.next) { for (h in q) q[m](h) && (R[h] = e.totalOrigin[h]); e.el.attr(R); f(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1) } e.next && !e.stop && f(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat)
                        } 
                    } 
                } b.svg && g && g.paper && g.paper.safari(); Ma.length && Qa(pc)
            }, Rc = function (a) { return 255 < a ? 255 : 0 > a ? 0 : a }; ea.animateWith = function (a, c, e, p, d, v) {
                if (this.removed) return v && v.call(this),
this; e = e instanceof k ? e : b.animation(e, p, d, v); f(e, this, e.percents[0], null, this.attr()); e = 0; for (p = Ma.length; e < p; e++) if (Ma[e].anim == c && Ma[e].el == a) { Ma[p - 1].start = Ma[e].start; break } return this
            }; ea.onAnimation = function (a) { a ? l.on("raphael.anim.frame." + this.id, a) : l.unbind("raphael.anim.frame." + this.id); return this }; k.prototype.delay = function (a) { var b = new k(this.anim, this.ms); b.times = this.times; b.del = +a || 0; return b }; k.prototype.repeat = function (a) {
                var b = new k(this.anim, this.ms); b.del = this.del; b.times = ga.floor(Aa(a,
0)) || 1; return b
            }; b.animation = function (a, c, e, p) { if (a instanceof k) return a; if (b.is(e, "function") || !e) p = p || e || null, e = null; a = Object(a); c = +c || 0; var d = {}, v, A; for (A in a) a[m](A) && la(A) != A && la(A) + "%" != A && (v = !0, d[A] = a[A]); return v ? (e && (d.easing = e), p && (d.callback = p), new k({ 100: d }, c)) : new k(a, c) }; ea.animate = function (a, c, e, p) { if (this.removed) return p && p.call(this), this; a = a instanceof k ? a : b.animation(a, c, e, p); f(a, this, a.percents[0], null, this.attr()); return this }; ea.setTime = function (a, b) {
                a && null != b && this.status(a,
za(b, a.ms) / a.ms); return this
            }; ea.status = function (a, b) { var c = [], e = 0, p, d; if (null != b) return f(a, this, -1, za(b, 1)), this; for (p = Ma.length; e < p; e++) if (d = Ma[e], d.el.id == this.id && (!a || d.anim == a)) { if (a) return d.status; c.push({ anim: d.anim, status: d.status }) } return a ? 0 : c }; ea.pause = function (a) { for (var b = 0; b < Ma.length; b++) Ma[b].el.id != this.id || a && Ma[b].anim != a || !1 === l("raphael.anim.pause." + this.id, this, Ma[b].anim) || (Ma[b].paused = !0); return this }; ea.resume = function (a) {
                for (var b = 0; b < Ma.length; b++) if (Ma[b].el.id == this.id &&
(!a || Ma[b].anim == a)) { var c = Ma[b]; !1 !== l("raphael.anim.resume." + this.id, this, c.anim) && (delete c.paused, this.status(c.anim, c.status)) } return this
            }; ea.stop = function (a) { for (var b = 0; b < Ma.length; b++) Ma[b].el.id != this.id || a && Ma[b].anim != a || !1 !== l("raphael.anim.stop." + this.id, this, Ma[b].anim) && Ma.splice(b--, 1); return this }; l.on("raphael.remove", h); l.on("raphael.clear", h); ea.toString = function () { return "RaphaÃ«lâ€™s object" }; ea.toFront = function () {
                if (this.removed) return this; var a = b._engine.getNode(this), c = this.parent,
e = this.followers, p; b._tofront(this, c) && c.canvas.appendChild(a); a = 0; for (c = e.length; a < c; a++) (p = e[a]).stalk && p.el[p.stalk](this); return this
            }; ea.toBack = function () { if (this.removed) return this; var a = b._engine.getNode(this), c = this.parent, e = this.followers, p; b._toback(this, c) && c.canvas.insertBefore(a, c.canvas.firstChild); a = 0; for (c = e.length; a < c; a++) (p = e[a]).stalk && p.el[p.stalk](this); return this }; ea.insertAfter = function (a) {
                if (this.removed) return this; var c = b._engine.getNode(this), e = b._engine.getLastNode(a),
p = a.parent.canvas, d = this.followers, v; e.nextSibling ? p.insertBefore(c, e.nextSibling) : p.appendChild(c); b._insertafter(this, a, this.parent, a.parent); c = 0; for (e = d.length; c < e; c++) (v = d[c]).stalk && v.el[v.stalk](a); return this
            }; ea.insertBefore = function (a) {
                if (this.removed) return this; var c = b._engine.getNode(this), e = b._engine.getNode(a), p = this.followers, d; a.parent.canvas.insertBefore(c, e); b._insertbefore(this, a, this.parent, a.parent); this.parent = a.parent; c = 0; for (e = p.length; c < e; c++) (d = p[c]).stalk && d.el[d.stalk](a);
                return this
            }; ea.appendChild = function (a) { if (this.removed || "group" !== this.type) return this; var c = this.followers, e, p, d; if (a.parent === this) return a.toFront(), this; p = b._engine.getNode(a); b._tear(a, a.parent); this.canvas.appendChild(p); a.parent = this; !this.bottom && (this.bottom = a); a.prev = this.top; a.next = null; this.top && (this.top.next = a); this.top = a; p = 0; for (d = c.length; p < d; p++) (e = c[p]).stalk && e.el[e.stalk](a); return this }; ea.removeChild = function (a) {
                if (this.removed || "group" !== this.type || a.parent !== this) return this;
                var c = b._engine.getNode(a), e = this.paper; b._tear(a, this); e.canvas.appendChild(c); this.parent = e; !e.bottom && (e.bottom = this); (this.prev = e.top) && (e.top.next = this); e.top = this; this.next = null; return this
            }; var rc = function (a) { this.items = []; this.length = 0; this.type = "set"; if (a) for (var b = 0, c = a.length; b < c; b++) !a[b] || a[b].constructor != ea.constructor && a[b].constructor != rc || (this[this.items.length] = this.items[this.items.length] = a[b], this.length++) }, sb = rc.prototype; sb.push = function () {
                for (var a, b, c = 0, e = arguments.length; c <
e; c++) !(a = arguments[c]) || a.constructor != ea.constructor && a.constructor != rc || (b = this.items.length, this[b] = this.items[b] = a, this.length++); return this
            }; sb.pop = function () { this.length && delete this[this.length--]; return this.items.pop() }; sb.forEach = function (a, b) { for (var c = 0, e = this.items.length; c < e && !1 !== a.call(b, this.items[c], c); c++); return this }; for (var Wa in ea) ea[m](Wa) && (sb[Wa] = function (a) { return function () { var b = arguments; return this.forEach(function (c) { c[a][z](c, b) }) } } (Wa)); sb.attr = function (a, c) {
                if (a &&
b.is(a, $) && b.is(a[0], "object")) for (var e = 0, p = a.length; e < p; e++) this.items[e].attr(a[e]); else for (e = 0, p = this.items.length; e < p; e++) this.items[e].attr(a, c); return this
            }; sb.clear = function () { for (; this.length; ) this.pop() }; sb.splice = function (a, b, c) {
                a = 0 > a ? Aa(this.length + a, 0) : a; b = Aa(0, za(this.length - a, isNaN(b) && this.length || b)); var e = [], p = [], d = [], v; for (v = 2; v < arguments.length; v++) d.push(arguments[v]); for (v = 0; v < b; v++) p.push(this[a + v]); for (; v < this.length - a; v++) e.push(this[a + v]); var A = d.length; for (v = 0; v < A + e.length; v++) this.items[a +
v] = this[a + v] = v < A ? d[v] : e[v - A]; for (v = this.items.length = this.length -= b - A; this[v]; ) delete this[v++]; return new rc(p)
            }; sb.exclude = function (a) { for (var b = 0, c = this.length; b < c; b++) if (this[b] == a) return this.splice(b, 1), !0 }; sb.animate = function (a, c, e, p) {
                !b.is(e, "function") && e || (p = e || null); var d = this.items.length, v = d, A = this, F; if (!d) return this; p && (F = function () { ! --d && p.call(A) }); e = b.is(e, "string") ? e : F; c = b.animation(a, c, e, F); for (a = this.items[--v].animate(c); v--; ) this.items[v] && !this.items[v].removed && this.items[v].animateWith(a,
c, c); return this
            }; sb.insertAfter = function (a) { for (var b = this.items.length; b--; ) this.items[b].insertAfter(a); return this }; sb.getBBox = function () { for (var a = [], b = [], c = [], e = [], p = this.items.length; p--; ) if (!this.items[p].removed) { var d = this.items[p].getBBox(); a.push(d.x); b.push(d.y); c.push(d.x + d.width); e.push(d.y + d.height) } a = za[z](0, a); b = za[z](0, b); c = Aa[z](0, c); e = Aa[z](0, e); return { x: a, y: b, x2: c, y2: e, width: c - a, height: e - b} }; sb.clone = function (a) {
                a = new rc; for (var b = 0, c = this.items.length; b < c; b++) a.push(this.items[b].clone());
                return a
            }; sb.toString = function () { return "RaphaÃ«lâ€˜s set" }; sb.glow = function (a) { var b = this.paper.set(); this.forEach(function (c, e) { var p = c.glow(a); null != p && p.forEach(function (a, c) { b.push(a) }) }); return b }; b.registerFont = function (a) {
                if (!a.face) return a; this.fonts = this.fonts || {}; var b = { w: a.w, face: {}, glyphs: {} }, c = a.face["font-family"], e; for (e in a.face) a.face[m](e) && (b.face[e] = a.face[e]); this.fonts[c] ? this.fonts[c].push(b) : this.fonts[c] = [b]; if (!a.svg) {
                    b.face["units-per-em"] = Xa(a.face["units-per-em"], 10); for (var p in a.glyphs) if (a.glyphs[m](p) &&
(c = a.glyphs[p], b.glyphs[p] = { w: c.w, k: {}, d: c.d && "M" + c.d.replace(/[mlcxtrv]/g, function (a) { return { l: "L", c: "C", x: "z", t: "m", r: "l", v: "c"}[a] || "M" }) + "z" }, c.k)) for (var d in c.k) c[m](d) && (b.glyphs[p].k[d] = c.k[d])
                } return a
            }; K.getFont = function (a, c, e, p) {
                p = p || "normal"; e = e || "normal"; c = +c || { normal: 400, bold: 700, lighter: 300, bolder: 800}[c] || 400; if (b.fonts) {
                    var d = b.fonts[a]; if (!d) { a = new RegExp("(^|\\s)" + a.replace(/[^\w\d\s+!~.:_-]/g, "") + "(\\s|$)", "i"); for (var v in b.fonts) if (b.fonts[m](v) && a.test(v)) { d = b.fonts[v]; break } } var A;
                    if (d) for (v = 0, a = d.length; v < a && (A = d[v], A.face["font-weight"] != c || A.face["font-style"] != e && A.face["font-style"] || A.face["font-stretch"] != p); v++); return A
                } 
            }; K.print = function (a, c, e, p, d, v, A) {
                v = v || "middle"; A = Aa(za(A || 0, 1), -1); var F = G(e)[C](""), r = 0, f = 0, q = ""; b.is(p, e) && (p = this.getFont(p)); if (p) {
                    e = (d || 16) / p.face["units-per-em"]; var g = p.face.bbox[C](Na); d = +g[0]; var w = g[3] - g[1], O = 0; v = +g[1] + ("baseline" == v ? w + +p.face.descent : w / 2); for (var g = 0, R = F.length; g < R; g++) {
                        if ("\n" == F[g]) f = k = r = 0, O += w; else var h = f && p.glyphs[F[g -
1]] || {}, k = p.glyphs[F[g]], r = r + (f ? (h.w || p.w) + (h.k && h.k[F[g]] || 0) + p.w * A : 0), f = 1; k && k.d && (q += b.transformPath(k.d, ["t", r * e, O * e, "s", e, e, d, v, "t", (a - d) / e, (c - v) / e]))
                    } 
                } return this.path(q).attr({ fill: "#000", stroke: "none" })
            }; K.add = function (a) { if (b.is(a, "array")) for (var c = this.set(), e = 0, p = a.length, d; e < p; e++) d = a[e] || {}, aa[m](d.type) && c.push(this[d.type]().attr(d)); return c }; b.format = function (a, c) {
                var e = b.is(c, $) ? [0][H](c) : arguments; a && b.is(a, "string") && e.length - 1 && (a = a.replace(qb, function (a, b) {
                    return null == e[++b] ?
"" : e[b]
                })); return a || ""
            }; b.fullfill = function () { var a = /\{([^\}]+)\}/g, b = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, c = function (a, c, e) { var p = e; c.replace(b, function (a, b, c, e, d) { b = b || e; p && (b in p && (p = p[b]), "function" == typeof p && d && (p = p())) }); return p = (null == p || p == e ? a : p) + "" }; return function (b, e) { return String(b).replace(a, function (a, b) { return c(a, b, e) }) } } (); b.ninja = function () { xa ? da.win.Raphael = ua : delete Raphael; return b }; var Kc = b.vml && 0.5 || 0; b.crispBound = Cb(function (a, b, c, e, p) {
                var d = {}, v;
                a = a || 0; b = b || 0; c = c || 0; e = e || 0; p = p || 0; v = p % 2 / 2 + Kc; d.x = fa(a + v) - v; d.y = fa(b + v) - v; d.width = fa(a + c + v) - v - d.x; d.height = fa(b + e + v) - v - d.y; d["stroke-width"] = p; 0 === d.width && 0 !== c && (d.width = 1); 0 === d.height && 0 !== e && (d.height = 1); return d
            }, b); ea.crisp = function () { var a = this.attrs, c, e = this.attr(["x", "y", "width", "height", "stroke-width"]), e = b.crispBound(e.x, e.y, e.width, e.height, e["stroke-width"]); for (c in e) a[c] === e[c] && delete e[c]; return this.attr(e) }; b.st = sb; b.define = function (a, c, e, p, d, v) {
                var A; if (b.is(a, $)) for (v = 0, A = a.length; v <
A; v++) b.define(a[v]); else if (b.is(a, "object")) b.define(a.name, a[a.name], a.ca, a.fn, a.e, a.data); else if (a && !b.fn[a]) return b.fn[a] = function () { var v = arguments, A = c.apply(this, v), F; if (p && b.is(p, "object")) for (F in p) A[F] = p[F]; if (d && b.is(d, "object")) for (F in d) A[F] && A[F](d[F]); if (e) { if (b.is(e, "function")) A.ca[a] = e; else for (F in e) A.ca[F] = e[F]; A.ca[a] && (b._lastArgIfGroup(v, !0), A.attr(a, V.call(v))) } return A }, e && (b.fn[a].ca = e), p && (b.fn[a].fn = p), d && (b.fn[a].e = d), v && (b.fn[a].data = v), b.fn[a]
            }; (function (a, c, e) {
                function p() {
                    /in/.test(a.readyState) ?
setTimeout(p, 9) : b.eve("raphael.DOMload")
                } null == a.readyState && a.addEventListener && (a.addEventListener(c, e = function () { a.removeEventListener(c, e, !1); a.readyState = "complete" }, !1), a.readyState = "loading"); p()
            })(document, "DOMContentLoaded"); l.on("raphael.DOMload", function () { s = !0 }); (function () {
                if (b.svg) {
                    var a = String, c = parseFloat, e = parseInt, p = Math, d = p.max, v = p.abs, A = p.pow, F = p.sqrt, r = /[, ]+/, f = !(!/AppleWebKit/.test(b._g.win.navigator.userAgent) || /Chrome/.test(b._g.win.navigator.userAgent) && !(29 > b._g.win.navigator.appVersion.match(/Chrome\/(\d+)\./)[1])),
q = b.eve, g = { block: "M5,0 0,2.5 5,5z", classic: "M5,0 0,2.5 5,5 3.5,3 3.5,2z", diamond: "M2.5,0 5,2.5 2.5,5 0,2.5z", open: "M6,1 1,3.5 6,6", oval: "M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z" }, w = {}; b.toString = function () { return "Your browser supports SVG.\nYou are running RaphaÃ«l " + this.version }; b._url = ""; var O = function (a, b) { var c = a.gradient; if (c) { if (c === b) return; c.refCount--; c.refCount || c.parentNode.removeChild(c); delete a.gradient } b && (a.gradient = b, b.refCount++) }, R = b._createNode = function (c, e) {
    if (e) {
        "string" ==
typeof c && (c = R(c)); for (var p in e) e.hasOwnProperty(p) && ("xlink:" == p.substring(0, 6) ? c.setAttributeNS("http://www.w3.org/1999/xlink", p.substring(6), a(e[p])) : c.setAttribute(p, a(e[p])))
    } else c = b._g.doc.createElementNS("http://www.w3.org/2000/svg", c); return c
}, h = { userSpaceOnUse: "userSpaceOnUse", objectBoundingBox: "objectBoundingBox" }, k = { pad: "pad", redlect: "reflect", repeat: "repeat" }, I = function (e, r) {
    if (!e.paper || !e.paper.defs) return 0; var f = "linear", q = e.paper, g = (q.id + "-" + r).replace(/[\(\)\s,\xb0#]/g, "_"),
w = 0.5, I = 0.5, D, z, Z, s, G, K = e.node, L = K.style, l = b._g.doc.getElementById(g); if (!l) {
        r = a(r).replace(b._radial_gradient, function (a, b) {
            f = "radial"; b = b && b.split(",") || []; s = b[5]; G = b[6]; var e = b[0], p = b[1], d = b[2], v = b[3], r = b[4], q = e && p, g; d && (D = /\%/.test(d) ? d : c(d)); if (s === h.userSpaceOnUse) return q && (w = e, I = p), v && r && (z = v, Z = r, q || (w = z, I = Z)), ""; q && (w = c(e), I = c(p), e = 2 * (0.5 < I) - 1, 0.25 < (g = A(w - 0.5, 2)) + A(I - 0.5, 2) && 0.25 > g && (I = F(0.25 - g) * e + 0.5) && 0.5 !== I && (I = I.toFixed(5) - 1E-5 * e)); v && r && (z = c(v), Z = c(r), e = 2 * (0.5 < Z) - 1, 0.25 < (g = A(z - 0.5,
2)) + A(Z - 0.5, 2) && 0.25 > g && (Z = F(0.25 - g) * e + 0.5) && 0.5 !== Z && (Z = Z.toFixed(5) - 1E-5 * e), q || (w = z, I = Z)); return ""
        }); r = r.split(/\s*\-\s*/); if ("linear" == f) {
            var l = r.shift(), m = l.match(/\((.*)\)/), Q, m = m && m[1] && m[1].split(/\s*\,\s*/), l = -c(l); if (isNaN(l)) return null; m && m.length ? (m[0] in h ? (s = m.shift(), m[0] in k && (G = m.shift())) : (m[4] && (s = m[4]), m[5] && (G = m[5])), Q = [m[0] || "0%", m[1] || "0%", m[2] || "100%", m[3] || "0%"]) : (Q = [0, 0, p.cos(b.rad(l)), p.sin(b.rad(l))], l = 1 / (d(v(Q[2]), v(Q[3])) || 1), Q[2] *= l, Q[3] *= l, 0 > Q[2] && (Q[0] = -Q[2], Q[2] = 0),
0 > Q[3] && (Q[1] = -Q[3], Q[3] = 0))
        } m = b._parseDots(r); if (!m) return null; l = R(f + "Gradient", { id: g }); l.refCount = 0; s in h && l.setAttribute("gradientUnits", a(s)); G in k && l.setAttribute("spreadMethod", a(G)); "radial" === f ? (void 0 !== D && l.setAttribute("r", a(D)), void 0 !== z && void 0 !== Z && (l.setAttribute("cx", a(z)), l.setAttribute("cy", a(Z))), l.setAttribute("fx", a(w)), l.setAttribute("fy", a(I))) : R(l, { x1: Q[0], y1: Q[1], x2: Q[2], y2: Q[3] }); Q = 0; for (var Ea = m.length; Q < Ea; Q++) l.appendChild(R("stop", { offset: m[Q].offset ? m[Q].offset :
Q ? "100%" : "0%", "stop-color": m[Q].color || "#fff", "stop-opacity": void 0 === m[Q].opacity ? 1 : m[Q].opacity
        })); q.defs.appendChild(l)
    } O(e, l); R(K, { fill: "url('" + b._url + "#" + g + "')", opacity: 1, "fill-opacity": 1 }); L.fill = ""; L.opacity = 1; return L.fillOpacity = 1
}, z = function (a) { var b = a.getBBox(1); R(a.pattern, { patternTransform: a.matrix.invert() + " translate(" + b.x + "," + b.y + ")" }) }, D = function (c, e, p) {
    if ("path" == c.type) {
        for (var d = a(e).toLowerCase().split("-"), v = c.paper, A = p ? "end" : "start", F = c.node, r = c.attrs, f = r["stroke-width"], q =
d.length, O = "classic", h, k, I = 3, z = 3, D = 5; q--; ) switch (d[q]) { case "block": case "classic": case "oval": case "diamond": case "open": case "none": O = d[q]; break; case "wide": z = 5; break; case "narrow": z = 2; break; case "long": I = 5; break; case "short": I = 2 } "open" == O ? (I += 2, z += 2, D += 2, h = 1, k = p ? 4 : 1, d = { fill: "none", stroke: r.stroke }) : (k = h = I / 2, d = { fill: r.stroke, stroke: "none" }); c._.arrows ? p ? (c._.arrows.endPath && w[c._.arrows.endPath]--, c._.arrows.endMarker && w[c._.arrows.endMarker]--) : (c._.arrows.startPath && w[c._.arrows.startPath]--,
c._.arrows.startMarker && w[c._.arrows.startMarker]--) : c._.arrows = {}; if ("none" != O) {
            var q = "raphael-marker-" + O, Z = "raphael-marker-" + A + O + I + z + "-obj" + c.id; b._g.doc.getElementById(q) ? w[q]++ : (v.defs.appendChild(R(R("path"), { "stroke-linecap": "round", d: g[O], id: q })), w[q] = 1); var s = b._g.doc.getElementById(Z); s ? (w[Z]++, I = s.getElementsByTagName("use")[0]) : (s = R(R("marker"), { id: Z, markerHeight: z, markerWidth: I, orient: "auto", refX: k, refY: z / 2 }), I = R(R("use"), { "xlink:href": "#" + q, transform: (p ? "rotate(180 " + I / 2 + " " + z / 2 + ") " :
"") + "scale(" + I / D + "," + z / D + ")", "stroke-width": (1 / ((I / D + z / D) / 2)).toFixed(4)
            }), s.appendChild(I), v.defs.appendChild(s), w[Z] = 1); R(I, d); v = h * ("diamond" != O && "oval" != O); p ? (p = c._.arrows.startdx * f || 0, f = b.getTotalLength(r.path) - v * f) : (p = v * f, f = b.getTotalLength(r.path) - (c._.arrows.enddx * f || 0)); d = {}; d["marker-" + A] = "url('" + b._url + "#" + Z + "')"; if (f || p) d.d = Raphael.getSubpath(r.path, p, f); R(F, d); c._.arrows[A + "Path"] = q; c._.arrows[A + "Marker"] = Z; c._.arrows[A + "dx"] = v; c._.arrows[A + "Type"] = O; c._.arrows[A + "String"] = e
        } else p ? (p =
c._.arrows.startdx * f || 0, f = b.getTotalLength(r.path) - p) : (p = 0, f = b.getTotalLength(r.path) - (c._.arrows.enddx * f || 0)), c._.arrows[A + "Path"] && R(F, { d: Raphael.getSubpath(r.path, p, f) }), delete c._.arrows[A + "Path"], delete c._.arrows[A + "Marker"], delete c._.arrows[A + "dx"], delete c._.arrows[A + "Type"], delete c._.arrows[A + "String"]; for (d in w) w.hasOwnProperty(d) && !w[d] && (c = b._g.doc.getElementById(d)) && c.parentNode.removeChild(c)
    } 
}, Z = { "": [0], none: [0], "-": [3, 1], ".": [1, 1], "-.": [3, 1, 1, 1], "-..": [3, 1, 1, 1, 1, 1], ". ": [1, 3],
    "- ": [4, 3], "--": [8, 3], "- .": [4, 3, 1, 3], "--.": [8, 3, 1, 3], "--..": [8, 3, 1, 3, 1, 3]
}, s = function (c, e, p) { var d = Z[a(e).toLowerCase()]; if (e = d || void 0 !== e && [].concat(e)) { var v = c.attrs["stroke-width"] || "1"; p = { round: v, square: v, butt: 0}[c.attrs["stroke-linecap"] || p["stroke-linecap"]] || 0; var A, F = A = e.length; if (d) for (; A--; ) e[A] = e[A] * v + (A % 2 ? 1 : -1) * p; else for (A = 0; A < F; A += 2) e[A] -= p, e[A + 1] && (e[A + 1] += p), 0 >= e[A] && (e[A] = 0.1); b.is(e, "array") && R(c.node, { "stroke-dasharray": e.join(",") }) } }, G = function (a, b) {
    for (var c in a.ca) b.hasOwnProperty(c) &&
a.attr(c, b[c])
}, K = b._setFillAndStroke = function (c, p) {
    if (c.paper.canvas) {
        var A = c.node, F = c.attrs, q = c.paper, g = A.style, w = g.visibility; g.visibility = "hidden"; for (var h in p) if (p.hasOwnProperty(h) && b._availableAttrs.hasOwnProperty(h)) {
            var k = p[h]; F[h] = k; switch (h) {
                case "blur": c.blur(k); break; case "href": case "title": case "target": var Z = A.parentNode; if ("a" != Z.tagName.toLowerCase()) { if ("" == k) break; var G = R("a"); G.raphael = !0; G.raphaelid = A.raphaelid; Z.insertBefore(G, A); G.appendChild(A); Z = G } "target" == h ? Z.setAttributeNS("http://www.w3.org/1999/xlink",
"show", "blank" == k ? "new" : k) : Z.setAttributeNS("http://www.w3.org/1999/xlink", h, k); A.titleNode = Z; break; case "cursor": g.cursor = k; break; case "transform": c.transform(k); break; case "rotation": b.is(k, "array") ? c.rotate.apply(c, k) : c.rotate(k); break; case "arrow-start": D(c, k); break; case "arrow-end": D(c, k, 1); break; case "clip-path": var l = !0; case "clip-rect": Z = !l && a(k).split(r); c._.clipispath = !!l; if (l || 4 == Z.length) {
                        c.clip && c.clip.parentNode.parentNode.removeChild(c.clip.parentNode); var G = R("clipPath"), Q = R(l ? "path" :
"rect"); G.id = b.createUUID(); R(Q, l ? { d: k ? F["clip-path"] = b._pathToAbsolute(k) : b._availableAttrs.path, fill: "none"} : { x: Z[0], y: Z[1], width: Z[2], height: Z[3], transform: c.matrix.invert() }); G.appendChild(Q); q.defs.appendChild(G); R(A, { "clip-path": "url('" + b._url + "#" + G.id + "')" }); c.clip = Q
                    } !k && (k = A.getAttribute("clip-path")) && ((k = b._g.doc.getElementById(k.replace(/(^url\(#|\)$)/g, ""))) && k.parentNode.removeChild(k), R(A, { "clip-path": "" }), delete c.clip); break; case "path": "path" == c.type && (R(A, { d: k ? F.path = b._pathToAbsolute(k) :
b._availableAttrs.path
                    }), c._.dirty = 1, c._.arrows && ("startString" in c._.arrows && D(c, c._.arrows.startString), "endString" in c._.arrows && D(c, c._.arrows.endString, 1))); break; case "width": if (A.setAttribute(h, k), c._.dirty = 1, F.fx) h = "x", k = F.x; else break; case "x": F.fx && (k = -F.x - (F.width || 0)); case "rx": if ("rx" == h && "rect" == c.type) break; case "cx": A.setAttribute(h, k); c.pattern && z(c); c._.dirty = 1; break; case "height": if (A.setAttribute(h, k), c._.dirty = 1, F.fy) h = "y", k = F.y; else break; case "y": F.fy && (k = -F.y - (F.height || 0));
                case "ry": if ("ry" == h && "rect" == c.type) break; case "cy": A.setAttribute(h, k); c.pattern && z(c); c._.dirty = 1; break; case "r": "rect" == c.type ? R(A, { rx: k, ry: k }) : A.setAttribute(h, k); c._.dirty = 1; break; case "src": "image" == c.type && A.setAttributeNS("http://www.w3.org/1999/xlink", "href", k); break; case "stroke-width": if (1 != c._.sx || 1 != c._.sy) k /= d(v(c._.sx), v(c._.sy)) || 1; q._vbSize && (k *= q._vbSize); f && 0 === k && (k = 1E-6); A.setAttribute(h, k); F["stroke-dasharray"] && s(c, F["stroke-dasharray"], p); c._.arrows && ("startString" in c._.arrows &&
D(c, c._.arrows.startString), "endString" in c._.arrows && D(c, c._.arrows.endString, 1)); break; case "stroke-dasharray": s(c, k, p); break; case "fill": var K = a(k).match(b._ISURL); if (K) {
                        var G = R("pattern"), L = R("image"); G.id = b.createUUID(); R(G, { x: 0, y: 0, patternUnits: "userSpaceOnUse", height: 1, width: 1 }); R(L, { x: 0, y: 0, "xlink:href": K[1] }); G.appendChild(L); (function (a) { b._preload(K[1], function () { var b = this.offsetWidth, c = this.offsetHeight; R(a, { width: b, height: c }); R(L, { width: b, height: c }); q.safari() }) })(G); q.defs.appendChild(G);
                        g.fill = "url('" + b._url + "#" + G.id + "')"; R(A, { fill: g.fill }); c.pattern = G; c.pattern && z(c); break
                    } Z = b.getRGB(k); if (!Z.error) delete p.gradient, delete F.gradient, !b.is(F.opacity, "undefined") && b.is(p.opacity, "undefined") && R(A, { opacity: F.opacity }), !b.is(F["fill-opacity"], "undefined") && b.is(p["fill-opacity"], "undefined") && R(A, { "fill-opacity": F["fill-opacity"] }), c.gradient && O(c); else if (("circle" == c.type || "ellipse" == c.type || "r" != a(k).charAt()) && I(c, k)) {
                        if ("opacity" in F || "fill-opacity" in F) if (Z = b._g.doc.getElementById(A.getAttribute("fill").replace(/^url\(#|\)$/g,
""))) Z = Z.getElementsByTagName("stop"), R(Z[Z.length - 1], { "stop-opacity": ("opacity" in F ? F.opacity : 1) * ("fill-opacity" in F ? F["fill-opacity"] : 1) }); F.gradient = k; F.fill = "none"; g.fill = ""; break
                    } Z.hasOwnProperty("opacity") ? (R(A, { "fill-opacity": g.fillOpacity = 1 < Z.opacity ? Z.opacity / 100 : Z.opacity }), c._.fillOpacityDirty = !0) : c._.fillOpacityDirty && b.is(F["fill-opacity"], "undefined") && b.is(p["fill-opacity"], "undefined") && (A.removeAttribute("fill-opacity"), g.fillOpacity = "", delete c._.fillOpacityDirty); case "stroke": Z =
b.getRGB(k); A.setAttribute(h, Z.hex); g[h] = Z.hex; "stroke" == h && (Z.hasOwnProperty("opacity") ? (R(A, { "stroke-opacity": g.strokeOpacity = 1 < Z.opacity ? Z.opacity / 100 : Z.opacity }), c._.strokeOpacityDirty = !0) : c._.strokeOpacityDirty && b.is(F["stroke-opacity"], "undefined") && b.is(p["stroke-opacity"], "undefined") && (A.removeAttribute("stroke-opacity"), g.strokeOpacity = "", delete c._.strokeOpacityDirty), c._.arrows && ("startString" in c._.arrows && D(c, c._.arrows.startString), "endString" in c._.arrows && D(c, c._.arrows.endString,
1))); break; case "gradient": "circle" != c.type && "ellipse" != c.type && "r" == a(k).charAt() || I(c, k); break; case "line-height": case "vertical-align": break; case "visibility": "hidden" === k ? c.hide() : c.show(); break; case "opacity": F.gradient && !F.hasOwnProperty("stroke-opacity") && R(A, { "stroke-opacity": 1 < k ? k / 100 : k }); case "fill-opacity": if (F.gradient) { if (Z = b._g.doc.getElementById(A.getAttribute("fill").replace(/^url\(#|\)$/g, ""))) Z = Z.getElementsByTagName("stop"), R(Z[Z.length - 1], { "stop-opacity": k }); break } default: "font-size" ==
h && (k = e(k, 10) + "px"), Z = h.replace(/(\-.)/g, function (a) { return a.substring(1).toUpperCase() }), g[Z] = k, c._.dirty = 1, A.setAttribute(h, k)
            } 
        } "text" === c.type && m(c, p); g.visibility = w
    } 
}, m = function (e, p) {
    if ("text" == e.type && (p.hasOwnProperty("text") || p.hasOwnProperty("font") || p.hasOwnProperty("font-size") || p.hasOwnProperty("x") || p.hasOwnProperty("y") || p.hasOwnProperty("line-height") || p.hasOwnProperty("vertical-align"))) {
        var d = e.attrs, v = e.node, A = v.firstChild && b._g.doc.defaultView.getComputedStyle(v.firstChild, "") ?
c(b._g.doc.defaultView.getComputedStyle(v.firstChild, "").getPropertyValue("font-size")) : 10, F = c(p["line-height"] || d["line-height"]) || 1.2 * A, r = d.hasOwnProperty("vertical-align") ? d["vertical-align"] : "middle"; isNaN(F) && (F = 1.2 * A); b.is(p.text, "array") && (p.text = p.text.join("<br>")); r = "top" === r ? -0.5 : "bottom" === r ? 0.5 : 0; if (p.hasOwnProperty("text") && (p.text !== d.text || e._textdirty)) {
            for (d.text = p.text; v.firstChild; ) v.removeChild(v.firstChild); for (var f = a(p.text).split(/\n|<br\s*?\/?>/ig), A = [], q, g = 0, w = f.length; g <
w; g++) q = R("tspan"), g ? R(q, { dy: F, x: d.x }) : R(q, { dy: F * f.length * r, x: d.x }), f[g] || (q.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), f[g] = " "), q.appendChild(b._g.doc.createTextNode(f[g])), v.appendChild(q), A[g] = q; e._textdirty = !1
        } else for (A = v.getElementsByTagName("tspan"), g = 0, w = A.length; g < w; g++) g ? R(A[g], { dy: F, x: d.x }) : R(A[0], { dy: F * A.length * r, x: d.x }); R(v, { x: d.x, y: d.y }); e._.dirty = 1; v = e._getBBox(); F = d.y - (v.y + v.height / 2); if (v.isCalculated) switch (d["vertical-align"]) {
            case "top": F = 0.75 *
v.height; break; case "bottom": F = -(0.25 * v.height); break; default: F = d.y - (v.y + 0.25 * v.height)
        } F && b.is(F, "finite") && A[0] && R(A[0], { dy: F })
    } 
}, l = function (a, c, e) {
    e = e || c; e.canvas && e.canvas.appendChild(a); this.node = this[0] = a; a.raphael = !0; a.raphaelid = this.id = b._oid++; this.matrix = b.matrix(); this.realPath = null; this.attrs = this.attrs || {}; this.followers = this.followers || []; this.paper = c; this.ca = this.customAttributes = this.customAttributes || new c._CustomAttributes; this._ = { transform: [], sx: 1, sy: 1, deg: 0, dx: 0, dy: 0, dirty: 1 };
    this.parent = e; !e.bottom && (e.bottom = this); (this.prev = e.top) && (e.top.next = this); e.top = this; this.next = null
}, L = b.el; l.prototype = L; L.constructor = l; b._engine.getNode = function (a) { a = a.node || a[0].node; return a.titleNode || a }; b._engine.getLastNode = function (a) { a = a.node || a[a.length - 1].node; return a.titleNode || a }; L.rotate = function (b, e, p) {
    if (this.removed) return this; b = a(b).split(r); b.length - 1 && (e = c(b[1]), p = c(b[2])); b = c(b[0]); null == p && (e = p); if (null == e || null == p) p = this.getBBox(1), e = p.x + p.width / 2, p = p.y + p.height / 2; this.transform(this._.transform.concat([["r",
b, e, p]])); return this
}; L.scale = function (b, e, p, d) { var v; if (this.removed) return this; b = a(b).split(r); b.length - 1 && (e = c(b[1]), p = c(b[2]), d = c(b[3])); b = c(b[0]); null == e && (e = b); null == d && (p = d); if (null == p || null == d) v = this.getBBox(1); p = null == p ? v.x + v.width / 2 : p; d = null == d ? v.y + v.height / 2 : d; this.transform(this._.transform.concat([["s", b, e, p, d]])); return this }; L.translate = function (b, e) {
    if (this.removed) return this; b = a(b).split(r); b.length - 1 && (e = c(b[1])); b = c(b[0]) || 0; this.transform(this._.transform.concat([["t", b, +e ||
0]])); return this
}; L.transform = function (a) { var c = this._; if (null == a) return c.transform; b._extractTransform(this, a); this.clip && !c.clipispath && R(this.clip, { transform: this.matrix.invert() }); this.pattern && z(this); this.node && R(this.node, { transform: this.matrix }); if (1 != c.sx || 1 != c.sy) a = this.attrs.hasOwnProperty("stroke-width") ? this.attrs["stroke-width"] : 1, this.attr({ "stroke-width": a }); return this }; L.hide = function () { !this.removed && this.paper.safari(this.node.style.display = "none"); return this }; L.show = function () {
    !this.removed &&
this.paper.safari(this.node.style.display = ""); return this
}; L.remove = function () {
    if (!this.removed && this.parent.canvas) {
        var a = b._engine.getNode(this), c = this.paper, e = c.defs; c.__set__ && c.__set__.exclude(this); q.unbind("raphael.*.*." + this.id); for (this.gradient && e && O(this); e = this.followers.pop(); ) e.el.remove(); for (; e = this.bottom; ) e.remove(); this._drag && this.undrag(); if (this.events) for (; e = this.events.pop(); ) e.unbind(); this.parent.canvas.removeChild(a); this.removeData(); delete c._elementsById[this.id]; b._tear(this,
this.parent); for (e in this) this[e] = "function" === typeof this[e] ? b._removedFactory(e) : null; this.removed = !0
    } 
}; L._getBBox = function () {
    var a = this.node, b = {}, c = this.attrs, e, p; "none" === a.style.display && (this.show(), p = !0); try { b = a.getBBox(), "text" == this.type && (void 0 === b.x && (b.isCalculated = !0, e = c["text-anchor"], b.x = (c.x || 0) - b.width * ("start" === e ? 0 : "middle" === e ? 0.5 : 1)), void 0 === b.y && (b.isCalculated = !0, e = c["vertical-align"], b.y = (c.y || 0) - b.height * ("bottom" === e ? 1 : "middle" === e ? 0.5 : 0))) } catch (d) { } finally { b = b || {} } p &&
this.hide(); return b
}; L.attr = function (a, c) {
    if (this.removed) return this; if (null == a) { var e = {}, p; for (p in this.attrs) this.attrs.hasOwnProperty(p) && (e[p] = this.attrs[p]); e.gradient && "none" == e.fill && (e.fill = e.gradient) && delete e.gradient; e.transform = this._.transform; e.visibility = "none" === this.node.style.display ? "hidden" : "visible"; return e } if (null == c && b.is(a, "string")) {
        if ("fill" == a && "none" == this.attrs.fill && this.attrs.gradient) return this.attrs.gradient; if ("transform" == a) return this._.transform; if ("visibility" ==
a) return "none" === this.node.style.display ? "hidden" : "visible"; var e = a.split(r), d = {}, v = 0; for (p = e.length; v < p; v++) a = e[v], a in this.attrs ? d[a] = this.attrs[a] : b.is(this.ca[a], "function") ? d[a] = this.ca[a].def : d[a] = b._availableAttrs[a]; return p - 1 ? d : d[e[0]]
    } if (null == c && b.is(a, "array")) { d = {}; v = 0; for (p = a.length; v < p; v++) d[a[v]] = this.attr(a[v]); return d } null != c ? (e = {}, e[a] = c) : null != a && b.is(a, "object") && (e = a); for (v in e) q("raphael.attr." + v + "." + this.id, this, e[v], v); var A = {}; for (v in this.ca) if (this.ca[v] && e.hasOwnProperty(v) &&
b.is(this.ca[v], "function") && !this.ca["_invoked" + v]) { this.ca["_invoked" + v] = !0; p = this.ca[v].apply(this, [].concat(e[v])); delete this.ca["_invoked" + v]; for (d in p) p.hasOwnProperty(d) && (e[d] = p[d]); this.attrs[v] = e[v]; !1 === p && (A[v] = e[v], delete e[v]) } K(this, e); var F, v = 0; for (p = this.followers.length; v < p; v++) F = this.followers[v], F.cb && !F.cb.call(F.el, e, this) || F.el.attr(e); for (d in A) e[d] = A[d]; return this
}; L.blur = function (a) {
    if (0 !== +a) {
        var c = R("filter"), e = R("feGaussianBlur"); this.attrs.blur = a; c.id = b.createUUID();
        R(e, { stdDeviation: +a || 1.5 }); c.appendChild(e); this.paper.defs.appendChild(c); this._blur = c; R(this.node, { filter: "url('" + b._url + "#" + c.id + "')" })
    } else this._blur && (this._blur.parentNode.removeChild(this._blur), delete this._blur, delete this.attrs.blur), this.node.removeAttribute("filter")
}; L.on = function (a, c) { if (this.removed) return this; var e = c; b.supportsTouch && (a = b._touchMap[a] || "click" === a && "touchstart" || a, e = function (a) { a.preventDefault(); c() }); this.node["on" + a] = e; return this }; b._engine.path = function (a,
b, c) { var e = R("path"); a = new l(e, a, c); a.type = "path"; K(a, b); G(a, b); return a }; b._engine.group = function (a, b, c) { var e = R("g"); a = new l(e, a, c); a.type = "group"; a.canvas = a.node; a.top = a.bottom = null; a._id = b || ""; b && e.setAttribute("class", "raphael-group-" + a.id + "-" + b); return a }; b._engine.circle = function (a, b, c) { var e = R("circle"); a = new l(e, a, c); a.type = "circle"; K(a, b); G(a, b); return a }; b._engine.rect = function (a, b, c) { var e = R("rect"); a = new l(e, a, c); a.type = "rect"; b.rx = b.ry = b.r; K(a, b); G(a, b); return a }; b._engine.ellipse = function (a,
b, c) { var e = R("ellipse"); a = new l(e, a, c); a.type = "ellipse"; K(a, b); G(a, b); return a }; b._engine.image = function (a, b, c) { var e = R("image"); a = new l(e, a, c); a.type = "image"; e.setAttribute("preserveAspectRatio", "none"); K(a, b); G(a, b); return a }; b._engine.text = function (a, b, c) { var e = R("text"); a = new l(e, a, c); a.type = "text"; a._textdirty = !0; K(a, b); G(a, b); return a }; b._engine.setSize = function (a, b) {
    this.width = a || this.width; this.height = b || this.height; this.canvas.setAttribute("width", this.width); this.canvas.setAttribute("height",
this.height); this._viewBox && this.setViewBox.apply(this, this._viewBox); return this
}; b._engine.create = function () {
    var a = b._getContainer.apply(0, arguments), c = a && a.container, e = a.x, p = a.y, d = a.width, a = a.height; if (!c) throw Error("SVG container not found."); var v = R("svg"), A, e = e || 0, p = p || 0, d = d || 512, a = a || 342; R(v, { height: a, version: 1.1, width: d, xmlns: "http://www.w3.org/2000/svg" }); 1 == c ? (v.style.cssText = "overflow:hidden;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-moz-user-select:-moz-none;-khtml-user-select:none;-ms-user-select:none;user-select:none;-o-user-select:none;cursor:default;position:absolute;left:" +
e + "px;top:" + p + "px", b._g.doc.body.appendChild(v), A = 1) : (v.style.cssText = "overflow:hidden;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-user-select:none;-moz-user-select:-moz-none;-khtml-user-select:none;-ms-user-select:none;user-select:none;-o-user-select:none;cursor:default;position:relative", c.firstChild ? c.insertBefore(v, c.firstChild) : c.appendChild(v)); c = new b._Paper; c.width = d; c.height = a; c.canvas = v; R(v, { id: "raphael-paper-" + c.id }); c.clear(); c._left = c._top = 0; A && (c.renderfix = function () { }); c.renderfix();
    return c
}; b._engine.setViewBox = function (a, b, c, e, p) {
    q("raphael.setViewBox", this, this._viewBox, [a, b, c, e, p]); var v = d(c / this.width, e / this.height), A = this.top, F = p ? "meet" : "xMinYMin", r; null == a ? (this._vbSize && (v = 1), delete this._vbSize, r = "0 0 " + this.width + " " + this.height) : (this._vbSize = v, r = a + " " + b + " " + c + " " + e); for (R(this.canvas, { viewBox: r, preserveAspectRatio: F }); v && A; ) F = "stroke-width" in A.attrs ? A.attrs["stroke-width"] : 1, A.attr({ "stroke-width": F }), A._.dirty = 1, A._.dirtyT = 1, A = A.prev; this._viewBox = [a, b, c, e, !!p];
    return this
}; b.prototype.renderfix = function () { var a = this.canvas, b = a.style, c; try { c = a.getScreenCTM() || a.createSVGMatrix() } catch (e) { c = a.createSVGMatrix() } a = -c.e % 1; c = -c.f % 1; if (a || c) a && (this._left = (this._left + a) % 1, b.left = this._left + "px"), c && (this._top = (this._top + c) % 1, b.top = this._top + "px") }; b.prototype._desc = function (a) {
    var c = this.desc; if (c) for (; c.firstChild; ) c.removeChild(c.firstChild); else this.desc = c = R("desc"), this.canvas.appendChild(c); c.appendChild(b._g.doc.createTextNode(b.is(a, "string") ? a : "Created with Red RaphaÃ«l " +
b.version))
}; b.prototype.clear = function () { var a; for (q("raphael.clear", this); a = this.bottom; ) a.remove(); for (a = this.canvas; a.firstChild; ) a.removeChild(a.firstChild); this.bottom = this.top = null; a.appendChild(this.desc = R("desc")); a.appendChild(this.defs = R("defs")) }; b.prototype.remove = function () {
    var a; for (q("raphael.remove", this); a = this.bottom; ) a.remove(); this.defs && this.defs.parentNode.removeChild(this.defs); this.desc && this.desc.parentNode.removeChild(this.desc); this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
    for (a in this) this[a] = "function" == typeof this[a] ? b._removedFactory(a) : null; this.removed = !0
}; var Q = b.st, Ea; for (Ea in L) L.hasOwnProperty(Ea) && !Q.hasOwnProperty(Ea) && (Q[Ea] = function (a) { return function () { var b = arguments; return this.forEach(function (c) { c[a].apply(c, b) }) } } (Ea))
                } 
            })(); (function () {
                if (b.vml) {
                    var a = String, c = parseFloat, e = Math, p = e.round, d = e.max, v = e.min, A = e.sqrt, F = e.abs, r = /[, ]+/, f = b.eve, q = { M: "m", L: "l", C: "c", Z: "x", m: "t", l: "r", c: "v", z: "x" }, g = /([clmz]),?([^clmz]*)/gi, w = / progid:\S+Blur\([^\)]+\)/g,
O = /-?[^,\s-]+/g, R = { path: 1, rect: 1, image: 1 }, h = { circle: 1, ellipse: 1 }, k = function (c) {
    var e = /[ahqstv]/ig, d = b._pathToAbsolute; a(c).match(e) && (d = b._path2curve); e = /[clmz]/g; if (d == b._pathToAbsolute && !a(c).match(e)) return (c = a(c).replace(g, function (a, b, c) { var e = [], d = "m" == b.toLowerCase(), v = q[b]; c.replace(O, function (a) { d && 2 == e.length && (v += e + q["m" == b ? "l" : "L"], e = []); e.push(p(21600 * a)) }); return v + e })) || "m0,0"; var e = d(c), v; c = []; for (var A = 0, F = e.length; A < F; A++) {
        d = e[A]; v = e[A][0].toLowerCase(); "z" == v && (v = "x"); for (var r =
1, f = d.length; r < f; r++) v += p(21600 * d[r]) + (r != f - 1 ? "," : ""); c.push(v)
    } return c.length ? c.join(" ") : "m0,0"
}, I = function (a, c, e) { var p = b.matrix(); p.rotate(-a, 0.5, 0.5); return { dx: p.x(c, e), dy: p.y(c, e)} }, Z = function (a, b, c, e, p, d) {
    var v = a._, A = a.matrix, r = v.fillpos; a = a.node; var f = a.style, q = 1, g = "", w = 21600 / b, O = 21600 / c; f.visibility = "hidden"; if (b && c) {
        a.coordsize = F(w) + " " + F(O); f.rotation = d * (0 > b * c ? -1 : 1); d && (p = I(d, e, p), e = p.dx, p = p.dy); 0 > b && (g += "x"); 0 > c && (g += " y") && (q = -1); f.flip = g; a.coordorigin = e * -w + " " + p * -O; if (r || v.fillsize) if (e =
(e = a.getElementsByTagName("fill")) && e[0]) a.removeChild(e), r && (p = I(d, A.x(r[0], r[1]), A.y(r[0], r[1])), e.position = p.dx * q + " " + p.dy * q), v.fillsize && (e.size = v.fillsize[0] * F(b) + " " + v.fillsize[1] * F(c)), a.appendChild(e); f.visibility = "visible"
    } 
}; b._url = ""; b.toString = function () { return "Your browser doesnâ€™t support SVG. Falling down to VML.\nYou are running RaphaÃ«l " + this.version }; var z = function (b, c, e) {
    c = a(c).toLowerCase().split("-"); e = e ? "end" : "start"; for (var p = c.length, d = "classic", v = "medium", A = "medium"; p--; ) switch (c[p]) {
        case "block": case "classic": case "oval": case "diamond": case "open": case "none": d =
c[p]; break; case "wide": case "narrow": A = c[p]; break; case "long": case "short": v = c[p]
    } b = b.node.getElementsByTagName("stroke")[0]; b[e + "arrow"] = d; b[e + "arrowlength"] = v; b[e + "arrowwidth"] = A
}, D = function (a, b) { for (var c in a.ca) b.hasOwnProperty(c) && a.attr(c, b[c]) }, G = b._setFillAndStroke = function (e, A) {
    if (e.paper.canvas) {
        e.attrs = e.attrs || {}; var F = e.node, f = e.attrs, q = F.style, g = R[e.type] && (A.x != f.x || A.y != f.y || A.width != f.width || A.height != f.height || A.cx != f.cx || A.cy != f.cy || A.rx != f.rx || A.ry != f.ry || A.r != f.r), w = h[e.type] &&
(f.cx != A.cx || f.cy != A.cy || f.r != A.r || f.rx != A.rx || f.ry != A.ry), O = "group" === e.type, I; for (I in A) A.hasOwnProperty(I) && (f[I] = A[I]); g && (f.path = b._getPath[e.type](e), e._.dirty = 1); A.href && (F.href = A.href); A.title && (F.title = A.title); A.target && (F.target = A.target); A.cursor && (q.cursor = A.cursor); "blur" in A && e.blur(A.blur); if (A.path && "path" == e.type || g) F.path = k(~a(f.path).toLowerCase().indexOf("r") ? b._pathToAbsolute(f.path) : f.path), "image" == e.type && (e._.fillpos = [f.x, f.y], e._.fillsize = [f.width, f.height], Z(e, 1, 1, 0, 0,
0)); "transform" in A && e.transform(A.transform); "rotation" in A && (q = A.rotation, b.is(q, "array") ? e.rotate.apply(e, q) : e.rotate(q)); "visibility" in A && ("hidden" === A.visibility ? e.hide() : e.show()); w && (q = +f.cx, w = +f.cy, g = +f.rx || +f.r || 0, I = +f.ry || +f.r || 0, F.path = b.format("ar{0},{1},{2},{3},{4},{1},{4},{1}x", p(21600 * (q - g)), p(21600 * (w - I)), p(21600 * (q + g)), p(21600 * (w + I)), p(21600 * q))); "clip-rect" in A && (q = a(A["clip-rect"]).split(r), 4 == q.length && (q[0] = +q[0], q[1] = +q[1], q[2] = +q[2] + q[0], q[3] = +q[3] + q[1], g = O ? F : F.clipRect || b._g.doc.createElement("div"),
w = g.style, O ? (e.clip = q.slice(), g = e.matrix.offset(), g = [c(g[0]), c(g[1])], q[0] -= g[0], q[1] -= g[1], q[2] -= g[0], q[3] -= g[1], w.width = "10800px", w.height = "10800px") : F.clipRect || (w.top = "0", w.left = "0", w.width = e.paper.width + "px", w.height = e.paper.height + "px", F.parentNode.insertBefore(g, F), g.appendChild(F), g.raphael = !0, g.raphaelid = F.raphaelid, F.clipRect = g), w.position = "absolute", w.clip = b.format("rect({1}px {2}px {3}px {0}px)", q)), A["clip-rect"] || (O && e.clip ? (F.style.clip = "rect(auto auto auto auto)", delete e.clip) : F.clipRect &&
(F.clipRect.style.clip = "rect(auto auto auto auto)"))); e.textpath && (O = e.textpath.style, A.font && (O.font = A.font), A["font-family"] && (O.fontFamily = '"' + A["font-family"].split(",")[0].replace(/^['"]+|['"]+$/g, "") + '"'), A["font-size"] && (O.fontSize = A["font-size"]), A["font-weight"] && (O.fontWeight = A["font-weight"]), A["font-style"] && (O.fontStyle = A["font-style"])); "arrow-start" in A && z(e, A["arrow-start"]); "arrow-end" in A && z(e, A["arrow-end"], 1); if (null != A.opacity || null != A["stroke-width"] || null != A.fill || null != A.src ||
null != A.stroke || null != A["stroke-width"] || null != A["stroke-opacity"] || null != A["fill-opacity"] || null != A["stroke-dasharray"] || null != A["stroke-miterlimit"] || null != A["stroke-linejoin"] || null != A["stroke-linecap"]) {
            O = F.getElementsByTagName("fill"); q = -1; O = O && O[0]; !O && (O = m("fill")); "image" == e.type && A.src && (O.src = A.src); A.fill && (O.on = !0); if (null == O.on || "none" == A.fill || null === A.fill) O.on = !1; O.on && A.fill && ((w = a(A.fill).match(b._ISURL)) ? (O.parentNode == F && F.removeChild(O), O.rotate = !0, O.src = w[1], O.type = "tile", g =
e.getBBox(1), O.position = g.x + " " + g.y, e._.fillpos = [g.x, g.y], b._preload(w[1], function () { e._.fillsize = [this.offsetWidth, this.offsetHeight] })) : (w = b.getRGB(A.fill), O.color = w.hex, O.src = "", O.type = "solid", w.error && (e.type in { circle: 1, ellipse: 1} || "r" != a(A.fill).charAt()) && s(e, A.fill, O) ? (f.fill = "none", f.gradient = A.fill, O.rotate = !1) : "opacity" in w && !("fill-opacity" in A) && (q = w.opacity))); if (-1 !== q || "fill-opacity" in A || "opacity" in A) w = ((+f["fill-opacity"] + 1 || 2) - 1) * ((+f.opacity + 1 || 2) - 1) * ((+q + 1 || 2) - 1), w = v(d(w, 0),
1), O.opacity = w, O.src && (O.color = "none"); F.appendChild(O); O = F.getElementsByTagName("stroke") && F.getElementsByTagName("stroke")[0]; q = !1; !O && (q = O = m("stroke")); if (A.stroke && "none" != A.stroke || A["stroke-width"] || null != A["stroke-opacity"] || A["stroke-dasharray"] || A["stroke-miterlimit"] || A["stroke-linejoin"] || A["stroke-linecap"]) O.on = !0; "none" != A.stroke && null !== A.stroke && null != O.on && 0 != A.stroke && 0 != A["stroke-width"] || (O.on = !1); w = b.getRGB("stroke" in A ? A.stroke : f.stroke); O.on && A.stroke && (O.color = w.hex); w = ((+f["stroke-opacity"] +
1 || 2) - 1) * ((+f.opacity + 1 || 2) - 1) * ((+w.opacity + 1 || 2) - 1); g = 0.75 * (c(A["stroke-width"]) || 1); w = v(d(w, 0), 1); null == A["stroke-width"] && (g = f["stroke-width"]); A["stroke-width"] && (O.weight = g); g && 1 > g && (w *= g) && (O.weight = 1); O.opacity = w; A["stroke-linejoin"] && (O.joinstyle = A["stroke-linejoin"]) || q && (q.joinstyle = "miter"); O.miterlimit = A["stroke-miterlimit"] || 8; A["stroke-linecap"] && (O.endcap = "butt" == A["stroke-linecap"] ? "flat" : "square" == A["stroke-linecap"] ? "square" : "round"); A["stroke-dasharray"] && (w = { "-": "shortdash", ".": "shortdot",
    "-.": "shortdashdot", "-..": "shortdashdotdot", ". ": "dot", "- ": "dash", "--": "longdash", "- .": "dashdot", "--.": "longdashdot", "--..": "longdashdotdot"
}, O.dashstyle = w.hasOwnProperty(A["stroke-dasharray"]) ? w[A["stroke-dasharray"]] : A["stroke-dasharray"].join && A["stroke-dasharray"].join(" ") || ""); q && F.appendChild(O)
        } if ("text" == e.type) {
            e.paper.canvas.style.display = ""; F = e.paper.span; O = f.font && f.font.match(/\d+(?:\.\d*)?(?=px)/); w = f["line-height"] && (f["line-height"] + "").match(/\d+(?:\.\d*)?(?=px)/); q = F.style; f.font &&
(q.font = f.font); f["font-family"] && (q.fontFamily = f["font-family"]); f["font-weight"] && (q.fontWeight = f["font-weight"]); f["font-style"] && (q.fontStyle = f["font-style"]); O = c(f["font-size"] || O && O[0]) || 10; q.fontSize = 100 * O + "px"; w = c(f["line-height"] || w && w[0]) || 12; f["line-height"] && (q.lineHeight = 100 * w + "px"); b.is(A.text, "array") && (A.text = e.textpath.string = A.text.join("\n").replace(/<br\s*?\/?>/ig, "\n")); e.textpath.string && (F.innerHTML = a(e.textpath.string).replace(/</g, "&#60;").replace(/&/g, "&#38;").replace(/\n/g,
"<br>")); F = F.getBoundingClientRect(); e.W = f.w = (F.right - F.left) / 100; e.H = f.h = (F.bottom - F.top) / 100; e.X = f.x; e.Y = f.y; switch (f["vertical-align"]) { case "top": e.bby = e.H / 2; break; case "bottom": e.bby = -e.H / 2; break; default: e.bby = 0 } ("x" in A || "y" in A || void 0 !== e.bby) && (e.path.v = b.format("m{0},{1}l{2},{1}", p(21600 * f.x), p(21600 * (f.y + (e.bby || 0))), p(21600 * f.x) + 1)); F = "x y text font font-family font-weight font-style font-size line-height".split(" "); O = 0; for (q = F.length; O < q; O++) if (F[O] in A) { e._.dirty = 1; break } switch (f["text-anchor"]) {
                case "start": e.textpath.style["v-text-align"] =
"left"; e.bbx = e.W / 2; break; case "end": e.textpath.style["v-text-align"] = "right"; e.bbx = -e.W / 2; break; default: e.textpath.style["v-text-align"] = "center", e.bbx = 0
            } e.textpath.style["v-text-kern"] = !0
        } 
    } 
}, s = function (e, p, d) {
    e.attrs = e.attrs || {}; var v = Math.pow, F = "linear", f = ".5 .5"; e.attrs.gradient = p; p = a(p).replace(b._radial_gradient, function (a, b) { F = "radial"; b = b && b.split(",") || []; var e = b[3], p = b[4]; e && p && (e = c(e), p = c(p), 0.25 < v(e - 0.5, 2) + v(p - 0.5, 2) && (p = A(0.25 - v(e - 0.5, 2)) * (2 * (0.5 < p) - 1) + 0.5), f = e + " " + p); return "" }); p = p.split(/\s*\-\s*/);
    if ("linear" == F) { var r = p.shift(), r = -c(r); if (isNaN(r)) return null } p = b._parseDots(p); if (!p) return null; e = e.shape || e.node; if (p.length) {
        d.parentNode == e && e.removeChild(d); d.on = !0; d.method = "none"; d.color = p[0].color; d.color2 = p[p.length - 1].color; for (var q = [], g = 1, w = void 0 === p[0].opacity ? 1 : p[0].opacity, O = 0, R = p.length; O < R; O++) p[O].offset && q.push(p[O].offset + " " + p[O].color), void 0 !== p[O].opacity && (g = p[O].opacity); d.colors = q.length ? q.join() : "0% " + d.color; d.opacity = g; d["o:opacity2"] = w; "radial" == F ? (d.type = "gradientTitle",
d.focus = "100%", d.focussize = "0 0", d.focusposition = f, d.angle = 0) : (d.type = "gradient", d.angle = (270 - r) % 360); e.appendChild(d)
    } return 1
}, l = function (a, c, e) {
    e = e || c; var p; e.canvas && e.canvas.appendChild(a); p = m("skew"); p.on = !0; a.appendChild(p); this.skew = p; this.node = this[0] = a; a.raphael = !0; a.raphaelid = this.id = b._oid++; this.Y = this.X = 0; this.attrs = this.attrs || {}; this.followers = this.followers || []; this.paper = c; this.ca = this.customAttributes = this.customAttributes || new c._CustomAttributes; this.matrix = b.matrix(); this._ =
{ transform: [], sx: 1, sy: 1, dx: 0, dy: 0, deg: 0, dirty: 1, dirtyT: 1 }; this.parent = e; !e.bottom && (e.bottom = this); (this.prev = e.top) && (e.top.next = this); e.top = this; this.next = null
}, e = b.el; l.prototype = e; e.constructor = l; e.transform = function (c) {
    if (null == c) return this._.transform; var e = this.paper._viewBoxShift, p = e ? "s" + [e.scale, e.scale] + "-1-1t" + [e.dx, e.dy] : "", d; e && (d = c = a(c).replace(/\.{3}|\u2026/g, this._.transform || "")); b._extractTransform(this, p + c); var e = this.matrix.clone(), v = this.skew; c = this.node; var p = ~a(this.attrs.fill).indexOf("-"),
A = !a(this.attrs.fill).indexOf("url("); e.translate(-0.5, -0.5); A || p || "image" == this.type ? (v.matrix = "1 0 0 1", v.offset = "0 0", v = e.split(), p && v.noRotation || !v.isSimple ? (c.style.filter = e.toFilter(), e = this.getBBox(), p = this.getBBox(1), A = e.x2 && p.x2 && "x2" || "x", v = e.y2 && p.y2 && "y2" || "y", A = e[A] - p[A], e = e[v] - p[v], c.coordorigin = -21600 * A + " " + -21600 * e, Z(this, 1, 1, A, e, 0)) : (c.style.filter = "", Z(this, v.scalex, v.scaley, v.dx, v.dy, v.rotate))) : (c.style.filter = "", v.matrix = a(e), v.offset = e.offset()); d && (this._.transform = d); return this
};
                    e.rotate = function (b, e, p) { if (this.removed) return this; if (null != b) { b = a(b).split(r); b.length - 1 && (e = c(b[1]), p = c(b[2])); b = c(b[0]); null == p && (e = p); if (null == e || null == p) p = this.getBBox(1), e = p.x + p.width / 2, p = p.y + p.height / 2; this._.dirtyT = 1; this.transform(this._.transform.concat([["r", b, e, p]])); return this } }; e.translate = function (b, e) {
                        if (this.removed) return this; b = a(b).split(r); b.length - 1 && (e = c(b[1])); b = c(b[0]) || 0; e = +e || 0; this._.bbox && (this._.bbox.x += b, this._.bbox.y += e); this.transform(this._.transform.concat([["t",
b, e]])); return this
                    }; e.scale = function (b, e, p, d) { if (this.removed) return this; b = a(b).split(r); b.length - 1 && (e = c(b[1]), p = c(b[2]), d = c(b[3]), isNaN(p) && (p = null), isNaN(d) && (d = null)); b = c(b[0]); null == e && (e = b); null == d && (p = d); if (null == p || null == d) var v = this.getBBox(1); p = null == p ? v.x + v.width / 2 : p; d = null == d ? v.y + v.height / 2 : d; this.transform(this._.transform.concat([["s", b, e, p, d]])); this._.dirtyT = 1; return this }; e.hide = function (a) { !this.removed && (this.node.style.display = "none"); return this }; e.show = function (a) {
                        !this.removed &&
(this.node.style.display = ""); return this
                    }; e._getBBox = function () { return this.removed ? {} : { x: this.X + (this.bbx || 0) - this.W / 2, y: this.Y + (this.bby || 0) - this.H / 2, width: this.W, height: this.H} }; e.remove = function () {
                        if (!this.removed && this.parent.canvas) {
                            var a = b._engine.getNode(this), c = this.paper, e = this.shape; c.__set__ && c.__set__.exclude(this); f.unbind("raphael.*.*." + this.id); e && e.parentNode.removeChild(e); for (a.parentNode && a.parentNode.removeChild(a); a = this.followers.pop(); ) a.el.remove(); for (; a = this.bottom; ) a.remove();
                            this._drag && this.undrag(); if (this.events) for (; a = this.events.pop(); ) a.unbind(); this.removeData(); delete c._elementsById[this.id]; b._tear(this, this.parent); for (a in this) this[a] = "function" === typeof this[a] ? b._removedFactory(a) : null; this.removed = !0
                        } 
                    }; e.attr = function (a, c) {
                        if (this.removed) return this; if (null == a) {
                            var e = {}, p; for (p in this.attrs) this.attrs.hasOwnProperty(p) && (e[p] = this.attrs[p]); e.gradient && "none" == e.fill && (e.fill = e.gradient) && delete e.gradient; e.transform = this._.transform; e.visibility = "none" ===
this.node.style.display ? "hidden" : "visible"; return e
                        } if (null == c && b.is(a, "string")) { if ("fill" == a && "none" == this.attrs.fill && this.attrs.gradient) return this.attrs.gradient; if ("visibility" == a) return "none" === this.node.style.display ? "hidden" : "visible"; var e = a.split(r), d = {}, v = 0; for (p = e.length; v < p; v++) a = e[v], a in this.attrs ? d[a] = this.attrs[a] : b.is(this.ca[a], "function") ? d[a] = this.ca[a].def : d[a] = b._availableAttrs[a]; return p - 1 ? d : d[e[0]] } if (this.attrs && null == c && b.is(a, "array")) {
                            d = {}; v = 0; for (p = a.length; v < p; v++) d[a[v]] =
this.attr(a[v]); return d
                        } null != c && (e = {}, e[a] = c); null == c && b.is(a, "object") && (e = a); for (v in e) f("raphael.attr." + v + "." + this.id, this, e[v], v); if (e) {
                            var A = {}; for (v in this.ca) if (this.ca[v] && e.hasOwnProperty(v) && b.is(this.ca[v], "function") && !this.ca["_invoked" + v]) { this.ca["_invoked" + v] = !0; p = this.ca[v].apply(this, [].concat(e[v])); delete this.ca["_invoked" + v]; for (d in p) p.hasOwnProperty(d) && (e[d] = p[d]); this.attrs[v] = e[v]; !1 === p && (A[v] = e[v], delete e[v]) } "text" in e && "text" == this.type && (b.is(e.text, "array") &&
(e.text = e.text.join("\n")), this.textpath.string = e.text.replace(/<br\s*?\/?>/ig, "\n")); G(this, e); var F, v = 0; for (p = this.followers.length; v < p; v++) F = this.followers[v], F.cb && !F.cb.call(F.el, e, this) || F.el.attr(e); for (d in A) e[d] = A[d]
                        } return this
                    }; e.blur = function (a) {
                        var c = this.node.runtimeStyle, e = c.filter, e = e.replace(w, ""); 0 !== +a ? (this.attrs.blur = a, c.filter = e + "  progid:DXImageTransform.Microsoft.Blur(pixelradius=" + (+a || 1.5) + ")", c.margin = b.format("-{0}px 0 0 -{0}px", p(+a || 1.5))) : (c.filter = e, c.margin = 0, delete this.attrs.blur);
                        return this
                    }; e.on = function (a, c) { if (this.removed) return this; this.node["on" + a] = function () { var a = b._g.win.event; a.target = a.srcElement; c(a) }; return this }; b._engine.getNode = function (a) { a = a.node || a[0].node; return a.clipRect || a }; b._engine.getLastNode = function (a) { a = a.node || a[a.length - 1].node; return a.clipRect || a }; b._engine.group = function (a, c, e) {
                        var p = b._g.doc.createElement("div"), d = new l(p, a, e); p.style.cssText = "position:absolute;left:0;top:0;width:1px;height:1px"; d._id = c || ""; c && (p.className = "raphael-group-" +
d.id + "-" + c); (e || a).canvas.appendChild(p); d.type = "group"; d.canvas = d.node; d.transform = b._engine.group.transform; d.top = null; d.bottom = null; return d
                    }; b._engine.group.transform = function (e) {
                        if (null == e) return this._.transform; var p = this.node.style, d = this.clip, v = this.paper._viewBoxShift, A = v ? "s" + [v.scale, v.scale] + "-1-1t" + [v.dx, v.dy] : ""; v && (e = a(e).replace(/\.{3}|\u2026/g, this._.transform || "")); b._extractTransform(this, A + e); e = this.matrix; A = e.offset(); v = c(A[0]) || 0; A = c(A[1]) || 0; p.left = v + "px"; p.top = A + "px"; p.zoom =
(this._.tzoom = e.get(0)) + ""; d && (p.clip = b.format("rect({1}px {2}px {3}px {0}px)", [d[0] - v, d[1] - A, d[2] - v, d[3] - A])); return this
                    }; b._engine.path = function (a, b, c) { var e = m("shape"); e.style.cssText = "position:absolute;left:0;top:0;width:1px;height:1px"; e.coordsize = "21600 21600"; e.coordorigin = a.coordorigin; a = new l(e, a, c); a.type = b.type || "path"; a.path = []; a.Path = ""; b.type && delete b.type; G(a, b); D(a, b); return a }; b._engine.rect = function (a, c, e) {
                        var p = b._rectPath(c.x, c.y, c.w, c.h, c.r); c.path = p; c.type = "rect"; a = a.path(c,
e); c = a.attrs; a.X = c.x; a.Y = c.y; a.W = c.width; a.H = c.height; c.path = p; return a
                    }; b._engine.ellipse = function (a, b, c) { b.type = "ellipse"; a = a.path(b, c); b = a.attrs; a.X = b.x - b.rx; a.Y = b.y - b.ry; a.W = 2 * b.rx; a.H = 2 * b.ry; return a }; b._engine.circle = function (a, b, c) { b.type = "circle"; a = a.path(b, c); b = a.attrs; a.X = b.x - b.r; a.Y = b.y - b.r; a.W = a.H = 2 * b.r; return a }; b._engine.image = function (a, c, e) {
                        var p = b._rectPath(c.x, c.y, c.w, c.h); c.path = p; c.type = "image"; c.stroke = "none"; a = a.path(c, e); e = a.attrs; var p = a.node, d = p.getElementsByTagName("fill")[0];
                        e.src = c.src; a.X = e.x = c.x; a.Y = e.y = c.y; a.W = e.width = c.w; a.H = e.height = c.h; d.parentNode == p && p.removeChild(d); d.rotate = !0; d.src = e.src; d.type = "tile"; a._.fillpos = [e.x, e.y]; a._.fillsize = [e.w, e.h]; p.appendChild(d); Z(a, 1, 1, 0, 0, 0); return a
                    }; b._engine.text = function (c, e, d) {
                        var v = m("shape"), A = m("path"), F = m("textpath"); x = e.x || 0; y = e.y || 0; text = e.text; A.v = b.format("m{0},{1}l{2},{1}", p(21600 * e.x), p(21600 * e.y), p(21600 * e.x) + 1); A.textpathok = !0; F.string = a(e.text).replace(/<br\s*?\/?>/ig, "\n"); F.on = !0; v.style.cssText = "position:absolute;left:0;top:0;width:1px;height:1px";
                        v.coordsize = "21600 21600"; v.coordorigin = "0 0"; c = new l(v, c, d); c.shape = v; c.path = A; c.textpath = F; c.type = "text"; c.attrs.text = a(e.text || ""); c.attrs.x = e.x; c.attrs.y = e.y; c.attrs.w = 1; c.attrs.h = 1; G(c, e); D(c, e); v.appendChild(F); v.appendChild(A); return c
                    }; b._engine.setSize = function (a, c) { var e = this.canvas.style; this.width = a; this.height = c; a == +a && (a += "px"); c == +c && (c += "px"); e.width = a; e.height = c; e.clip = "rect(0 " + a + " " + c + " 0)"; this._viewBox && b._engine.setViewBox.apply(this, this._viewBox); return this }; b._engine.setViewBox =
function (a, b, c, e, p) { f("raphael.setViewBox", this, this._viewBox, [a, b, c, e, p]); var v = this.width, A = this.height, F = 1 / d(c / v, e / A), r, q; p && (r = A / e, q = v / c, c * r < v && (a -= (v - c * r) / 2 / r), e * q < A && (b -= (A - e * q) / 2 / q)); this._viewBox = [a, b, c, e, !!p]; this._viewBoxShift = { dx: -a, dy: -b, scale: F }; this.forEach(function (a) { a.transform("...") }); return this }; var m; b._engine.initWin = function (c) {
    var e = c.document; e.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)"); try {
        !e.namespaces.rvml && e.namespaces.add("rvml", "urn:schemas-microsoft-com:vml"),
m = b._createNode = function (b, c) { var p = e.createElement("<rvml:" + b + ' class="rvml">'), d; for (d in c) p[d] = a(c[d]); return p } 
    } catch (p) { m = b._createNode = function (b, c) { var p = e.createElement("<" + b + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">'), d; for (d in c) p[d] = a(c[d]); return p } } 
}; b._engine.initWin(b._g.win); b._engine.create = function () {
    var a = b._getContainer.apply(0, arguments), c = a.container, e = a.height, p = a.width, d = a.x, a = a.y; if (!c) throw Error("VML container not found."); var v = new b._Paper, A = v.canvas = b._g.doc.createElement("div"),
F = A.style, d = d || 0, a = a || 0, p = p || 512, e = e || 342; v.width = p; v.height = e; p == +p && (p += "px"); e == +e && (e += "px"); v.coordsize = "21600000 21600000"; v.coordorigin = "0 0"; A.id = "raphael-paper-" + v.id; v.span = b._g.doc.createElement("span"); v.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;"; A.appendChild(v.span); F.cssText = b.format("top:0;left:0;width:{0};height:{1};display:inline-block;cursor:default;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", p, e); 1 == c ? (b._g.doc.body.appendChild(A),
F.left = d + "px", F.top = a + "px", F.position = "absolute") : c.firstChild ? c.insertBefore(A, c.firstChild) : c.appendChild(A); v.renderfix = function () { }; return v
}; b.prototype.clear = function () { var a; for (f("raphael.clear", this); a = this.bottom; ) a.remove(); this.canvas.innerHTML = ""; this.span = b._g.doc.createElement("span"); this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;"; this.canvas.appendChild(this.span); this.bottom = this.top = null }; b.prototype.remove = function () {
    var a;
    for (f("raphael.remove", this); a = this.bottom; ) a.remove(); this.canvas.parentNode.removeChild(this.canvas); for (a in this) this[a] = "function" == typeof this[a] ? b._removedFactory(a) : null; return !0
}; var Q = b.st, K; for (K in e) e.hasOwnProperty(K) && !Q.hasOwnProperty(K) && (Q[K] = function (a) { return function () { var b = arguments; return this.forEach(function (c) { c[a].apply(c, b) }) } } (K))
                } 
            })(); xa ? da.win.Raphael = b : Raphael = b; return b
        })
    })(); d.Raphael = E; d.Raphael.desc = ""; n && n !== E ? window.Raphael = n : window.Raphael === E && (window.Raphael =
void 0)
} ]); FusionCharts.register("module", ["private", "fusioncharts.redraphael.helper", function () { var d = {}; this.hcLib.Raphael.fn._elementFromEvent = function (n) { if (!n || this.removed) return null; var E = n.srcElement || n.target || (n = n.originalEvent) && (n.srcElement || n.target) || d; "tspan" === E.nodeName && (E = E.parentNode); return this.getById(E.raphaelid) } } ]);
FusionCharts.register("module", ["private", "fusioncharts.redraphael.css", function () {
    var d = this.hcLib.Raphael, n = d.eve, E = d._g, u = d.fn, l = d.el, b = /[, ]+/, P = /\B([A-Z]{1})/g, c, J; c = function (a) { this.rules = {}; this.ns = a || "" }; J = c.prototype; J.getSheet = function () { var a = this.node; a || (a = this.node = E.doc.createElement("style"), this.node.setAttribute("id", d.format("raphael-stylesheet-{0}", d._oid++)), this.node.setAttribute("type", "text/css"), (E.doc.head || E.doc.getElementsByTagName("head")[0]).appendChild(this.node)); return a };
    J.setCssText = function (a) { var b = this.node; if (!b) if (a) b = this.getSheet(); else return; b.styleSheet ? b.styleSheet.cssText = a || "" : (b.innerHTML = "", a && b.appendChild(E.doc.createTextNode(a))) }; J.destroy = function () { this.node && this.node.parentNode && this.node.parentNode.removeChild(this.node); delete this.rules }; J.clear = function () { this.setCssText(""); this.rules = {} }; J.add = function (a, b) { var c = this.rules[a] || (this.rules[a] = {}), d; for (d in b) c[d] = b[d] }; J.render = function () {
        var a = "\n", b, c; for (b in this.rules) {
            a += b.replace(/(^|\,)/g,
"$1" + this.ns + " ") + " {\n"; b = this.rules[b]; for (c in b) b[c] && (a += "\t" + c.replace(P, "-$1").toLowerCase() + ": " + b[c] + ";\n"); a += "}\n"
        } this.setCssText(a)
    }; n.on("raphael.new", function () { this._stylesheet = this._stylesheet || new c; this.cssNamespace("") }); n.on("raphael.remove", function () { this._stylesheet && this._stylesheet.destroy(); delete this._stylesheet }); u.cssNamespace = function (a) { arguments.length && (this._stylesheet.ns = d.format("{0}#raphael-paper-{1}", a && a + " " || "", this.id)); return this._stylesheet.ns }; u.cssAddRule =
function (a, b) { if (1 === arguments.length && "object" === typeof a) { for (var c in a) this.cssAddRule(c, a[c]); return this } return this._stylesheet.add(a, b), this }; u.cssRender = function () { return d.svg && this._stylesheet.render(), this }; u.cssClear = function () { return this._stylesheet.clear(), this }; d._availableAttrs["class"] = ""; d.svg && n.on("raphael.attr.class", function (a) { var b = this.node; a = a || ""; b.setAttribute("class", "group" === this.type && this._id ? "raphael-group-" + this.id + "-" + this._id + " " + a : a) }); d.vml && n.on("raphael.attr.class",
function (a) { var b = this.paper, c = "." + a, b = b._stylesheet && b._stylesheet.rules, l = this.parent, g = {}; this.node.className = "group" === this.type ? a && this._id + " " + a || this._id : "rvml " + a; if (c && b) { a = b[c]; for (d.extend(g, a); l.attr; ) { if (a = l.attr("class")) c = "." + a + " " + c, a = b[c], d.extend(g, a); l = l.parent } this.css(g) } }); l.css = function (a, c) {
    var l, t, g, k; if (this.removed) return this; this.styles || (this.styles = {}); if (null == c && d.is(a, "string")) {
        l = a.split(b); t = {}; k = 0; for (g = l.length; k < g; k++) a = l[k], a in this.styles && (t[a] = this.styles[a]);
        return g - 1 ? t : t[l[0]]
    } if (null == c && d.is(a, "array")) { t = {}; k = 0; for (g = a.length; k < g; k++) t[a[k]] = this.styles(a[k]); return t } null != c ? (l = {}, l[a] = c) : null != a && d.is(a, "object") && (l = a); t = {}; for (k in l) g = k.replace(/\B([A-Z]{1})/g, "-$1").toLowerCase(), d._availableAttrs.hasOwnProperty(g) || "color" === g ? ("color" === g && "text" === this.type && (g = "fill"), t[g] = l[k], t.dirty = !0) : (n("raphael.css." + g + "." + this.id, this, l[k], g), this.node.style[g] = l[k], this.styles[g] = l[k]); k = 0; for (g = this.followers.length; k < g; k++) this.followers[k].el.attr(l);
    t.hasOwnProperty("dirty") && (delete t.dirty, this.attr(t)); return this
} 
} ]);
FusionCharts.register("module", ["private", "modules.renderer.js-raphaelexport", function () {
    var d = this.hcLib, n = d.Raphael, E = d.pluckNumber, u = d.pluck, l = n._availableAttrs, b = /^matrix\(|\)$/g, P = /\,/g, c = /\n|<br\s*?\/?>/ig, J = /[^\d\.]/ig, a = /[\(\)\s,\xb0#]/g, B = /group/ig, N = /&/g, t = /"/g, g = /'/g, k = /</g, f = />/g, h = 0; (function (d) {
        var n = Math, m = parseFloat, z = n.max, H = n.abs, M = n.pow, $ = String, C = /[, ]+/, V = [{ reg: /xmlns\=\"http\:\/\/www.w3.org\/2000\/svg\"/ig, repStr: "" }, { reg: /^.*<svg /, repStr: '<svg xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" ' },
{ reg: /\/svg>.*$/, repStr: "/svg>" }, { reg: /<desc\>[^<]*<\/desc\>/, repStr: "" }, { reg: /zIndex="[^"]+"/g, repStr: "" }, { reg: /url\((\\?[\'\"])[^#]+#/g, repStr: "url($1#" }, { reg: / href=/g, repStr: " xlink:href=" }, { reg: /(id|class|width|height)=([^" >]+)/g, repStr: '$1="$2"' }, { reg: /:(path|rect)/g, repStr: "$1" }, { reg: /<ima?ge? ([^\>]+?)[^\/]\>/gi, repStr: "<image $1 />" }, { reg: /<\/ima?ge?\>/g, repStr: "" }, { reg: /style="([^"]+)"/g, repStr: function (a) { return a.toLowerCase() } }], ba = { blur: function () { }, transform: function () { }, src: function (a,
b) { b.attrSTR += ' xlink:href="' + b.attrs.src + '"' }, path: function (a, b) { var c = b.attrs.path, c = d._pathToAbsolute(c || ""); b.attrSTR += ' d="' + (c.toString && c.toString() || "").replace(P, " ") + '"' }, gradient: function (b, c, f) {
    var g = b.attrs.gradient, h = "linear", w, k, l, C = 0.5, B = 0.5, I = k = "", G = ""; w = g.replace(a, "_"); if (!f[w]) {
        g = $(g).replace(d._radial_gradient, function (a, b) {
            var c, d; b = b && b.split(",") || []; h = "radial"; c = b[3]; d = b[4]; c && d && (C = m(c), B = m(d), c = 2 * (0.5 < B) - 1, 0.25 < M(C - 0.5, 2) + M(B - 0.5, 2) && (B = n.sqrt(0.25 - M(C - 0.5, 2)) * c + 0.5) && 0.5 !=
B && (B = B.toFixed(5) - 1E-5 * c)); return ""
        }); g = g.split(/\s*\-\s*/); if ("linear" === h) { k = g.shift(); k = -m(k); if (isNaN(k)) return null; l = [0, 0, n.cos(d.rad(k)), n.sin(d.rad(k))]; k = 1 / (z(H(l[2]), H(l[3])) || 1); l[2] *= k; l[3] *= k; 0 > l[2] && (l[0] = -l[2], l[2] = 0); 0 > l[3] && (l[1] = -l[3], l[3] = 0) } g = d._parseDots(g); if (!g) return null; "radial" === h ? (k = '<radialGradient fx = "' + C + '" fy = "' + B + '" id = "' + w + '">', I = "</radialGradient>") : (k = '<linearGradient x1 = "' + l[0] + '" y1 = "' + l[1] + '" x2 = "' + l[2] + '" y2 = "' + l[3] + '" gradientTransform ="matrix(' +
b.matrix.invert() + ')" id = "' + w + '">', I = "</linearGradient>"); b = 0; for (l = g.length; b < l; b++) G += '<stop offset="' + (g[b].offset ? g[b].offset : b ? "100%" : "0%") + '" stop-color="' + (g[b].color || "#fff") + '" stop-opacity="' + (void 0 === g[b].opacity ? 1 : g[b].opacity) + '" />'; f[w] = !0; f.str += k + G + I
    } c.attrSTR += " fill=\"url('#" + w + "')\""
}, fill: function (a, b) {
    var c = b.attrs, f = c.fill, g; a.attrs.gradient || (f = d.color(f), g = f.opacity, "text" === a.type ? b.styleSTR += "fill:" + f + "; stroke-opacity:0; " : (b.attrSTR += ' fill="' + f + '"', c["fill-opacity"] ||
!g && 0 !== g || (b.attrSTR += ' fill-opacity="' + g + '"')))
}, stroke: function (a, b) { var c = b.attrs, f, g; f = d.color(c.stroke); g = f.opacity; "text" !== a.type && (b.attrSTR += ' stroke="' + f + '"', c["stroke-opacity"] || !g && 0 !== g || (b.attrSTR += ' stroke-opacity="' + g + '"')) }, "clip-rect": function (c, d, f) {
    var g = $(d.attrs["clip-rect"]), k = g.split(C), g = g.replace(a, "_") + "__" + h++; 4 === k.length && (f[g] || (f[g] = !0, f.str += '<clipPath id="' + g + '"><rect x="' + k[0] + '" y="' + k[1] + '" width="' + k[2] + '" height="' + k[3] + '" transform="matrix(' + c.matrix.invert().toMatrixString().replace(b,
"") + ')"/></clipPath>'), d.attrSTR += ' clip-path="url(#' + g + ')"')
}, cursor: function (a, b) { var c = b.attrs.cursor; c && (b.styleSTR += "cursor:" + c + "; ") }, font: function (a, b) { b.styleSTR += "font:" + b.attrs.font.replace(/\"/ig, " ") + "; " }, "font-size": function (a, b) { var c = u(b.attrs["font-size"], "10"); c && c.replace && (c = c.replace(J, "")); b.styleSTR += "font-size:" + c + "px; " }, "font-weight": function (a, b) { b.styleSTR += "font-weight:" + b.attrs["font-weight"] + "; " }, "font-family": function (a, b) {
    b.styleSTR += "font-family:" + b.attrs["font-family"] +
"; "
}, "line-height": function () { }, "clip-path": function () { }, visibility: function () { }, "vertical-align": function () { }, "text-anchor": function (a, b) { var c = b.attrs["text-anchor"] || "middle"; "text" === a.type && (b.attrSTR += ' text-anchor="' + c + '"') }, title: function () { }, text: function (a, b) {
    var d = b.attrs, h = d.text, z = u(d["font-size"], d.font, "10"), w = u(d["line-height"]), l, s, m; z && z.replace && (z = z.replace(J, "")); z = E(z); w && w.replace && (w = w.replace(J, "")); w = E(w, z && 1.2 * z); l = z ? 0.85 * z : 0.75 * w; z = d.x; s = u(d["vertical-align"], "middle").toLowerCase();
    h = $(h).split(c); m = h.length; d = 0; for (l = "top" === s ? l : "bottom" === s ? l - w * m : l - w * m * 0.5; d < m; d++) b.textSTR += "<tspan ", s = (h[d] || "").replace(N, "&amp;").replace(t, "&quot;").replace(g, "&#39;").replace(k, "&lt;").replace(f, "&gt;"), b.textSTR = d ? b.textSTR + ('dy="' + w + '" x="' + z + '" ') : b.textSTR + ('dy="' + l + '"'), b.textSTR += ">" + s + "</tspan>"
} 
}, da = function (a, c) {
    var d = "", f = { attrSTR: "", styleSTR: "", textSTR: "", attrs: a.attr() }, g = a.isShadow, w = "", k = "", h, z, s = f.attrs; if ("none" === a.node.style.display || g) a.next && (d += da(a.next, c)); else {
        for (h in s) if ("gradient" !==
h && (void 0 !== l[h] || ba[h]) && void 0 !== s[h]) if (ba[h]) ba[h](a, f, c); else f.attrSTR += " " + h + '="' + s[h] + '"'; a.attrs.gradient && ba.gradient(a, f, c); "rect" === a.type && s.r && (f.attrSTR += ' rx="' + s.r + '" ry="' + s.r + '"'); for (z in a.styles) f.styleSTR += z + ":" + a.styles[z] + "; "; "image" === a.type && (f.attrSTR += ' preserveAspectRatio="none"'); if ("text" === a.type && !s["text-anchor"]) ba["text-anchor"](a, f); a.bottom && (w = da(a.bottom, c)); a.next && (k = da(a.next, c)); g = a.type; g.match(B) && (g = "g"); d += "<" + g + ' transform="matrix(' + a.matrix.toMatrixString().replace(b,
"") + ')" style="' + f.styleSTR + '"' + f.attrSTR + ">" + f.textSTR + w + "</" + g + ">" + k
    } return d
}; d.fn.toSVG = function (a) {
    var b = "", c = { str: "" }, f = 0, g = V.length, w = ""; if (d.svg) { if (this.canvas && this.canvas.parentNode) for (b = this.canvas.parentNode.innerHTML; f < g; f += 1) c = V[f], b = b.replace(c.reg, c.repStr) } else b = '<svg style="overflow: hidden; position: relative;" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="' + this.width + '" version="1.1" height="' + this.height + '">', this.bottom && (w = da(this.bottom,
c)), b += "<defs>" + c.str + "</defs>" + w + "</svg>"; a || (b = b.replace(/<image [^\>]*\>/gi, "")); return b
} 
    })(n)
} ]);
FusionCharts.register("module", ["private", "modules.renderer.js-raphaelshadow", function () {
    var d = this.window, n = d.Math.sqrt, E = d.parseFloat, u = d.parseInt, d = d.SVGFilterElement || d.SVGFEColorMatrixElement && 2 === d.SVGFEColorMatrixElement.SVG_FECOLORMATRIX_TYPE_SATURATE, l = this.hcLib.Raphael, b = { "drop-shadow": "drop-shadow", stroke: "stroke", fill: "fill", "stroke-width": "stroke-width", "stroke-opacity": "stroke-opacity", "stroke-linecap": "stroke-linecap", "stroke-linejoin": "stroke-linejoin", "shape-rendering": "shape-rendering",
        transform: "transform"
    }, P = l._createNode, c; l.svg ? (d && (l.el.dropshadow = function (b, a, c, d) {
        var t = this.node, g = this._.shadowFilter, k = this.paper.cacheShadows || (this.paper.cacheShadows = {}), f = "drop-shadow" + [b, a, c, d].join(" "), h; if ("none" === b) { if (g) { g.use -= 1; this.node.removeAttribute("filter"); if (!g.use) { f = g.hash; for (h in g) b = g[h], b.parentNode && b.parentNode.removeChild(b), delete g[h]; delete k[f] } delete this._.shadowFilter } } else g && k[f] === g || (g = this.paper.defs.appendChild(P("filter", { id: l.createUUID(), width: "200%",
            height: "200%"
        })), d = l.color(d), d.error && (d = l.color("rgba(0,0,0,1)")), h = l.pick(d.opacity, 1), this._.shadowFilter = k[f] = { use: 1, filter: g, hash: f, offset: g.appendChild(P("feOffset", { result: "offOut", "in": "SourceGraphic", dx: E(b), dy: E(a) })), matrix: g.appendChild(P("feColorMatrix", { result: "matrixOut", "in": "offOut", type: "matrix", values: "0 0 0 0 " + d.r / 255 + " 0 0 0 0 " + d.g / 255 + " 0 0 0 0 " + d.b / 255 + " 0 0 0 " + h + " 0" })), blur: g.appendChild(P("feGaussianBlur", { result: "blurOut", "in": "matrixOut", stdDeviation: n(E(c)) })), blend: g.appendChild(P("feComposite",
{ "in": "SourceGraphic", in2: "blurOut", operator: "over" }))
        }, t.setAttribute("filter", 'url("' + l._url + "#" + g.id + '")')); return this
    }), c = function (c, a) { var d = this.__shadowscale, l = {}, n, g; for (g in c) switch (b[g] && (l[g] = c[g], delete c[g]), g) { case "transform": n = a.matrix.clone(); n.translate(this.__shadowx, this.__shadowy); this.transform(n.toTransformString()); break; case "stroke-width": c[g] = ((l[g] || 1) + 6 - 2 * this.__shadowlevel) * d } this.attr(c); for (g in l) c[g] = l[g] }, l.ca["drop-shadow"] = function (b, a, d, n, t, g) {
        d = this._.shadows ||
(this._.shadows = []); var k, f, h, s, E; if (!this.__shadowblocked) if ("none" === b) for (; f = d.pop(); ) f.remove(); else for (n = l.color(n), n.error && (n = l.color("rgba(0,0,0,1)")), t instanceof Array ? (k = t[0], t = t[1]) : k = t, k = 1 / l.pick(k, 1), t = 1 / l.pick(t, 1), b = l.pick(b, 1) * k, a = l.pick(a, 1) * k, k = 0.05 * l.pick(n.opacity, 1), h = u(this.attr("stroke-width") || 1, 10) + 6, s = this.matrix.clone(), s.translate(b, a), E = 1; 3 >= E; E++) f = (d[E - 1] || this.clone().follow(this, c, !g && "before")).attr({ stroke: n.hex, "stroke-opacity": k * E, "stroke-width": (h - 2 * E) * t, transform: s.toTransformString(),
    "stroke-linecap": "round", "stroke-linejoin": "round", fill: "none"
}), f.__shadowlevel = E, f.__shadowscale = t, f.__shadowx = b, f.__shadowy = a, g && g.appendChild(f), d.push(f); return !1
    }, l.el.shadow = function (b, a, c, d) {
        var n; c && c.constructor === l.el.constructor && (d = c, c = void 0); "object" === typeof b && (a && a.constructor === l.el.constructor && (d = a), a = b.opacity, c = b.scalefactor, n = !!b.useFilter, b = void 0 === b.apply ? !!a : b.apply); void 0 === a && (a = 1); if (this.dropshadow) {
            if (n) return b && this.dropshadow(1, 1, 3, "rgb(64,64,64)") || this.dropshadow("none"),
this; this._.shadowFilter && this.dropshadow("none")
        } return this.attr("drop-shadow", b ? [1, 1, 3, "rgba(64,64,64," + a + ")", c, d] : "none")
    }) : l.vml ? (l.ca["drop-shadow"] = function (b, a, c, d, n, g) {
        var k = this._.shadow, f, h; if (this.isShadow) return !1; "none" === b ? k && (this._.shadow = k.remove()) : (k || (k = this._.shadow = this.clone(), g && g.appendChild(k.follow(this)) || k.follow(this, void 0, "before"), k.attr({ fill: "none", "fill-opacity": 0.5, "stroke-opacity": 1 }).isShadow = !0, 0 >= k.attr("stroke-width") && k.attr("stroke-width", 1)), g = k.node.runtimeStyle,
f = g.filter.replace(/ progid:\S+Blur\([^\)]+\)/g, ""), d = l.color(d), d.error && (d = l.color("rgba(0,0,0,1)")), h = l.pick(d.opacity, 1) / 5, n = 1 / l.pick(n, 1), b = l.pick(b, 1) * n, a = l.pick(a, 1) * n, k.translate(b, a), g.filter = f + " progid:DXImageTransform.Microsoft.Blur(pixelRadius=" + E(0.4 * c) + " makeShadow=True Color=" + d.hex + ' shadowOpacity="' + h + '");'); return !1
    }, l.el.shadow = function (b, a, c, d) {
        c && c.constructor === l.el.constructor && (d = c, c = void 0); "object" === typeof b && (a && "group" === a.type && (d = a), a = b.opacity, c = b.scalefactor, b = void 0 ===
b.apply ? !!a : b.apply); void 0 === a && (a = 1); return this.attr("drop-shadow", b || !a ? [1, 1, 5, "rgba(64,64,64," + a + ")", c, d] : "none")
    }) : l.canvas && (l.el.shadow = function () { return this })
} ]);
FusionCharts.register("module", ["private", "modules.renderer.js-raphaelshapes", function () {
    var d = this.window, n = "createTouch" in d.document, E = /msie/i.test(d.navigator.userAgent) && !d.opera, u = d.Math, l = u.cos, b = u.sin, P = u.abs, c = u.pow, J = u.atan2, a = u.min, B = u.round, N = u.PI, t = 2 * N, g = d.parseInt, k = d.parseFloat, f = String, h = Array.prototype.slice, s = c(2, -24), sa = "rgba(192,192,192," + (E ? 0.002 : 1E-6) + ")", m = this.hcLib.Raphael, z = m.eve, H = m._createNode, M = m._setFillAndStroke, $ = m.el.constructor, C = { speed: "optimizeSpeed", crisp: "crispEdges",
        precision: "geometricPrecision"
    }, V = { enabled: !1, "false": !1, 0: !1, disabled: !0, "true": !0, 1: !0 }, ba = { Q: "L", Z: "X", q: "l", z: "x", ",": " " }, da = /,?([achlmqrstvxz]),?/gi, xa = /\s*\,\s*/g, ua, S = function () { return this.join(",").replace(da, ua) }, ca, ha; if (m.svg) z.on("raphael.attr.shape-rendering", function (a, b) { var c = this.node; this.attrs[b] = a = C[a] || a || "auto"; c.setAttribute(b, a); c.style.shapeRendering = a }); else if (m.vml) z.on("raphael.attr.shape-rendering", function (a) { this.node.style.antialias = "crisp" !== a }); m.define && m.define([{ name: "polypath",
        polypath: function () { return this.path(void 0, m._lastArgIfGroup(arguments)) }, ca: { polypath: function (a, c, d, f, h, I) {
            var z, s, C; z = []; a = g(a, 10) || 0; c = k(c) || 0; d = k(d) || 0; f = k(f) || 0; h = null === h || isNaN(h) ? 0.5 * N : m.rad(h); I = null === I || isNaN(I) ? 0 : k(I); s = h; if (2 < a) switch (h = 2 * N / a, I) {
                case 0: for (I = 0; I < a; I++) z.push("L", c + f * l(-s), d + f * b(-s)), s += h; z[0] = "M"; z.push("Z"); break; case 1: for (I = 0; I < a; I++) z.push("M", c, d, "L", c + f * l(-s), d + f * b(-s)), s += h; break; default: h *= 0.5; C = f * l(h) * (1 - I); for (I = 0; I < a; I++) z.push("L", c + f * l(-s), d + f * b(-s)), s +=
h, z.push("L", c + C * l(-s), d + C * b(-s)), s += h; z[0] = "M"; z.push("Z")
            } else 0 === f ? z.push("M", c, d, "L", c, d, "Z") : z.push("M", c - f, d, "A", f, f, 0, 0, 0, c + f, d, "A", f, f, 0, 0, 0, c - f, d, "Z"); return { path: z}
        }, r: function (a) { var b = this.attrs.polypath; b[3] = a; this.attr("polypath", b); return !1 } 
        }
    }, { name: "ringpath", ringpath: function () { return this.path(void 0, m._lastArgIfGroup(arguments)) }, ca: function (a, c, d, f, g, h) {
        var k = h % t - g % t, z = h - g, m; this._.ringangle = 0.5 * (g + h); P(z) < s ? (z = l(g), g = b(g), d = ["M", a + d * z, c + d * g, "L", a + f * z, c + f * g, "Z"]) : (P(z) > s && P(z) %
t < s ? (d = ["M", a - d, c, "A", d, d, 0, 0, 0, a + d, c, "A", d, d, 0, 0, 0, a - d, c], 0 !== f && (d = d.concat(["M", a - f, c, "A", f, f, 0, 0, 1, a + f, c, "A", f, f, 0, 0, 1, a - f, c]))) : (z = l(g), g = b(g), m = l(h), h = b(h), k %= t, 0 > k && (k += t), k = k < N ? 0 : 1, d = ["M", a + d * z, c + d * g, "A", d, d, 0, k, 1, a + d * m, c + d * h, "L", a + f * m, c + f * h], 0 !== f && d.push("A", f, f, 0, k, 0, a + f * z, c + f * g)), d.push("Z")); return { path: d}
    } 
    }, { name: "cubepath", cubepath: function () {
        var a = { "stroke-linejoin": "round", "shape-rendering": "precision", stroke: "none" }, b = arguments, c = b.length - 1, d = b[c], f, g; d && d.constructor === m.el.constructor ?
b[c] = void 0 : d = void 0; c = this.path(a, d); f = this.path(a, d); a = this.path(a, d); a._.cubetop = c.follow(a, void 0, "before"); a._.cubeside = f.follow(a, void 0, "before"); for (g in m.fn.cubepath.ca) a.ca[g] = m.fn.cubepath.ca[g]; return a.attr("cubepath", [b[0], b[1], b[2], b[3], b[4], b[5]])
    }, fn: { _getBBox2: function () { var a = this._.cubeside.getBBox(), b = this._.cubetop.getBBox(), c = this.getBBox(); return { x: c.x + b.height, y: c.y - a.width, width: c.width, height: c.height} } }, ca: { cubepath: function (a, b, c, d, f, g) {
        var h = this._.cubetop, k = this._.cubeside;
        a = a || 0; b = b || 0; c = c || 0; d = d || 0; f = f || 0; g = g || 0; this.attr("path", ["M", a + c, b, "l", 0, d, -c, 0, 0, -d, "z"]); h.attr("path", ["M", a, b, "l", 1, 1, c - 1, 0, 0, -1, f, -g, -c, 0, "z"]); k.attr("path", ["M", a + c - 1, b + 1, "l", 0, d - 1, 1, 0, f, -g, 0, -d, -f, g]); return !1
    }, "stroke-linejoin": function () { return { "stroke-linejoin": "round"} }, "drop-shadow": function (a, b, c, d) { var f = this._.cubetop, g = this._.cubeside; this.dropshadow && (f.dropshadow(a, -b, c, d), g.dropshadow(a, -b, c, d)); return !1 }, fill: function (a, b) {
        var c = this._.cubetop, d = this._.cubeside, f = this.attr("cubepath") ||
[0, 0, 0, 0, 0, 0], g = f[2], h = f[4], f = f[5], k; a = m.color(a); b ? (this.attr("fill", a), c.attr("fill", m.tintshade(a, -0.78).rgba), d.attr("fill", m.tintshade(a, -0.65).rgba)) : (k = "opacity" in a ? "rgba(" + [a.r, a.g, a.b, a.opacity] + ")" : "rgb(" + [a.r, a.g, a.b] + ")", this.attr("fill", [270, m.tintshade(k, 0.55).rgba, m.tintshade(k, -0.65).rgba].join("-")), d.attr("fill", [270, m.tintshade(k, -0.75).rgba, m.tintshade(k, -0.35).rgba].join("-")), c.attr("fill", [45 + m.deg(J(f, h + g)), m.tintshade(k, -0.78).rgba, m.tintshade(k, 0.22).rgba].join("-"))); return !1
    } 
    }
    },
{ name: "scroller", scroller: function (a, b, c, d, f, g, h) {
    var l = this.group("scroller", h), s = l.attrs, C = l._.scroller = {}; f = f && "horizontal" || "vertical"; var M, n = {}, H, B, S; C.track = this.rect(l).mousedown(function (a) { var b = s["scroll-position"]; a = "horizontal" === s["scroll-orientation"] ? a.layerX || a.x : a.layerY || a.y; a = (a - C.anchorOffset) / C.trackLength; M = m.animation({ "scroll-position": a }, 2E3 * P(b - a), "easeIn"); l.animate(M); z("raphael.scroll.start." + l.id, l, b) }).mouseup(C._mouseupTrack = function () {
        this.stop(M); z("raphael.scroll.end." +
this.id, this, s["scroll-position"])
    }, l, !0); C.anchor = this.rect(l).drag(function () { n["scroll-position"] = H + arguments[B] / C.trackLength; l.animate(n, 0) }, function (a, b, c) { B = "horizontal" === s["scroll-orientation"] ? 0 : 1; z("raphael.scroll.start." + l.id, l, H = s["scroll-position"]); c.stopPropagation() }, function () { z("raphael.scroll.end." + l.id, l, H = s["scroll-position"]) }); for (S in m.fn.scroller.fn) l[S] = m.fn.scroller.fn[S]; for (S in m.fn.scroller.ca) l.ca[S] = m.fn.scroller.ca[S]; s["scroll-orientation"] = f; s["stroke-width"] =
1; l.ca["scroll-repaint"] = l.ca["scroll-repaint-" + f]; !m.is(g, "object") && (g = {}); return l.attr({ ishot: !0, "scroll-display-buttons": g.showButtons && "arrow" || "none", "scroll-display-style": g.displayStyleFlat && "flat" || "3d", "scroll-ratio": k(g.scrollRatio) || 1, "scroll-position": k(g.scrollPosition) || 0, "scroll-repaint": [a, b, c, d] })
}, fn: { scroll: function (a, b) { var c = this._.scroller; b = b || this; c.callback = function () { return a.apply(b, arguments) }; return this }, remove: function () {
    var a = this._.scroller, b; this.attr("scroll-display-buttons",
"none"); a.track.unmouseup(a._mouseupTrack); for (b in a) a[b] && a[b].remove && a[b].remove(), a[b] = null; delete this._.scroller; m.el.remove.apply(this, arguments)
} 
}, ca: { "stroke-width": function () { return !1 }, "drop-shadow": function (a, b, c, d, f, g) { this._.scroller.track.attr("drop-shadow", [a, b, c, d, f, g]); return !1 }, "scroll-display-style": function (a) {
    var b = this.attrs, c = b["scroll-display-style"], d = b.fill; a = { flat: "flat", "3d": "3d", transparent: "transparent"}[a] || c; d && a !== c && (b["scroll-display-style"] = a, this.attr("fill",
d)); return { "scroll-display-style": a}
}, "scroll-display-buttons": function (a) {
    var b = this, c = b.paper, d = b._.scroller, f = b.attrs, g = f["scroll-display-buttons"], h = f["scroll-repaint"], k, l; void 0 === g && (g = "none"); a = { none: "none", arrow: "arrow"}[a] || g; a !== g && (f["scroll-display-buttons"] = a, "none" === a && d.start ? (d.arrowstart.remove(), delete d.arrowstart, d.arrowend.remove(), delete d.arrowend, d.start.unmouseup(d._mouseupStart), d.start.remove(), delete d.start, d.end.unmouseup(d._mouseupEnd), d.end.remove(), delete d.end) :
(d.arrowstart = c.polypath(b), d.arrowend = c.polypath(b), d.start = c.rect(b).mousedown(function () { var a; 0 !== (a = f["scroll-position"]) && (b.animate({ "scroll-position": a - 0.1 }, 100).animate(k = m.animation({ "scroll-position": 0 }, 4500 * a, "easeIn")), z("raphael.scroll.start." + b.id, b, a)) }).mouseup(d._mouseupStart = function () { b.stop(k); z("raphael.scroll.end." + b.id, b, f["scroll-position"]) }, b, !0), d.end = c.rect(b).mousedown(function () {
    var a; 1 !== (a = f["scroll-position"]) && (b.animate({ "scroll-position": a + 0.1 }, 100).animate(l =
m.animation({ "scroll-position": 1 }, 4500 * (1 - a), "easeIn")), z("raphael.scroll.start." + b.id, b, a))
}).mouseup(d._mouseupEnd = function () { b.stop(l); z("raphael.scroll.end." + b.id, b, f["scroll-position"]) }, b, !0), f.fill && b.attr("fill", f.fill)), h && b.attr("scroll-repaint", h)); return { "scroll-display-buttons": a}
}, "scroll-orientation": function (a) {
    var b = this.attrs, c = b["scroll-repaint"], d = b["scroll-orientation"]; a = { horizontal: "horizontal", vertical: "vertical"}[a] || d; d !== a && (this.ca["scroll-repaint"] = this.ca["scroll-repaint-" +
a], c && (c[2] += c[3], c[3] = c[2] - c[3], c[2] -= c[3], this.attr("scroll-repaint", c)), b.fill && this.attr("fill", b.fill)); return { "scroll-orientation": a}
}, "scroll-ratio": function (a) { var b = this.attrs, c = b["scroll-ratio"], d = b["scroll-repaint"]; a = 1 < a ? 1 : 0.01 > a ? 0.01 : k(a); d && a !== c && (b["scroll-ratio"] = a, this.attr("scroll-repaint", d)); return { "scroll-ratio": a} }, "scroll-position": function (a, b) {
    var c = this.attrs, d = "horizontal" === c["scroll-orientation"], f = c["scroll-repaint"], g = c["scroll-position"], h = this._.scroller, l = h.anchor;
    a = 1 < a ? 1 : 0 > a ? 0 : k(a); isNaN(a) && (a = g); f && (g !== a || b) && (g = h.start && h.start.attr(d && "width" || "height") || 0, d && l.attr("x", f[0] + g + (f[2] - 2 * g - l.attr("width")) * a + 0.5) || l.attr("y", f[1] + g + (f[3] - 2 * g - l.attr("height")) * a + 0.5), !b && 1 > c["scroll-ratio"] && (z("raphael.scroll.change." + this.id, this, a), h.callback && h.callback(a))); return { "scroll-position": a}
}, r: function (a) { var b = this._.scroller; b.track.attr("r", a); b.anchor.attr("r", "none" === this.attrs["scroll-display-buttons"] && a || 0); return !1 }, "scroll-repaint-horizontal": function (b,
c, d, f) {
    var g = this.attrs, h = this._.scroller, k = g["scroll-ratio"], z = g["scroll-position"], l = 0, s = d * k, g = "none" === g["scroll-display-buttons"]; d && (d -= 1); b && (b += 0.5); f && (f -= 1); c && (c += 0.5); h.track.attr({ width: d, height: f, y: c, x: b }).crisp(); g || (l = a(f, 0.5 * d), s -= 2 * l * k, h.start.attr({ width: l, height: f, x: b, y: c }), h.arrowstart.attr("polypath", [3, b + 0.5 * l, c + 0.5 * f, 0.25 * l, 180]), h.end.attr({ width: l, height: f, x: b + d - l, y: c }), h.arrowend.attr("polypath", [3, b + d - 0.5 * l, c + 0.5 * l, 0.25 * l, 0])); h.trackLength = d - 2 * l - s; h.trackOffset = b + l + 0.5;
    h.anchorOffset = h.trackOffset + 0.5 * (s - 1); h.anchor.attr({ height: f, width: s - 1, y: c, x: h.trackOffset + h.trackLength * z }).crisp()
}, "scroll-repaint-vertical": function (b, c, d, f) {
    var g = this.attrs, h = this._.scroller, k = g["scroll-ratio"], z = g["scroll-position"], l = 0, s = f * k, g = "none" === g["scroll-display-buttons"]; d && (d -= 1); b && (b += 0.5); f && (f -= 1); c && (c += 0.5); h.track.attr({ width: d, height: f, y: c, x: b }).crisp(); g || (l = a(d, 0.5 * f), s -= 2 * l * k, h.start.attr({ width: d, height: l, x: b, y: c }), h.arrowstart.attr("polypath", [3, b + 0.5 * d, c + 0.5 * l, 0.25 *
l, 90]), h.end.attr({ width: d, height: l, x: b, y: c + f - l }), h.arrowend.attr("polypath", [3, b + 0.5 * d, c + f - 0.5 * l, 0.25 * l, -90])); h.trackLength = f - 2 * l - s; h.trackOffset = c + l + 0.5; h.anchorOffset = h.trackOffset + 0.5 * (s - 1); h.anchor.attr({ height: s - 1, width: d, y: h.trackOffset + h.trackLength * z, x: b }).crisp()
}, fill: function (a) {
    var b = this.attrs, c = this._.scroller, d = b["scroll-repaint"], f = "flat" === b["scroll-display-style"], g = "horizontal" === b["scroll-orientation"], h = { stroke: "none" }, k; n && d && 3 < (k = 16 - d[g && 3 || 2]) && (h.stroke = sa, h["stroke-width"] =
k); a = m.color(a); a.error && (a = "#000000"); a = "opacity" in a ? "rgba(" + [a.r, a.g, a.b, a.opacity] + ")" : "rgb(" + [a.r, a.g, a.b] + ")"; h.fill = f && a || [90 * g, m.tintshade(a, 0.15).rgba, a].join("-"); h.stroke = m.tintshade(a, -0.75).rgba; c.track.attr(h); h.fill = f && m.tintshade(a, -0.6).rgba || [270 * g, m.tintshade(a, 0.3).rgba + ":40", m.tintshade(a, -0.7).rgba].join("-"); h.stroke = m.tintshade(a, -0.6).rgba; c.anchor.attr(h); h.stroke = "none"; "none" !== b["scroll-display-buttons"] && (h.fill = sa, c.start.attr(h), c.end.attr(h), h.fill = m.tintshade(a, -0.4).rgba,
c.arrowstart.attr(h), c.arrowend.attr(h)); return !1
} 
}
}, { name: "button", button: function (a, b, c, d, f, g) {
    g = this.group("button", g); var h; g._.button = { bound: this.rect(g), tracker: this.rect(g).attr({ fill: sa, stroke: sa, cursor: "pointer" }).data("compositeButton", g) }; !m.is(f, "object") && (f = {}); for (h in m.fn.button.fn) g[h] = m.fn.button.fn[h]; for (h in m.fn.button.ca) g.ca[h] = m.fn.button.ca[h]; return g.attr({ ishot: !0, "button-padding": [f.horizontalPadding, f.verticalPadding], "button-label": c, "button-symbol": d, "button-disabled": f.disabled ||
"false", "button-symbol-position": f.symbolPosition, "button-symbol-padding": f.symbolPadding
    }).attr("button-repaint", [a, b, f.width, f.height, f.r])
}, data: { hoverin: function () { var a = this._.button.hoverbackIn; a && !1 === a() || (this.attr("fill", "hover").hovered = !0) }, hoverout: function () { var a = this._.button.hoverbackOut; a && !1 === a() || (this.attr("fill", (this.pressed || this.active) && "active" || "normal").hovered = !1) }, mousedown: function () { this.attr("fill", "active").pressed = !0 }, mouseup: function () {
    var a = this._.button.callback;
    this.attr("fill", this.hovered && "hover" || this.active && "active" || "normal").pressed = !1; a()
} 
}, fn: { tooltip: function () { m.el.tooltip && m.el.tooltip.apply(this._.button.tracker, arguments); return this }, buttonclick: function (a, b) { var c = this._.button; b = b || this; c.callback = function () { return a.apply(b, arguments) }; return this }, labelcss: function () { var a = this._.button, b = a.label; a.cssArg = arguments; b && b.css.apply(b, arguments); return this }, buttonhover: function (a, b, c, d) {
    var f = this._.button; c = c || this; d = d || this; f.hoverbackIn =
function () { return a.apply(c, arguments) }; f.hoverbackOut = function () { return b.apply(d, arguments) }; return this
}, remove: function () { var a = this._.button, b; this.attr("button-disabled", "true"); for (b in a) a[b] && a[b].remove && a[b].remove(), a[b] = null; delete this._.button; m.el.remove.apply(this, arguments) } 
}, ca: { "button-active": function (a) { this.attr("fill", (this.active = !!a) ? "active" : this.hovered && "hover" || "normal") }, "button-disabled": function (a) {
    var b = this._.button.tracker, c = this.attrs["button-disabled"], d = this.paper.button.data;
    a = V[a]; c = V[c]; if (void 0 !== a && a !== c) switch (a) { case !0: b.attr("fill", "rgba(204,204,205,.5)").unmousedown(d.mousedown).unmouseup(d.mouseup).unhover(d.hoverin, d.hoverout); break; case !1: b.attr("fill", sa).mousedown(d.mousedown, this).mouseup(d.mouseup, this, !0).hover(d.hoverin, d.hoverout, this, this) } 
}, "button-label": function (a) {
    var b = this._.button, c = this.attrs, d = b.label, g = b.cssArg, h = this.attrs["button-repaint"]; a = f(a || ""); "none" === a ? d && (b.label = d.remove()) : a && (!d && (d = b.label = this.paper.text(this).insertBefore(b.tracker)),
d.attr({ text: a, "text-anchor": "start", "vertical-align": "top" }), g && g.length && d.css.apply(d, g)); h && c["button-label"] !== a && this.attr("button-repaint", h)
}, "button-symbol": function (a) { var b = this.attrs, c = this._.button, d = c.symbol, g = this.attrs["button-repaint"]; a = f(a || ""); "none" === a ? d && (c.symbol = d.remove()) : a && !d && (c.symbol = this.paper.symbol(this).insertAfter(c.bound)); g && b["button-symbol"] !== a && this.attr("button-repaint", g) }, "button-symbol-position": function (a) {
    return { "button-symbol-position": { top: "top",
        right: "right", bottom: "bottom", left: "left", none: "none"
    }[f(a).toLowerCase()] || "none"
    }
}, "button-symbol-padding": function (a) { return { "button-symbol-padding": k(a)} }, "button-padding": function (a, b) { return { "button-padding": [null == a && (a = 5) || k(a), null == b && a || k(b)]} }, "button-repaint": function (b, c, d, f, g) {
    var h = this._.button, k = h.bound, l = h.label, z = h.symbol, s = this.attrs, C = s["button-padding"], M = C[0], n = C[1], H; void 0 === b && (b = 0); void 0 === c && (c = 0); if (void 0 === d || void 0 === f) H = l && l.getBBox() || { width: 0, height: 0 }, void 0 ===
d && (d = 2 * M + H.width), void 0 === f && (f = 2 * n + H.height); k = m.crispBound(b, c, d, f, k.attr("stroke-width")); k.r = m.pick(g, B(0.1 * a(f, d))); b = k.x; c = k.y; d = k.width; f = k.height; l && l.attr({ x: b + M, y: c + n }); if (z) {
        !m.is(H = s["button-symbol-padding"], "finite") && (H = 0.2 * f); g = 0.5 * (f - n); switch (s["button-symbol-position"] + (l && "+" || "-")) {
            case "right+": b = b + (d + (2 * g + n)) - g - M; c += 0.5 * f; break; case "left+": b = b + M + g; c += 0.5 * f; l.attr("x", b + g + H); break; case "top+": b += 0.5 * d; c = c + C[1] + g; l && l.attr("y", c + g + H); break; case "bottom+": b += 0.5 * d; c = c + (f + (2 *
g + H)) - n - g; break; default: b += 0.5 * d, c += 0.5 * f
        } z.attr("symbol", [s["button-symbol"], b, c, g])
    } h.bound.attr(k); h.tracker.attr(k)
}, fill: function (a, b, c, d) {
    var f = this._.button, g = f.bound, h = f.symbol, k = f.label, l = { normal: f.gradient, active: f.gradientActive, hover: f.gradientHover}[a]; l || (a = m.getRGB(a), a.error && (a = m.color("#cccccc")), a = "opacity" in a ? "rgba(" + [a.r, a.g, a.b, a.opacity] + ")" : "rgb(" + [a.r, a.g, a.b] + ")", f.gradient = [90, m.tintshade(a, -0.8).rgba + ":0", m.tintshade(a, 0.8).rgba + ":100"].join("-"), f.gradientActive = [270,
m.tintshade(a, -0.8).rgba + ":0", m.tintshade(a, 0.8).rgba + ":100"].join("-"), d = m.getRGB(d), d.error && (d = a) || (d = "opacity" in d ? "rgba(" + [d.r, d.g, d.b, d.opacity] + ")" : "rgb(" + [d.r, d.g, d.b] + ")"), f.gradientHover = [90, m.tintshade(d, -0.9).rgba + ":0", m.tintshade(d, 0.7).rgba + ":100"].join("-"), c = c || m.tintshade(a, 0.2).rgba, b = b || m.tintshade(a, -0.2).rgba, f.symbolFill = c, f.labelFill = b, l = (this.pressed || this.active) && f.gradientActive || this.hovered && f.gradienthover || f.gradient); g.attr("fill", l); h && h.attr("fill", f.symbolFill);
    k && k.attr("fill", f.labelFill); return !1
}, stroke: function (a, b) { var c = this._.button, d = c.symbol; a = m.color(a); a.error && (a = m.color("#999999")); c.bound.attr("stroke", a); d && d.attr("stroke", b || a); return !1 }, "stroke-width": function (a, b) { var c = this._.button, d = c.symbol; c.bound.attr("stroke-width", a); c.tracker.attr("stroke-width", a); d && d.attr("stroke-width", b); return !1 } 
}
}]); m.ca["text-bound"] = function (a, b, c, d, f, g) {
    d = this.paper; var h = this._.textbound; if ("text" === this.type) {
        if (!(b && "none" !== b || a && "none" !== a)) return this._.textbound =
h && h.unfollow(this).remove(), !1; c && m.is(c, "finite") || (c = 0); f && m.is(f, "finite") || (f = 0); !h && (h = this._.textbound = d.rect(0, 0, 0, 0, this.group).follow(this, m.ca["text-bound"].reposition, "before")); h.attr({ stroke: b, "stroke-width": c, fill: a, "shape-rendering": 1 === c && "crisp" || "", r: f }); g && h.attr("stroke-dasharray", g); m.ca["text-bound"].reposition.call(h, this.attr(), this); return !1
    } 
}; m.ca["text-bound"].reposition = function (a, b) {
    var c = {}, d, g, h, l, z; a.hasOwnProperty("visibility") && this.attr("visibility", a.visibility);
    if (a.hasOwnProperty("text-bound") || a.hasOwnProperty("x") || a.hasOwnProperty("y") || a.hasOwnProperty("text") || a.hasOwnProperty("text-anchor") || a.hasOwnProperty("text-align") || a.hasOwnProperty("font-size") || a.hasOwnProperty("line-height") || a.hasOwnProperty("vertical-align") || a.hasOwnProperty("transform") || a.hasOwnProperty("rotation")) d = b.attrs["text-bound"], g = f(d && d[3] || "0").split(xa), d = k(g[0]) || 0, g = m.pick(k(g[1]), d), h = b.getBBox(), l = h.width, z = h.height, isNaN(l) || (c.x = h.x - d, c.y = h.y - g, c.width = l + 2 * d, c.height =
z + 2 * g), this.attr(c)
}; m.fn.symbol = function () { var a = arguments, b = a.length - 1, c = a[b]; c && c.constructor === m.el.constructor ? a[b] = void 0 : c = void 0; b = this.path(void 0, c); b.ca.symbol = m.fn.symbol.ca.symbol; return a.length === !!c + 0 ? b : b.attr("symbol", a) }; m.fn.symbol.cache = { "": m._cacher(function (a, b, c, d) { return 3 < arguments.length ? ["M", a, b, "h", c, "v", d, "h", -c, "v", -d, "z"] : ["M", a - c, b - c, "h", c *= 2, "v", c, "h", -c, "v", -c, "z"] }) }; m.fn.symbol.ca = { symbol: function (a) {
    var b = m.is(a, "object") && 1 === arguments.length && !m.is(a, "function") ?
a : arguments, c; b === a && (a = b[0]); b = (c = m.is(a, "function") && a || m.fn.symbol.cache[a] || m.fn.symbol.cache[""]) && c.apply(m, h.call(b, 1)); m.is(b, "array") || m.is(b, "string") ? this.attr("path", b) : b && this.attr(b)
} 
}; m.addSymbol = function (a, b) { var c = m.is(b, "function") && (c = {}, c[a] = b, c) || a, d = m.fn.symbol.cache, f = [], g; for (g in c) b = c[g], d[g] = m.is(b, "function") && m._cacher(b, m) || (f.push(g), b); for (; g = f.pop(); ) d[g] = d[d[g]] }; m.svg ? (ua = "$1", ca = function (a) {
    a ? "string" === typeof a ? a = a.replace(da, ua) : a.toString = S : a = "M0,0"; this.node.setAttribute("d",
a.toString()); return this
}, m._engine.litepath = function (a, b, c, d) { a = H("path"); (d || b).canvas.appendChild(a); b = new $(a, b, d); b.type = "litepath"; b.id = a.raphaelid = m._oid++; a.raphael = !0; M(b, { fill: "none", stroke: "#000" }); return b }, m._getPath.litepath = function (a) { return m.parsePathString(a.node.getAttribute("d")) }) : m.vml && (ua = function (a, b) { return ba[b] || b }, ha = function () { this._transform.apply(this, arguments); this._.bcoord && (this.node.coordsize = this._.bcoord); return this }, ca = function (a) {
    a ? "string" === typeof a ? a =
a.replace(da, ua) : a.toString = S : a = "M0,0"; this.node.path = a; return this
}, m._engine.litepath = function (a, b, c, d) {
    a = H("shape"); var f = a.style, g = new $(a, b, d); f.cssText = "position:absolute;left:0;top:0;width:21600px;height:21600px;"; c = k(c); isNaN(c) ? a.coordsize = "21600 21600" : (g._.bzoom = c, f.width = "1px", f.height = "1px", a.coordsize = g._.bcoord = c + " " + c); a.coordorigin = b.coordorigin; g.type = "litepath"; g.id = a.raphaelid = m._oid++; a.raphael = !0; g._transform = g.transform; g.transform = ha; m._setFillAndStroke(g, { fill: "none", stroke: "#000" });
    (d || b).canvas.appendChild(a); b = H("skew"); b.on = !0; a.appendChild(b); g.skew = b; return g
}, m._getPath.litepath = function (a) { return m.parsePathString(a.node.path || "") }); m.fn.litepath = function (a, b, c) { b && b.constructor === $ && (c = b, b = void 0); a && a.constructor === $ && (c = a, a = ""); b = m._engine.litepath(a, this, b, c); b.ca.litepath = ca; a && b.attr("litepath", m.is(a, "array") ? [a] : a); return this.__set__ && this.__set__.push(b), this._elementsById[b.id] = b } 
} ]);
FusionCharts.register("module", ["private", "modules.renderer.js-htmlrenderer", function () {
    var d = this.hcLib, n = d.Raphael, E = d.dem, u = this.window, l = u.document, b = /msie/i.test(u.navigator.userAgent) && !u.opera, P = "VML" === n.type, c = "createTouch" in l, J = { cursor: "cursor" }, a = { x: "left", y: "top", strokeWidth: "borderThickness", "stroke-width": "borderThickness", width: "width", height: "height" }, B = { fill: "backgroundColor", stroke: "borderColor", color: "color" }, N = { left: 0, top: 0, padding: 0, border: "none", margin: 0, outline: "none", "-webkit-apperance": "none",
        position: "absolute", zIndex: 20
    }, t, g = function (b, c, d, g) { b = l.createElement(b); for (var k in c) a[k] ? b.style[k] = c[k] : b.setAttribute(k, c[k]); for (k in d) b.style[k] = d[k]; g && g.appendChild && g.appendChild(b); return b }, k; k = function (a, b, c) { b && b instanceof k && (b = b.element); (this.element = g(a, c, N, b)).ishot = "true"; this.nodeName = a.toLowerCase(); this.added = Boolean(b) }; k.prototype = { attr: function (c) {
        var d = this.element, g = {}, k, m, z; if ("object" !== typeof c) {
            if (!(g = this[c])) {
                var n; if ("string" === typeof c) d && d.getAttribute && (n =
d.getAttribute(c)); else if (void 0 !== c && null !== c && "object" === typeof c) for (z in c) d.setAttribute(z, c[z]); g = n
            } return g
        } for (k in c) {
            z = c[k]; if (J[k]) { switch (k) { case "cursor": "pointer" === z && P && (z = "hand") } d.style[J[k]] = z; m = !0 } else a[k] ? (d.style[a[k]] = z + "px", m = !0) : B[k] ? (d.style[B[k]] = z && z.replace(/^#?([a-f0-9]+)/ig, "#$1") || "none", m = !0) : /^visibility$/i.test(k) ? (m = "hidden" === z, d.style.display = m ? "none" : "", this.hidden = m, m = !0) : /^opacity$/i.test(k) ? (d.style.opacity = z, b && (m = 100 * Number(z), d.style.filter = "progid:DXImageTransform.Microsoft.Alpha(Opacity=" +
m + ")"), m = !0) : /^innerhtml$/i.test(k) ? ("input" !== d.nodeName.toLowerCase() && void 0 !== z && (d.innerHTML = z || ""), m = !0) : /^text$/i.test(k) ? ("input" !== d.nodeName.toLowerCase() && (d.innerHTML = "", void 0 !== z && d.appendChild(l.createTextNode(z))), m = !0) : /^type$/i.test(k) && b && this.added && (m = !0); m && (g[k] = z, delete c[k], m = !1)
        } for (k in c) d.setAttribute(k, c[k]); for (k in g) this[k] = c[k] = g[k], delete g[k]; return this
    }, val: function (a) {
        var b = this.element, c = void 0 === a; return "input" === this.nodeName && "checkbox" === b.getAttribute("type") ?
c ? this.checked() ? 1 : 0 : this.checked(a) : c ? b.value : (b.value = a, this)
    }, checked: function (a) { var b = this.element; return void 0 === a ? b.checked : (a ? b.setAttribute("checked", "checked") : b.removeAttribute("checked"), this) }, css: function (a, b) { var c = this.element.style, d; if ("object" === typeof a) for (d in a) c[d] = a[d]; else d && void 0 !== b && (c[d] = b); return this }, translate: function (a, b) { var c = this.element; void 0 !== a && (c.style.left = a + "px"); void 0 !== b && (c.style.top = b + "px"); return this }, add: function (a, b) {
        var c = this.element, d = a.element;
        b ? d.insertBefore(c, d.firstChild) : d.appendChild(c); this.added = !0; return this
    }, hide: function () { this.element.style.display = "none"; return this }, show: function () { this.element.style.display = ""; return this }, focus: function () { "function" === typeof this.element.focus ? this.element.focus() : d.dem.fire(this.element, "focus") }, destroy: function () { var a = this.element || {}; a.onclick = a.onmouseout = a.onmouseover = a.onmousemove = a.onblur = a.onfocus = null; t || (t = g("div")); a && t.appendChild(a); t.innerHTML = ""; delete this.element; return null },
        on: P ? function (a, b) { this.element["on" + a] = function () { var a = u.event; a.target = a.srcElement; b(a) }; return this } : function (a, b) { var d = b; c && "click" === a && (a = "touchstart", d = function (a) { a.preventDefault(); b() }); this.element["on" + a] = d; return this }, bind: function (a, b, c) { E.listen(this.element, a, b, c); return this }, unbind: function (a, b) { E.unlisten(this.element, a, b); return this }, trigger: function (a, b) { E.fire(this.element, a, b); return this }, fadeIn: function (a, b) {
            var c = "fast" === a ? 400 : 1E3; this.show(); this.attr({ opacity: 0 });
            d.danimate.animate(this.element, { opacity: 1 }, c, "linear", b)
        } 
    }; k.prototype.constructor = k; n.fn.html = function (a, b, c, d) { var g = {}, l; b && "type" in b && (g.type = b.type, delete b.type); a = (new k(a, d, g)).css(c).attr(b); for (l in g) b[l] = g[l]; return a } 
} ]);
FusionCharts.register("module", ["private", "modules.renderer.js-raphaeltooltip", function () {
    var d = this, n = d.window, E = n.document, u = E.body || E.getElementsByTagName("body")[0], l = d.hcLib, b = l.Raphael, P = b.eve, c = l.createElement, J = l.addEvent, a = l.removeEvent, B = l.getPosition, N = l.hasTouch, t = l.getTouchEvent, g = n.Math, k = g.ceil, f = g.floor, h = {}, s = n.screen.availHeight, sa = n.screen.availWidth, m = { "": 1, moz: 1, webkit: 1, o: 1, ms: 1 }, z = { borderRadius: "borderRadius", boxShadow: "boxShadow" }, H = /\-([a-z])/ig, M = function (a, b) { return b.toUpperCase() },
$ = function (a) { var c = C.forbiddenStyle, d, f, g; for (d in a) f = H.test(d) ? d.replace(H, M) : d, void 0 !== a[d] && !c[f] && (this[f] = a[d]), b.vml && /color/ig.test(f) && (this[f] = b.getRGB(this[f]).toString()); for (d in z) if (this[d]) for (g in m) this[g + d] = this[d] }, C = l.toolTip = { elementId: "fusioncharts-tooltip-element", element: null, lastTarget: null, currentTarget: null, currentPaper: null, pointeroffset: 12, prevented: !1, defaultStyle: l.extend2($.prototype, { backgroundColor: "#ffffee", borderColor: "#000000", borderWidth: "1px", color: "#000000",
    fontSize: "10px", lineHeight: "12px", padding: "3px", borderStyle: "solid"
}), defaultContainerStyle: { position: "absolute", textAlign: "left", margin: "0", zIndex: "99999", pointer: "default", display: "block" }, forbiddenStyle: {}
}, V = function (b) { !0 === C._oobready ? C._oobready = !1 : (a(u, "touchstart", V), !C.hidden && C.currentTarget && (b = b.srcElement || b.target || h, b.raphael && C.currentTarget.paper.getById(b.raphaelid) === C.currentTarget || C.hide())) }; b.svg && (C.defaultContainerStyle.pointerEvents = "none", C.defaultStyle.borderRadius = "0",
C.defaultStyle.boxShadow = "none"); b.vml && (C.forbiddenStyle.borderRadius = !0, C.forbiddenStyle.boxShadow = !0, C.defaultStyle.filter = ""); C.setup = function () {
    var a = C.container, f = C.textElement, g = C.style, k = C.defaultContainerStyle, h = C.forbiddenStyle, l; a || (a = C.element = c("span"), (E.body || E.getElementsByTagName("body")[0]).appendChild(a), a.setAttribute("id", C.elementId), g = C.containerStyle = a.style, f = C.textElement = c("span"), a.appendChild(f), C.style = b.vml ? f.runtimeStyle : f.style, C.style.overflow = "hidden", C.style.display =
"block", C.hidden = !1, C.hide()); for (l in k) !h[l] && (g[l] = k[l]); C.scatted = !0; P.on("raphael.drag.start.*", function () { C.scatted && (C.waitingScat = !0) }); P.on("raphael.drag.move.*", function () { C.waitingScat && (C.block(), C.waitingScat = !1) }); P.on("raphael.drag.end.*", function () { C.waitingScat = !1; C.scatted && C.unblock(!0) }); P.on("raphael.remove", function () { if (C.currentPaper === this || C.currentTarget && C.currentTarget.paper === this) C.hide(), C.currentTarget = C.currentPaper = null }); d.addEventListener("LinkedChartInvoked",
function (a) { C.currentPaper === a.sender.jsVars.hcObj.paper && C.hide() })
}; C.restyle = function (a) { var b = C.style, c; for (c in a) b[c] = a[c] }; C.onelement = function (a) {
    if (!a.__tipProcessed) {
        var b = this.paper, c = "group" === this.type ? b && b._elementFromEvent(a) : this, d = b.__tipStyle; c && d && c.__tipNeeded && ((a.originalEvent || a).FusionChartsPreventEvent && C.preventTooltip(), C.hiding && (C.hiding = clearTimeout(C.hiding)), C.currentPaper !== b && (b.__tipCp = b.canvas && B(b.canvas.parentNode, !0) || {}, C.restyle(b.__tipStyle), C.currentPaper =
b), C.lastTarget = C.currentTarget, C.currentTarget = c, C.scatted = c.__tipScatted, C.onredraw.call(this, a), a.__tipProcessed = !0, N && (C._oobready = !0, J(u || (u = E.body || E.getElementsByTagName("body")[0]), "touchstart", V)))
    } 
}; C.onredraw = function (a) {
    a.__tipProcessed || (a.__tipProcessed = !0, (this.paper && this.paper._elementFromEvent(a)) === C.currentTarget && (C.redrawing && clearTimeout(C.redrawing), a = t(a), a = a.originalEvent || a, C.x = f(a.pageX || a.clientX + E.body.scrollLeft + E.documentElement.scrollLeft || 0), C.y = f(a.pageY || a.clientY +
E.body.scrollTop + E.documentElement.scrollTop || 0), C.redrawing = setTimeout(C.redraw, 0)))
}; C.onhide = function (a) { a.__tipProcessed || (a.__tipProcessed = !0, (this.paper && this.paper._elementFromEvent(a)) === C.currentTarget && (C.hiding = setTimeout(C.hide, 200))) }; C.redraw = function () {
    if (!C.prevented && !C.blocked && C.currentTarget && C.currentTarget.__tipNeeded) {
        var a = C.currentTarget, b = a.paper, c = C.textElement, d = C.containerStyle, f = C.style, g = a.__tipText, a = C.pointeroffset, h = b.__tipCp, l = E.documentElement || E.body, z = l.scrollLeft,
l = l.scrollTop, m = C.x, n = C.y, M, I = b.width, G = b.height, b = b.__tipConstrain; if (100 > I || 100 > G) b = !1; C.hidden && (C.containerStyle.top = "-999em", C.show()); g !== C.text && (C.text = g, d.width = d.height = "", c.innerHTML = g, f.whiteSpace = "nowrap", g = k(f.pixelWidth || c.offsetWidth || 0), M = k(f.pixelHeight || c.offsetHeight || 0), (C.textWidthOverflow = g > I) ? (d.width = (I || 0) - 2 * a + "px", f.whiteSpace = "normal") : d.width = "", (C.textHeightOverflow = M > G) ? (d.height = (G || 0) - 2 * a + "px", f.whiteSpace = "normal") : d.height = ""); g = k(f.pixelWidth || c.offsetWidth || 0);
        M = k(f.pixelHeight || c.offsetHeight || 0); b ? (C.textWidthOverflow ? m = h.left - z : m + a + g > h.left - z + I - a && (m = m - g - a), C.textHeightOverflow ? n = h.top - l : n + a + M > h.top - l + G - a && (n = n - M - 1.5 * a)) : (z + sa < m + a + g && (m = m - g - a), l + s < n + a + M && (n = n - M - 1.5 * a)); d.left = (m + a || 0) + "px"; d.top = (n + a || 0) + "px"; C.hidden && C.show()
    } 
}; C.hide = function () { C.hiding && (C.hiding = clearTimeout(C.hiding)); C.containerStyle.display = "none"; C.hidden = !0; C.prevented = !1 }; C.show = function () {
    C.blocked || (C.hiding && (C.hiding = clearTimeout(C.hiding)), C.containerStyle.display = "inline",
C.hidden = !1)
}; C.preventTooltip = function () { C.prevented = !0 }; C.block = function () { C.blocked = !0; C.containerStyle.display = "none" }; C.unblock = function (a) { C.blocked = !1; a && (C.containerStyle.display = C.hidden && "none" || "inline") }; b.fn.tooltip = function (a, c, d) {
    c && (c = 0.4 * (void 0 === c.opacity ? 1 : c.opacity), b.svg ? a.boxShadow = "1px 1px 3px rgba(64,64,64," + c + ")" : a.filter = 'progid:DXImageTransform.Microsoft.Shadow(Strength=2, Direction=135, Color="#404040", shadowOpacity="' + c / 2 + '")'); this.__tipStyle = new $(a); this.__tipCp =
this.canvas && B(this.canvas.parentNode, !0) || {}; this.__tipConstrain = Boolean(d); return this
}; b.el.trackTooltip = function (a) { var b = !!this.__tiptracking; if (void 0 === a || (a = !!a) === b) return this; a ? N ? this.touchstart(C.onelement) : (this.mouseover(C.onelement), this.mousemove(C.onredraw), this.mouseout(C.onhide)) : N ? this.untouchstart(C.onelement) : (this.unmouseover(C.onelement), this.unmousemove(C.onredraw), this.unmouseout(C.onhide)); this.__tiptracking = a; return this }; b.el.tooltip = function (a, c, d, f, g) {
    C.setup(); b.el.tooltip =
function (a, b, c, d, f) { b = !1 === a || void 0 === a || "" === a; this.__tipScatted = void 0 === d ? this.__tipScatted : !d; void 0 === this.__tipScatted && (this.__tipScatted = !0); null !== f && (this.__tip_blocked = f); b ^ !this.__tipText && (this.__tipNeeded = !b); this.__tipText = a; if (C.currentTarget === this && a !== C.text && !C.hidden) C[b ? "hide" : "redraw"](); return this }; return b.el.tooltip.call(this, a, c, d, f, g)
}; d.core._setTooltipZIndex = function (a) {
    a = parseInt(a, 10); C && !isNaN(a) && (C.defaultContainerStyle.zIndex = a, C.containerStyle && (C.containerStyle.zIndex =
a))
} 
} ]);
FusionCharts.register("module", ["private", "modules.renderer.js-smartlabel", function () {
    var d = this.hcLib, n = d.isIE, E = d.hasSVG, u = Math.max, l = this.window, b = / HtmlUnit/.test(l.navigator.userAgent), P = l.document, c = / AppleWebKit\//.test(l.navigator.userAgent), J = !!P.createElement("canvas").getContext, a = !(!J || !P.createElement("canvas").getContext("2d").measureText), l = function () {
        function l(a, b, c) {
            if (!a || !a.length) return 0; var d = c.getWidthFunction(), f = 0, g = 0, g = d(a), k = g / a.length; c = b; f = Math.ceil(b / k); if (g < b) return a.length -
1; f > a.length && (c = b - g, f = a.length); for (; 0 < c; ) if (c = b - d(a.substr(0, f)), g = Math.floor(c / k)) f += g; else return f; for (; 0 > c; ) if (c = b - d(a.substr(0, f)), g = Math.floor(c / k)) f += g; else break; return f
        } function N(a, b) {
            b = 5 < b ? b : 5; this.maxContainers = 20 > b ? b : 20; this.last = this.first = null; this.containers = {}; this.length = 0; this.rootNode = a; if (C) {
                var c = P.createElementNS("http://www.w3.org/2000/svg", "svg"); c.setAttributeNS("http://www.w3.org/2000/svg", "xlink", "http://www.w3.org/1999/xlink"); c.setAttributeNS("http://www.w3.org/2000/svg",
"height", "0"); c.setAttributeNS("http://www.w3.org/2000/svg", "width", "0"); this.svgRoot = c; this.rootNode.appendChild(c)
            } 
        } function t(a, c, d) {
            if ("undefined" !== typeof a && "object" !== typeof a) {
                this.id = a; var g; "string" === typeof c && (c = P.getElementById(c)); a: 
                {
                    if (c && (c.offsetWidth || c.offsetHeight)) { if (c.appendChild) { c.appendChild(c = P.createElement("div")); c.className = "fusioncharts-smartlabel-container"; c.setAttribute("aria-hidden", "true"); c.setAttribute("role", "presentation"); a = c; break a } } else if ((a = P.getElementsByTagName("body")[0]) &&
a.appendChild) { c = P.createElement("div"); c.className = "fusioncharts-smartlabel-container"; c.setAttribute("aria-hidden", "true"); c.setAttribute("role", "presentation"); a.appendChild(c); a = c; break a } a = void 0
                } a = this.parentContainer = a; a.innerHTML = $; if (b || !a.offsetHeight && !a.offsetWidth) C = !0; a.innerHTML = ""; for (g in f) a.style[g] = f[g]; this.containerManager = new N(a, 10); this.showNoEllipses = !d; this.init = !0; this.style = {}; this.setStyle()
            } 
        } var g = d.supportedStyle, k = { fontWeight: 1, "font-weight": 1, fontStyle: 1, "font-style": 1,
            fontSize: 1, "font-size": 1, fontFamily: 1, "font-family": 1
        }, f = { position: "absolute", top: "-9999em", left: "-9999em", whiteSpace: "nowrap", padding: "0px", width: "1px", height: "1px", overflow: "hidden" }, h = c ? 0 : 4.5, s = 0, sa = /\b_SmartLabel\b/, m = /\b_SmartLabelBR\b/, z = /(<[^<\>]+?\>)|(&(?:[a-z]+|#[0-9]+);|.)/ig, H = RegExp("\\<span[^\\>]+?_SmartLabel[^\\>]{0,}\\>(.*?)\\<\\/span\\>", "ig"), M = /<[^>][^<]*[^>]+>/i, $ = "WgI", C = !1, V = 0, ba = 0, da, xa, ua; P.getElementsByClassName ? (da = "getElementsByClassName", xa = "_SmartLabel", ua = !0) : (da = "getElementsByTagName",
xa = "span", ua = !1); N.prototype = { get: function (a) { var b = this.containers, c = this.length, d = this.maxContainers, f, k = "", h = "", h = this.getCanvasFont(a); for (f in g) void 0 !== a[f] && (k += g[f] + ":" + a[f] + ";"); if (!k) return !1; if (b[k]) k = b[k], this.first !== k && (k.prev && (k.prev.next = k.next), k.next && (k.next.prev = k.prev), k.next = this.first, k.next.prev = k, this.last === k && (this.last = k.prev), k.prev = null, this.first = k); else { if (c >= d) for (a = c - d + 1; a--; ) this.removeContainer(this.last); k = this.addContainer(k, h) } return k }, getCanvasFont: function (b) {
    var c,
d = []; if (!J || !a) return !1; for (c in k) void 0 !== b[c] && d.push(b[c]); return d.join(" ")
}, setMax: function (a) { var b = this.length; a = 5 < a ? a : 5; a = 20 > a ? a : 20; if (a < b) { for (b -= a; b--; ) this.removeContainer(this.last); this.length = a } this.maxContainers = a }, addContainer: function (a, b) {
    var c, d; this.containers[a] = d = { next: null, prev: null, node: null, ellipsesWidth: 0, lineHeight: 0, dotWidth: 0, avgCharWidth: 4, keyStr: a, canvasStr: b, charCache: {} }; d.next = this.first; d.next && (d.next.prev = d); this.first = d; this.last || (this.last = d); this.length +=
1; c = d.node = P.createElement("span"); this.rootNode.appendChild(c); n && !E ? c.style.setAttribute("cssText", a) : c.setAttribute("style", a); c.setAttribute("aria-hidden", "true"); c.setAttribute("role", "presentation"); c.style.display = "inline-block"; c.innerHTML = $; d.lineHeight = c.offsetHeight; d.avgCharWidth = c.offsetWidth / 3; C ? (c = d.svgText = P.createElementNS("http://www.w3.org/2000/svg", "text"), c.setAttribute("style", a), this.svgRoot.appendChild(c), c.textContent = $, d.lineHeight = c.getBBox().height, d.avgCharWidth = (c.getBBox().width -
h) / 3, c.textContent = "...", d.ellipsesWidth = c.getBBox().width - h, c.textContent = ".", d.dotWidth = c.getBBox().width - h) : b ? (c = d.canvas = P.createElement("canvas"), c.style.height = c.style.width = "0px", this.rootNode.appendChild(c), d.context = c = c.getContext("2d"), c.font = b, d.ellipsesWidth = c.measureText("...").width, d.dotWidth = c.measureText(".").width) : (c.innerHTML = "...", d.ellipsesWidth = c.offsetWidth, c.innerHTML = ".", d.dotWidth = c.offsetWidth, c.innerHTML = ""); return d
}, removeContainer: function (a) {
    var b = a.keyStr; b && this.length &&
a && (this.length -= 1, a.prev && (a.prev.next = a.next), a.next && (a.next.prev = a.prev), this.first === a && (this.first = a.next), this.last === a && (this.last = a.prev), a.node.parentNode.removeChild(a.node), a.canvas && a.canvas.parentNode.removeChild(a.canvas), delete this.containers[b])
}, dispose: function () { var a, b = this.containers; this.maxContainers = null; for (a in b) this.removeContainer(b[a]); this.rootNode.parentNode.removeChild(this.rootNode); this.last = this.first = this.rootNode = null } 
}; N.prototype.constructor = N; t.prototype =
{ dispose: function () { this.init && (this.containerManager.dispose(), delete this.container, delete this.context, delete this.cache, delete this.containerManager, delete this.containerObj, delete this.id, delete this.style, delete this.parentContainer, delete this.showNoEllipses) }, useEllipsesOnOverflow: function (a) { this.init && (this.showNoEllipses = !a) }, getWidthFunction: function () {
    var a = this.context, b = this.container, c = this.containerObj.svgText; return c ? function (a) {
        var b; c.textContent = a; a = c.getBBox(); b = a.width - h; 1 >
b && (b = a.width); return b
    } : a ? function (b) { return a.measureText(b).width } : function (a) { b.innerHTML = a; return b.offsetWidth } 
}, getSmartText: function (a, b, c, d) {
    if (!this.init) return !1; if (void 0 === a || null === a) a = ""; var f = { text: a, maxWidth: b, maxHeight: c, width: null, height: null, oriTextWidth: null, oriTextHeight: null, oriText: a, isTruncated: !1 }, g = !1, k, h, I = 0, G, n, t = -1, E = g = -1; h = this.container; var $ = this.context, J = 0, N = 0, X, ma, Ba = [], W = 0, fa = this.showNoEllipses ? "" : "...", N = this.lineHeight, Ca, J = [], t = k = -1; Ca = function (a) {
        a = a.replace(/^\s\s*/,
""); for (var b = /\s/, c = a.length; b.test(a.charAt(c -= 1)); ); return a.slice(0, c + 1)
    }; ma = this.getWidthFunction(); if (h) {
        if (!C) { h.innerHTML = a; f.oriTextWidth = n = h.offsetWidth; f.oriTextHeight = g = h.offsetHeight; if (g <= c && n <= b) return f.width = f.oriTextWidth = n, f.height = f.oriTextHeight = g, f; if (N > c) return f.text = "", f.width = f.oriTextWidth = 0, f.height = f.oriTextHeight = 0, f } a = Ca(a).replace(/(\s+)/g, " "); g = M.test(a); n = this.showNoEllipses ? b : b - s; if (g) {
            I = a.replace(z, "$2"); a = a.replace(z, '$1<span class="_SmartLabel">$2</span>'); a =
a.replace(/(<br\s*\/*\>)/g, '<span class="_SmartLabel _SmartLabelBR">$1</span>'); h.innerHTML = a; W = h[da](xa); $ = 0; for (ma = W.length; $ < ma; $ += 1) if (a = W[$], ua || sa.test(a.className)) Ca = a.innerHTML, "" !== Ca && (" " === Ca ? t = J.length : "-" === Ca && (k = J.length), J.push({ spaceIdx: t, dashIdx: k, elem: a }), Ba.push(Ca)); W = 0; k = J.length; V = J[0].elem.offsetWidth; if (V > b) return f.text = "", f.width = f.oriTextWidth = f.height = f.oriTextHeight = 0, f; V > n && !this.showNoEllipses && (n = b - 2 * ba, n > V ? fa = ".." : (n = b - ba, n > V ? fa = "." : (n = 0, fa = ""))); if (d) for (; W < k; W +=
1) a = J[W].elem, d = a.offsetLeft + a.offsetWidth, d > n && (X || (X = W), h.offsetWidth > b && (G = W, W = k)); else for (; W < k; W += 1) a = J[W].elem, $ = a.offsetHeight + a.offsetTop, d = a.offsetLeft + a.offsetWidth, Ba = null, d > n ? (X || (X = W), d > b && (g = J[W].spaceIdx, t = J[W].dashIdx, g > E ? (J[g].elem.innerHTML = "<br/>", E = g) : t > E ? (J[t].elem.innerHTML = t === W ? "<br/>-" : "-<br/>", E = t) : a.parentNode.insertBefore(Ba = P.createElement("br"), a), a.offsetHeight + a.offsetTop > c ? (Ba ? Ba.parentNode.removeChild(Ba) : E === t ? J[t].elem.innerHTML = "-" : J[g].elem.innerHTML = " ", G = W,
W = k) : X = null)) : $ > c && (G = W, W = k); if (G < k) { f.isTruncated = !0; X = X ? X : G; for (W = k - 1; W >= X; W -= 1) a = J[W].elem, a.parentNode.removeChild(a); for (; 0 <= W; W -= 1) a = J[W].elem, m.test(a.className) ? a.parentNode.removeChild(a) : W = 0 } f.text = h.innerHTML.replace(H, "$1"); f.isTruncated && (f.text += fa, f.tooltext = I)
        } else {
            Ba = a.split(""); k = Ba.length; h = ""; G = []; X = Ba[0]; this.cache[X] ? V = this.cache[X].width : (V = ma(X), this.cache[X] = { width: V }); if (n > V) G = a.substr(0, l(a, n, this)).split(""), W = G.length; else {
                if (V > b) return f.text = "", f.width = f.oriTextWidth =
f.height = f.oriTextHeight = 0, f; fa && (n = b - 2 * ba, n > V ? fa = ".." : (n = b - ba, n > V ? fa = "." : (n = 0, fa = "")))
            } J = ma(G.join("")); N = this.lineHeight; if (d) { for (; W < k; W += 1) if (X = G[W] = Ba[W], this.cache[X] ? V = this.cache[X].width : (V = ma(X), this.cache[X] = { width: V }), J += V, J > n && (h || (h = G.slice(0, -1).join("")), J > b)) return f.text = Ca(h) + fa, f.tooltext = f.oriText, f.width = ma(f.text), f.height = this.lineHeight, f; f.text = G.join(""); f.width = J; f.height = this.lineHeight } else {
                for (; W < k; W += 1) if (X = G[W] = Ba[W], " " !== X || $ || (X = "&nbsp;"), this.cache[X] ? V = this.cache[X].width :
(V = ma(X), this.cache[X] = { width: V }), J += V, J > n && (h || (h = G.slice(0, -1).join("")), J > b)) {
                    g = a.substr(0, G.length).lastIndexOf(" "); t = a.substr(0, G.length).lastIndexOf("-"); g > E ? (J = ma(G.slice(E + 1, g).join("")), G.splice(g, 1, "<br/>"), E = g, d = g + 1) : t > E ? (t === G.length - 1 ? (J = ma(G.slice(E + 1, g).join("")), G.splice(t, 1, "<br/>-")) : (J = ma(G.slice(E + 1, g).join("")), G.splice(t, 1, "-<br/>")), E = t, d = t + 1) : (G.splice(G.length - 1, 1, "<br/>" + Ba[W]), d = W); N += this.lineHeight; if (N > c) return f.text = Ca(h) + fa, f.tooltext = f.oriText, f.width = I, f.height =
N - this.lineHeight, f; I = u(I, J); h = null; X = l(a.substr(d), n, this); J = ma(a.substr(d, X || 1)); G.length < d + X && (G = G.concat(a.substr(G.length, d + X - G.length).split("")), W = G.length - 1)
                } I = u(I, J); f.text = G.join(""); f.width = I; f.height = N
            } return f
        } f.height = h.offsetHeight; f.width = h.offsetWidth
    } else f.error = Error("Body Tag Missing!"); return f
}, setStyle: function (a) {
    if (!this.init) return !1; if (a !== this.style || this.styleNotSet) {
        a || (a = this.style); var b = a, c = b.fontSize = b.fontSize || "12px"; b.lineHeight = b.lineHeight || b["line-height"] ||
1.2 * parseInt(c, 10) + "px"; this.style = a; (this.containerObj = a = this.containerManager.get(a)) ? (this.container = a.node, this.context = a.context, this.cache = a.charCache, this.lineHeight = a.lineHeight, s = a.ellipsesWidth, ba = a.dotWidth, this.styleNotSet = !1) : this.styleNotSet = !0
    } 
}, getTextSize: function (a, b, c) {
    if (!this.init) return !1; var d = { text: a, width: null, height: null, oriTextWidth: null, oriTextHeight: null, isTruncated: !1 }, f = this.container; f && (f.innerHTML = a, d.oriTextWidth = f.offsetWidth, d.oriTextHeight = f.offsetHeight, d.width =
Math.min(d.oriTextWidth, b), d.height = Math.min(d.oriTextHeight, c), d.width < d.oriTextWidth || d.height < d.oriTextHeight) && (d.isTruncated = !0); return d
}, getOriSize: function (a) { if (!this.init) return !1; var b = { text: a, width: null, height: null }, c = this.container, d = this.getWidthFunction(), f = 0; if (C) { a = a.split(/(<br\s*\/*\>)/g); c = a.length; for (b.height = this.lineHeight * c; c--; ) f = u(f, d(a[c])); b.width = f } else c && (c.innerHTML = a, b.width = c.offsetWidth, b.height = c.offsetHeight); return b } 
}; return t.prototype.constructor = t
    } (); d.SmartLabelManager =
l
} ]);
FusionCharts.register("module", ["private", "modules.renderer.js-numberformatter", function () {
    var d = this, n = d.hcLib, E = n.pluckNumber, u = n.extend2, l = n.getValidValue, b = n.pluck, P = n.getFirstValue, c = Math.abs, J = Math.pow, a = Math.round, B = function (a) { return a && a.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&") }, N = {}, t = function (a) { var b = [], c; for (c in a) b.push(c + "_" + a[c]); b.sort(); return b.join(",") }, g = function (a) { var b = {}, c; for (c in a) b[c.toLowerCase()] = a[c]; return b }; n.NumberFormatter = function () {
        function d(b, c, f) {
            var g; if (0 >=
c) return a(b) + ""; if (isNaN(c)) return b += "", 12 < b.length && -1 != b.indexOf(".") && (c = 12 - b.split(".")[0].length, g = J(10, c), b = a(b * g) / g + ""), b; g = J(10, c); b = a(b * g) / g + ""; if (1 == f) for (-1 == b.indexOf(".") && (b += ".0"), f = b.split("."), c -= f[1].length, f = 1; f <= c; f++) b += "0"; return b
        } function f(a, b, c, d) {
            var f = Number(a), g = "", k = !1, h = "", l = "", s = h = 0; if (isNaN(f)) return ""; h = 0; s = a.length; -1 != a.indexOf(".") && (g = a.substring(a.indexOf(".") + 1, a.length), s = a.indexOf(".")); 0 > f && (k = !0, h = 1); h = a.substring(h, s); a = h.length; f = d.length - 1; s = d[f]; if (a <
s) l = h; else for (; a >= s; ) l = (a - s ? c : "") + h.substr(a - s, s) + l, a -= s, s = 0 >= (f -= 1) ? d[0] : d[f], a < s && (l = h.substring(a, 0) + l); "" != g && (l = l + b + g); !0 === k && (l = "-" + l); return l
        } var g, s = { formatnumber: "1", formatnumberscale: "1", defaultnumberscale: "", numberscaleunit: ["K", "M"], numberscalevalue: [1E3, 1E3], numberprefix: "", numbersuffix: "", decimals: "", forcedecimals: "0", yaxisvaluedecimals: "2", decimalseparator: ".", thousandseparator: ",", thousandseparatorposition: [3], indecimalseparator: "", inthousandseparator: "", sformatnumber: "1", sformatnumberscale: "0",
            sdefaultnumberscale: "", snumberscaleunit: ["K", "M"], snumberscalevalue: [1E3, 1E3], snumberprefix: "", snumbersuffix: "", sdecimals: "2", sforcedecimals: "0", syaxisvaluedecimals: "2", xFormatNumber: "0", xFormatNumberScale: "0", xDefaultNumberScale: "", xNumberScaleUnit: ["K", "M"], xNumberScaleValue: [1E3, 1E3], xNumberPrefix: "", xNumberSuffix: ""
        }, n = { mscombidy2d: { formatnumberscale: "1"} }, m = function (a, c, d) {
            var f, g, k, h, m, t, J, N, ca, ha = c.name, w = u({}, s), Q, K, aa, ja, I, G, la, Xa, ga, Aa, za; (k = n[ha]) && (w = u(w, k)); this.csConf = w; this.chartAPI =
c; l(a.numberscaleunit) && (f = a.numberscaleunit.split(",")); if (g = l(a.snumberscaleunit, a.numberscaleunit)) g = g.split(","); if (k = l(a.xnumberscaleunit, a.numberscaleunit)) k = k.split(","); if (h = l(a.ticknumberscaleunit, a.numberscaleunit)) h = h.split(","); if (m = l(a.ynumberscaleunit, a.numberscaleunit)) m = m.split(","); l(a.numberscalevalue) && (t = a.numberscalevalue.split(",")); if (K = l(a.snumberscalevalue, a.numberscalevalue)) K = K.split(","); if (J = l(a.xnumberscalevalue, a.numberscalevalue)) J = J.split(","); if (N = l(a.ticknumberscalevalue,
a.numberscalevalue)) N = N.split(","); if (ca = l(a.ynumberscalevalue, a.numberscalevalue)) ca = ca.split(","); if (l(a.thousandseparatorposition)) for (Q = a.thousandseparatorposition.split(","), aa = Q.length, I = s.thousandseparatorposition[0]; aa--; ) ja = parseInt(Q[aa], 10), 0 >= ja && (ja = I), I = Q[aa] = ja; c || (c = {}); aa = E(a.scalerecursively, 0); ja = E(a.sscalerecursively, aa); I = E(a.xscalerecursively, aa); G = E(a.maxscalerecursion, -1); la = E(a.smaxscalerecursion, G); Xa = E(a.xmaxscalerecursion, G); ga = l(a.scaleseparator, " "); Aa = l(a.sscaleseparator,
ga); za = l(a.xscaleseparator, ga); G || (G = -1); this.baseConf = f = { cacheStore: [], formatnumber: b(a.formatnumber, c.formatnumber, w.formatnumber), formatnumberscale: b(a.formatnumberscale, c.formatnumberscale, w.formatnumberscale), defaultnumberscale: P(a.defaultnumberscale, c.defaultnumberscale, w.defaultnumberscale), numberscaleunit: b(f, c.numberscaleunit, w.numberscaleunit).concat(), numberscalevalue: b(t, c.numberscalevalue, w.numberscalevalue).concat(), numberprefix: P(a.numberprefix, c.numberprefix, w.numberprefix), numbersuffix: P(a.numbersuffix,
c.numbersuffix, w.numbersuffix), decimalprecision: parseInt("auto" === a.decimals ? w.decimalprecision : b(a.decimals, a.decimalprecision, c.decimals, w.decimals, c.decimalprecision, w.decimalprecision), 10), forcedecimals: b(a.forcedecimals, c.forcedecimals, w.forcedecimals), decimalseparator: b(a.decimalseparator, c.decimalseparator, w.decimalseparator), thousandseparator: b(a.thousandseparator, c.thousandseparator, w.thousandseparator), thousandseparatorposition: b(Q, c.thousandseparatorposition, w.thousandseparatorposition),
    indecimalseparator: P(a.indecimalseparator, c.indecimalseparator, w.indecimalseparator), inthousandseparator: P(a.inthousandseparator, c.inthousandseparator, w.inthousandseparator), scalerecursively: aa, maxscalerecursion: G, scaleseparator: ga
}; l(f.inthousandseparator) && (this.baseConf._REGinthousandseparator = new RegExp(B(f.inthousandseparator), "g")); l(f.indecimalseparator) && (this.baseConf._REGindecimalseparator = new RegExp(B(f.indecimalseparator))); this.Y = []; d || (d = { cacheStore: [], formatnumber: f.formatnumber, formatnumberscale: f.formatnumberscale,
    defaultnumberscale: f.defaultnumberscale, numberscaleunit: f.numberscaleunit.concat(), numberscalevalue: f.numberscalevalue.concat(), numberprefix: f.numberprefix, numbersuffix: f.numbersuffix, decimalprecision: f.decimalprecision, forcedecimals: f.forcedecimals, decimalseparator: f.decimalseparator, thousandseparator: f.thousandseparator, thousandseparatorposition: f.thousandseparatorposition, indecimalseparator: f.indecimalseparator, inthousandseparator: f.inthousandseparator, scalerecursively: aa, maxscalerecursion: G, scaleseparator: ga
},
c.useScaleRecursively && (d.numberscalevalue && d.numberscalevalue.length) == (d.numberscaleunit && d.numberscaleunit.length) || (d.scalerecursively = aa = 0), t = { cacheStore: [], formatnumber: d.formatnumber, formatnumberscale: d.formatnumberscale, defaultnumberscale: d.defaultnumberscale, numberscaleunit: d.numberscaleunit.concat(), numberscalevalue: d.numberscalevalue.concat(), numberprefix: d.numberprefix, numbersuffix: d.numbersuffix, decimalprecision: parseInt(b(a.yaxisvaluedecimals, d.decimalprecision, 2), 10), forcedecimals: b(a.forceyaxisvaluedecimals,
d.forcedecimals), decimalseparator: d.decimalseparator, thousandseparator: d.thousandseparator, thousandseparatorposition: d.thousandseparatorposition.concat(), indecimalseparator: d.indecimalseparator, inthousandseparator: d.inthousandseparator, scalerecursively: aa, maxscalerecursion: G, scaleseparator: ga
}, K = { cacheStore: [], formatnumber: b(a.sformatnumber, c.sformatnumber, s.sformatnumber), formatnumberscale: b(a.sformatnumberscale, c.sformatnumberscale, s.sformatnumberscale), defaultnumberscale: P(a.sdefaultnumberscale,
c.sdefaultnumberscale, d.defaultnumberscale), numberscaleunit: b(g, c.snumberscaleunit, s.snumberscaleunit).concat(), numberscalevalue: b(K, c.snumberscalevalue, s.snumberscalevalue).concat(), numberprefix: P(a.snumberprefix, c.snumberprefix, s.snumberprefix), numbersuffix: P(a.snumbersuffix, c.snumbersuffix, s.snumbersuffix), decimalprecision: parseInt(b(a.syaxisvaluedecimals, a.sdecimals, a.decimals, c.sdecimals, s.sdecimals), 10), forcedecimals: b(a.forcesyaxisvaluedecimals, a.sforcedecimals, a.forcedecimals, c.sforcedecimals,
s.sforcedecimals), decimalseparator: b(a.decimalseparator, c.decimalseparator, s.decimalseparator), thousandseparator: b(a.thousandseparator, c.thousandseparator, s.thousandseparator), thousandseparatorposition: d.thousandseparatorposition.concat(), indecimalseparator: b(a.indecimalseparator, c.indecimalseparator, s.indecimalseparator), inthousandseparator: b(a.inthousandseparator, c.inthousandseparator, s.inthousandseparator), scalerecursively: ja, maxscalerecursion: la, scaleseparator: Aa
}, g = u({}, K), g.decimalprecision =
parseInt(b(a.sdecimals, a.decimals, a.syaxisvaluedecimals, c.sdecimals, s.sdecimals), 10), g.forcedecimals = b(a.sforcedecimals, a.forcedecimals, a.forcesyaxisvaluedecimals, c.sforcedecimals, s.sforcedecimals), g.cacheStore = [], c.useScaleRecursively && (K.numberscalevalue && K.numberscalevalue.length) == (K.numberscaleunit && K.numberscaleunit.length) || (K.scalerecursively = ja = 0), /^(bubble|scatter|selectscatter)$/.test(ha) && (t.formatnumber = b(a.yformatnumber, t.formatnumber), t.formatnumberscale = b(a.yformatnumberscale, t.formatnumberscale),
t.defaultnumberscale = P(a.ydefaultnumberscale, t.defaultnumberscale), t.numberscaleunit = b(m, t.numberscaleunit), t.numberscalevalue = b(ca, t.numberscalevalue), t.numberprefix = b(a.ynumberprefix, t.numberprefix), t.numbersuffix = b(a.ynumbersuffix, t.numbersuffix), d.formatnumber = b(a.yformatnumber, d.formatnumber), d.formatnumberscale = b(a.yformatnumberscale, d.formatnumberscale), d.defaultnumberscale = P(a.ydefaultnumberscale, d.defaultnumberscale), d.numberscaleunit = b(a.ynumberscaleunit, d.numberscaleunit.concat()), d.numberscalevalue =
b(a.ynumberscalevalue, d.numberscalevalue.concat()), d.numberprefix = b(a.ynumberprefix, d.numberprefix), d.numbersuffix = b(a.ynumbersuffix, d.numbersuffix)), /^(mscombidy2d|mscombidy3d)$/.test(ha) && (K.formatnumberscale = E(a.sformatnumberscale, "1")), /^(pie2d|pie3d|doughnut2d|doughnut3d|marimekko|pareto2d|pareto3d)$/.test(ha) && (d.decimalprecision = b(a.decimals, "2")), aa && (d.numberscalevalue.push(1), d.numberscaleunit.unshift(d.defaultnumberscale), t.numberscalevalue.push(1), t.numberscaleunit.unshift(t.defaultnumberscale)),
ja && (K.numberscalevalue.push(1), K.numberscaleunit.unshift(K.defaultnumberscale), g.numberscalevalue.push(1), g.numberscaleunit.unshift(g.defaultnumberscale)), this.Y[0] = { yAxisLabelConf: t, dataLabelConf: d }, this.Y[1] = { yAxisLabelConf: K, dataLabelConf: g }, this.paramLabels = d, this.param1 = t, this.param2 = K, this.paramLabels2 = g); this.paramX = { cacheStore: [], formatnumber: b(a.xformatnumber, f.formatnumber), formatnumberscale: b(a.xformatnumberscale, f.formatnumberscale), defaultnumberscale: P(a.xdefaultnumberscale, f.defaultnumberscale),
    numberscaleunit: b(k, f.numberscaleunit.concat()), numberscalevalue: b(J, f.numberscalevalue.concat()), numberprefix: b(a.xnumberprefix, f.numberprefix), numbersuffix: b(a.xnumbersuffix, f.numbersuffix), decimalprecision: parseInt(b(a.xaxisvaluedecimals, a.xaxisvaluesdecimals, f.decimalprecision, 2), 10), forcedecimals: b(a.forcexaxisvaluedecimals, 0), decimalseparator: f.decimalseparator, thousandseparator: f.thousandseparator, thousandseparatorposition: f.thousandseparatorposition.concat(), indecimalseparator: f.indecimalseparator,
    inthousandseparator: f.inthousandseparator, scalerecursively: I, maxscalerecursion: Xa, scaleseparator: za
}; this.paramLegend = u(u({}, f), { cacheStore: [], decimalprecision: parseInt(E(a.legendvaluedecimals, f.decimalprecision, 2), 10), forcedecimals: E(a.legendvalueforcedecimals, f.forcedecimals, 0), formatnumberscale: b(a.legendvalueformatnumberscale, f.formatnumberscale), formatnumber: b(a.legendvalueformatnumber, f.formatnumber) }); c.useScaleRecursively && (this.paramX.numberscalevalue && this.paramX.numberscalevalue.length) ==
(this.paramX.numberscaleunit && this.paramX.numberscaleunit.length) || (this.paramX.scalerecursively = I = 0); I && (this.paramX.numberscalevalue.push(1), this.paramX.numberscaleunit.unshift(this.paramX.defaultnumberscale)); this.paramScale = { cacheStore: [], formatnumber: b(a.tickformatnumber, f.formatnumber), formatnumberscale: b(a.tickformatnumberscale, f.formatnumberscale), defaultnumberscale: P(a.tickdefaultnumberscale, f.defaultnumberscale), numberscaleunit: b(h, f.numberscaleunit.concat()), numberscalevalue: b(N, f.numberscalevalue.concat()),
    numberprefix: b(a.ticknumberprefix, f.numberprefix), numbersuffix: b(a.ticknumbersuffix, f.numbersuffix), decimalprecision: parseInt(b(a.tickvaluedecimals, f.decimalprecision, "2"), 10), forcedecimals: b(a.forcetickvaluedecimals, f.forcedecimals, 0), decimalseparator: f.decimalseparator, thousandseparator: f.thousandseparator, thousandseparatorposition: f.thousandseparatorposition.concat(), indecimalseparator: f.indecimalseparator, inthousandseparator: f.inthousandseparator, scalerecursively: aa, maxscalerecursion: G, scaleseparator: ga
};
            aa && (this.paramScale.numberscalevalue.push(1), this.paramScale.numberscaleunit.unshift(this.paramScale.defaultnumberscale)); this.timeConf = { inputDateFormat: b(a.inputdateformat, a.dateformat, "mm/dd/yyyy"), outputDateFormat: b(a.outputdateformat, a.inputdateformat, a.dateformat, "mm/dd/yyyy"), days: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), months: "January February March April May June July August September October November December".split(" "), daySuffix: " st nd rd th th th th th th th th th th th th th th th th th st nd rd th th th th th th th st".split(" ")}
        };
        m.prototype = { cleaneValueCacheStore: {}, percentStrCacheStore: {}, dispose: function () {
            this.Y && delete this.Y; this.cleaneValueCacheStore && delete this.cleaneValueCacheStore; this.percentStrCacheStore && delete this.percentStrCacheStore; this.paramLabels && delete this.paramLabels; this.param1 && delete this.param1; this.param2 && delete this.param2; this.paramLabels2 && delete this.paramLabels2; this.csConf && delete this.csConf; this.chartAPI && delete this.chartAPI; this.baseConf && delete this.baseConf; this.timeConf && delete this.timeConf;
            this.paramX && delete this.paramX; this.paramScale && delete this.paramScale
        }, parseMLAxisConf: function (a, d) {
            var f = this.baseConf, g = this.csConf, k = this.chartAPI, h = E(a.scalerecursively, f.scalerecursively), m = E(a.maxscalerecursion, f.maxscalerecursion), n = l(a.scaleseparator, f.scaleseparator), t, B, u, J, N, w; d = E(d, this.Y.length); l(a.numberscaleunit) && (t = a.numberscaleunit.split(",")); l(a.numberscalevalue) && (B = a.numberscalevalue.split(",")); m || (m = -1); if (l(a.thousandseparatorposition)) for (u = a.thousandseparatorposition.split(","),
J = u.length, w = s.thousandseparatorposition[0]; J--; ) (N = E(c(u[J]))) ? w = N : N = w, u[J] = N; f = { cacheStore: [], formatnumber: b(a.formatnumber, f.formatnumber), formatnumberscale: b(a.formatnumberscale, f.formatnumberscale), defaultnumberscale: P(a.defaultnumberscale, f.defaultnumberscale), numberscaleunit: b(t, f.numberscaleunit).concat(), numberscalevalue: b(B, f.numberscalevalue).concat(), numberprefix: P(a.numberprefix, f.numberprefix), numbersuffix: P(a.numbersuffix, f.numbersuffix), forcedecimals: b(a.forcedecimals, f.forcedecimals),
    decimalprecision: parseInt("auto" === a.decimals ? g.decimalprecision : b(a.decimals, f.decimalprecision), 10), decimalseparator: b(a.decimalseparator, f.decimalseparator), thousandseparator: b(a.thousandseparator, f.thousandseparator), thousandseparatorposition: b(u, f.thousandseparatorposition), indecimalseparator: P(a.indecimalseparator, f.indecimalseparator), inthousandseparator: P(a.inthousandseparator, f.inthousandseparator), scalerecursively: h, maxscalerecursion: m, scaleseparator: n
}; k.useScaleRecursively && (f.numberscalevalue &&
f.numberscalevalue.length) == (f.numberscaleunit && f.numberscaleunit.length) || (f.scalerecursively = h = 0); k = { cacheStore: [], formatnumber: f.formatnumber, formatnumberscale: f.formatnumberscale, defaultnumberscale: f.defaultnumberscale, numberscaleunit: f.numberscaleunit.concat(), numberscalevalue: f.numberscalevalue.concat(), numberprefix: f.numberprefix, numbersuffix: f.numbersuffix, decimalprecision: parseInt(b(a.yaxisvaluedecimals, f.decimalprecision, 2), 10), forcedecimals: b(a.forceyaxisvaluedecimals, f.forcedecimals),
    decimalseparator: f.decimalseparator, thousandseparator: f.thousandseparator, thousandseparatorposition: f.thousandseparatorposition.concat(), indecimalseparator: f.indecimalseparator, inthousandseparator: f.inthousandseparator, scalerecursively: h, maxscalerecursion: m, scaleseparator: n
}; h && (f.numberscalevalue.push(1), f.numberscaleunit.unshift(f.defaultnumberscale), k.numberscalevalue.push(1), k.numberscaleunit.unshift(k.defaultnumberscale)); this.Y[d] = { dataLabelConf: f, yAxisLabelConf: k}
        }, percentValue: function (a) {
            var b =
this.percentStrCacheStore[a]; void 0 === b && (b = isNaN(this.paramLabels.decimalprecision) ? "2" : this.paramLabels.decimalprecision, b = this.percentStrCacheStore[a] = f(d(a, b, this.paramLabels.forcedecimals), this.paramLabels.decimalseparator, this.paramLabels.thousandseparator, this.paramLabels.thousandseparatorposition) + "%"); return b
        }, getCleanValue: function (a, b) {
            var d = this.cleaneValueCacheStore[a]; if (void 0 === d) {
                var f = this.baseConf, d = a + ""; f._REGinthousandseparator && (d = d.replace(f._REGinthousandseparator, "")); f._REGindecimalseparator &&
(d = d.replace(f._REGindecimalseparator, ".")); d = parseFloat(d); d = isFinite(d) ? d : NaN; this.cleaneValueCacheStore[a] = d = isNaN(d) ? null : b ? c(d) : d
            } return d
        }, dataLabels: function (a, b) { var c = this.Y[b] || (b ? this.Y[1] : this.Y[0]), d, c = c && c.dataLabelConf || this.baseConf; d = c.cacheStore[a]; void 0 === d && (d = c.cacheStore[a] = g(a, c)); return d }, yAxis: function (a, b) { var c = this.Y[b] || (b ? this.Y[1] : this.Y[0]), d, c = c && c.yAxisLabelConf || this.baseConf; d = c.cacheStore[a]; void 0 === d && (d = c.cacheStore[a] = g(a, c)); return d }, xAxis: function (a) {
            var b =
this.paramX.cacheStore[a]; void 0 === b && (b = this.paramX.cacheStore[a] = g(a, this.paramX)); return b
        }, sYAxis: function (a) { var b = this.Y[1], c, b = b && b.yAxisLabelConf || this.baseConf; c = b.cacheStore[a]; void 0 === c && (c = b.cacheStore[a] = g(a, b)); return c }, scale: function (a) { var b = this.paramScale.cacheStore[a]; void 0 === b && (b = this.paramScale.cacheStore[a] = g(a, this.paramScale)); return b }, getCleanTime: function (a) {
            var b; this.timeConf.inputDateFormat && Date.parseExact && (b = Date.parseExact(a, this.timeConf.inputDateFormat)); return b &&
b.getTime()
        }, legendValue: function (a) { var b = this.paramLegend.cacheStore[a]; void 0 === b && (b = this.paramLegend.cacheStore[a] = g(a, this.paramLegend)); return b }, legendPercentValue: function (a) { var b = this.percentStrCacheStore[a], c = this.paramLegend; void 0 === b && (b = isNaN(c.decimalprecision) ? "2" : c.decimalprecision, b = this.percentStrCacheStore[a] = f(d(a, b, c.forcedecimals), c.decimalseparator, c.thousandseparator, c.thousandseparatorposition) + "%"); return b }, getDateValue: function (a) {
            var b, c, d; a = /^dd/.test(this.timeConf.inputDateFormat) &&
a && a.replace(/(\d{1,2})\/(\d{1,2})\/(\d{2,4})/, "$2/$1/$3") || a; b = new Date(a); c = b.getTime(); !c && a && /\:/.test(a) && (a = a.split(":"), c = E(a[0], 0), d = E(a[1], 0), a = E(a[2], 0), c = 23 < c ? 24 === c && 0 === d && 0 === a ? c : 23 : c, d = 59 < d ? 59 : d, a = 59 < a ? 59 : a, b = new Date, b.setHours(c), b.setMinutes(d), b.setSeconds(a), c = b.getTime()); return { ms: c, date: b}
        }, getFormattedDate: function (a, c) {
            var d = "object" === typeof a && a || new Date(a), f = this.timeConf, g = b(c, f.outputDateFormat), k = d.getFullYear(), h = d.getMonth(), l = d.getDate(), s = d.getDay(), m = d.getMinutes(),
n = d.getSeconds(), d = d.getHours(), m = 9 < m ? "" + m : "0" + m, n = 9 < n ? "" + n : "0" + n, d = 9 < d ? "" + d : "0" + d; g.match(/dnl/) && (g = g.replace(/dnl/ig, f.days[s])); g.match(/dns/) && (g = g.replace(/dns/ig, f.days[s] && f.days[s].substr(0, 3))); g.match(/dd/) && (g = g.replace(/dd/ig, l)); g.match(/mnl/) && (g = g.replace(/mnl/ig, f.months[h])); g.match(/mns/) && (g = g.replace(/mns/ig, f.months[h] && f.months[h].substr(0, 3))); g.match(/mm/) && (g = g.replace(/mm/ig, h + 1)); g.match(/yyyy/) && (g = g.replace(/yyyy/ig, k)); g.match(/yy/) && (g = g.replace(/yy/ig, (k % 1E3 % 100 + "").replace(/^(\d)$/,
"0$1"))); g.match(/hh12/) && (g = g.replace(/hh12/ig, d % 12 || 12)); g.match(/hh/) && (g = g.replace(/hh/ig, d)); g.match(/mn/) && (g = g.replace(/mn/ig, m)); g.match(/ss/) && (g = g.replace(/ss/ig, n)); g.match(/ampm/) && (g = g.replace(/ampm/ig, 12 > d ? "AM" : "PM")); g.match(/ds/) && (g = g.replace(/ds/ig, f.daySuffix[l])); return g
        } 
        }; m.prototype.constructor = m; g = function (a, c) {
            if (null !== a) {
                a = Number(a); var g = a + "", h, l, s, m, n, t, B; h = 1 == c.formatnumberscale ? c.defaultnumberscale : ""; B = (B = g.split(".")[1]) ? B.length : c.forcedecimals ? "2" : ""; if (1 == c.formatnumberscale) {
                    g =
a; h = c.numberscalevalue; l = c.numberscaleunit; s = {}; var u = c.defaultnumberscale; m = 0; t = []; var J = []; if (c.scalerecursively) { for (m = 0; m < h.length; m++) if (n = E(h[m]) || 1E3, Math.abs(Number(g)) >= n && m < h.length - 1) u = g % n, g = (g - u) / n, 0 !== u && (t.push(u), J.push(l[m])); else { t.push(g); J.push(l[m]); break } t.reverse(); J.reverse(); s.value = t; s.scale = J } else { if (h.length === l.length) for (m = 0; m < h.length; m++) if (n = E(h[m]) || 1E3, Math.abs(Number(g)) >= n) u = l[m] || "", g = Number(g) / n; else break; s.value = g; s.scale = u } l = s; a = g = l.value; h = l.scale
                } if (c.scalerecursively &&
0 !== c.formatnumberscale && "0" !== c.formatnumberscale) {
                    h = l.value; l = l.scale; s = -1 == c.maxscalerecursion ? h.length : Math.min(h.length, c.maxscalerecursion); if (1 == c.formatnumber) for (g = "", t = 0; t < s; t++) m = 0 === t ? h[t] : Math.abs(h[t]), n = m + "", t == s - 1 && (n = d(m, b(c.decimalprecision, B), c.forcedecimals)), g = g + f(n, c.decimalseparator, c.thousandseparator, c.thousandseparatorposition) + l[t] + (t < s - 1 ? c.scaleseparator : ""); else for (g = "", t = 0; t < s; t++) g = g + (0 === t ? h[t] : Math.abs(h[t]) + "") + l[t] + (t < s - 1 ? c.scaleseparator : ""); g = (c.numberprefix ||
"") + g + (c.numbersuffix || "")
                } else 1 == c.formatnumber && (g = d(a, b(c.decimalprecision, B), c.forcedecimals), g = f(g, c.decimalseparator, c.thousandseparator, c.thousandseparatorposition)), g = (c.numberprefix || "") + g + h + (c.numbersuffix || ""); return g
            } 
        }; return m
    } (); d.extend(d.core, { formatNumber: function (a, b) { b = b && g(b) || {}; var c = t(b), d; N[c] ? d = N[c] : N[c] = d = new n.NumberFormatter(b, { useScaleRecursively: !0 }); return d.dataLabels(a) } }, !1); d.extend(d.core, { formatNumber: function (a, b, c, l) {
        c = c && g(c) || {}; var B = this.jsVars.instanceAPI ||
{}, m = B.numberFormatter, z; "" === t(c) ? m ? z = m : (m = this.getChartData(d.dataFormats.JSON, !0), m = m.data || {}, m = m.chart || {}, c = t(m), N[c] ? z = N[c] : N[c] = z = new n.NumberFormatter(m, B)) : (m = this.getChartData(d.dataFormats.JSON, !0), m = m.data || {}, m = m.chart || {}, m = u(u({}, m), c), c = t(m), N[c] ? z = N[c] : N[c] = z = new n.NumberFormatter(m, B)); switch ((b && b.toLowerCase ? b : "").toLowerCase()) { case "yaxisvalues": a = z.yAxis(a, l); break; case "xaxisvalues": a = z.xAxis(a); break; case "scale": a = z.scale(a); break; default: a = z.dataLabels(a, l) } return a
    } 
    },
!0)
} ]);
FusionCharts.register("module", ["private", "modules.renderer.js-dom", function () {
    var d = this.hcLib, n = this.window, E = n.document, u = d.extend2, l = "ontouchstart" in n; (function (b) {
        var d = function () {
            var b = {}, a; b.pointerdrag = { start: ["mousedown"], end: ["mouseup"], onStart: ["mousemove"], postHandlers: {}, preHandlers: {} }; b.pointerhover = { start: ["mouseover"], end: ["mouseout"] }; b.click = { start: ["click"] }; b.escape = { start: ["keydown"], preHandlers: { start: function (a) { a = a || n.event; return a.keyCode && 27 === a.keyCode ? !0 : !1 } } }; l && (a =
b.pointerdrag, a.start.push("touchstart"), a.end.push("touchend"), a.onStart.push("touchmove"), a.postHandlers.onStart = function (a) { a.preventDefault ? a.preventDefault() : a.returnValue = !1 }, a = b.click, a.start.push("touchstart")); return b
        } (), c; c = u({}, d); b.dem = new function () {
            var b = {}, a = {}, d = E.addEventListener ? function (a, b, c) { a.addEventListener(b, c, !1) } : function (a, b, c) { a.attachEvent("on" + b, c) }, l = E.removeEventListener ? function (a, b, c) { a.removeEventListener(b, c) } : function (a, b, c) { a.detachEvent("on" + b, c) }, t = function (a,
b, d) {
                var k = [], l, z, t; t = c[b]; d.start = function (b) { b = b || n.event; for (var c = t.onStart, k = t.end, h = [], l = [], m = c && c.length || 0; m--; ) h.push(g(a, c[m], d, "onStart")); for (m = k && k.length || 0; m--; ) l.push(g(a, k[m], d, "end")); d.startUn = d.startUn ? d.startUn.concat(h) : h; d.endUn = d.endUn ? d.endUn.concat(l) : l; d.state = "start"; d.closure(b) }; d.onStart = function (a) {
                    a = a || n.event; d.state = "on"; if (d.gDef && d.gDef.preHandlers && "function" === typeof d.gDef.preHandlers.onStart) d.gDef.preHandlers.onStart(a); d.closure(a); if (d.gDef && d.gDef.postHandlers &&
"function" === typeof d.gDef.postHandlers.onStart) d.gDef.postHandlers.onStart(a)
                }; d.end = function (a) { a = a || n.event; for (var b = d.startUn, c = d.endUn, f = b && b.length || 0; f--; ) b[f](); delete d.startUn; d.startUn = []; for (f = c && c.length || 0; f--; ) c[f](); delete d.endUn; d.endUn = []; d.state = "end"; d.closure(a) }; if (t) for (b = t.start, z = b.length; z--; ) (l = b[z]) && k.push(g(a, l, d, "start")); return k
            }, g = function (a, b, c, g) { g = g || "closure"; d(a, b, c[g]); return function () { l(a, b, c[g]) } }, k = function (a) {
                return function (b) {
                    b = b || n.event; a.handler.call(a.context ||
a.elem, { data: a.data, type: a.type, state: a.state, isGesture: a.isGesture, target: b.target || b.srcElement, originalEvent: b })
                } 
            }; return { listen: function (d, h, l, n, m) {
                var z = this; h = "string" === typeof h ? h.split(" ") : h; var B = h.length, u = [], N = function (a, b, c) { u.push(function () { z.unlisten(a, b, c) }) }, C, P, ba, da, xa; if (d.ownerDocument && d.ownerDocument === E) for (; B--; ) P = h[B], da = Boolean(c[P]), xa = "function" === typeof l ? l : l[B], ba = { handler: xa, elem: d, type: P, isGesture: da, gDef: da ? c[P] : null, data: n, context: m, start: [], end: [], links: { prev: null,
                    next: null
                }
                }, ba.closure = k(ba), da ? ((C = a[P]) || (C = a[P] = []), C.push(ba), t(d, P, ba)) : ((C = b[P]) || (C = b[P] = []), C.push(ba), g(d, P, ba)), N(d, P, xa); else for (; B--; ) P = h[B], xa = "function" === typeof l ? l : l[B], ba = { handler: xa, elem: d, type: P, isGesture: da, data: n, context: m, start: [], end: [], links: { prev: null, next: null} }, ba.closure = k(ba), (C = b[P]) || (C = b[P] = []), C.push(ba); return { unlisten: function () { for (var a = u.length; a--; ) u[a]() } }
            }, unlisten: function (d, g, k) {
                var n, m = !1, z, t; if (Boolean(c[g])) for (z = (n = a[g]) && n.length || 0; z--; ) {
                    if (t = n[z],
t.handler === k && t.elem === d) { var m = d, B = void 0, u = void 0, C = void 0, B = void 0; if (B = c[g]) for (B = B.start, C = B.length; C--; ) (u = B[C]) && l(m, u, t.start); n.splice(z, 1); m = !0 } 
                } else for (z = (n = b[g]) && n.length || 0; z--; ) t = n[z], t.handler === k && t.elem === d && (l(d, g, t.closure), n.splice(z, 1), m = !0); return m
            }, fire: function (a, c, d, g) {
                var k; if (a.ownerDocument && a.ownerDocument === E) E.createEvent ? (k = E.createEvent("HTMLEvents"), k.initEvent(c, !0, !0), d && (d.originalEvent ? d.originalEvent = k : u(k, d)), "function" === typeof a[c] && a[c].call(a), a.dispatchEvent(k)) :
(k = E.createEventObject(), k.eventType = c, d && (d.originalEvent ? d.originalEvent = k : u(k, d)), "function" === typeof a[c] && a[c].call(a), a.fireEvent("on" + c, k)), g && !k.returnValue && g(k); else for (g = (c = b[c]) && c.length || 0; g--; ) k = c[g], k.elem === a && k.closure(d)
            } 
            }
        } 
    })(d || n); (function (b) {
        function d(a, b) {
            var c = ""; E.defaultView && E.defaultView.getComputedStyle ? c = E.defaultView.getComputedStyle(a, "").getPropertyValue(b) : a.currentStyle && (b = b.replace(/\-(\w)/g, function (a, b) { return b.toUpperCase() }), c = a.currentStyle[b]); c = parseInt(c,
10); return isNaN(c) ? 0 : c
        } function c(b, c, d, f, h, l, n, m) { var z = c / N, u = a[l || "linear"](f - d, z), E = 0, J = function () { var a; E < z ? (a = u[E], b.style[h] = d + a + m, B && "opacity" === h && (a = 100 * Number(a), b.style.filter = "progid:DXImageTransform.Microsoft.Alpha(Opacity=" + a + ")"), E += 1, setTimeout(J, N)) : n && n() }; m = m || ""; setTimeout(J, N) } var l = { width: { suffix: "px" }, height: { suffix: "px" }, opacity: !0, top: { suffix: "px" }, left: { suffix: "px"} }, a = { linear: function (a, b) { for (var c = [], d = a / b, h = 0; h < b; h += 1) c[h] = d * (h + 1); return c } }, B = /msie/i.test(n.navigator.userAgent) &&
!n.opera, N = 40; b.danimate = u({ animate: function (a, b, k, f, h) { f = {}; var s = {}, n = function () { z += 1; z === m && "function" === typeof h && h() }, m = 0, z = 0, B, u; if (k < N) { for (u in b) a.style[u] = b[u]; h && h() } else for (u in b) l[u] && (m += 1, f[u] = b[u], s[u] = d(a, u), B = "object" === typeof l[u] && l[u].suffix, c(a, k, s[u], f[u], u, "linear", n, B)) } }, {})
    })(d || n)
} ]);
FusionCharts.register("module", ["private", "modules.renderer.js-colormanager", function () {
    var d = this.hcLib, n = d.pluckNumber, E = d.graphics.getDarkColor, u = d.graphics.getLightColor, l = "AFD8F8 F6BD0F 8BBA00 FF8E46 008E8E D64646 8E468E 588526 B3AA00 008ED6 9D080D A186BE CC6600 FDC689 ABA000 F26D7D FFF200 0054A6 F7941C CC3300 006600 663300 6DCFF6".split(" "), b = "8BBA00 F6BD0F FF654F AFD8F8 FDB398 CDC309 B1D0D2 FAD1B9 B8A79E D7CEA5 C4B3CE E9D3BE EFE9AD CEA7A2 B2D9BA".split(" "), P = d.defaultPaletteOptions = { paletteColors: [l,
l, l, l, l], bgColor: ["CBCBCB,E9E9E9", "CFD4BE,F3F5DD", "C5DADD,EDFBFE", "A86402,FDC16D", "FF7CA0,FFD1DD"], bgAngle: [270, 270, 270, 270, 270], bgRatio: ["0,100", "0,100", "0,100", "0,100", "0,100"], bgAlpha: ["50,50", "60,50", "40,20", "20,10", "30,30"], canvasBgColor: ["FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF"], canvasBgAngle: [0, 0, 0, 0, 0], canvasBgAlpha: ["100", "100", "100", "100", "100"], canvasBgRatio: ["", "", "", "", ""], canvasBorderColor: ["545454", "545454", "415D6F", "845001", "68001B"], canvasBorderAlpha: [100, 100, 100, 90, 100], showShadow: [0,
1, 1, 1, 1], divLineColor: ["717170", "7B7D6D", "92CDD6", "965B01", "68001B"], divLineAlpha: [40, 45, 65, 40, 30], altHGridColor: ["EEEEEE", "D8DCC5", "99C4CD", "DEC49C", "FEC1D0"], altHGridAlpha: [50, 35, 10, 20, 15], altVGridColor: ["767575", "D8DCC5", "99C4CD", "DEC49C", "FEC1D0"], altVGridAlpha: [10, 20, 10, 15, 10], anchorBgColor: ["FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF"], toolTipBgColor: ["FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF"], toolTipBorderColor: ["545454", "545454", "415D6F", "845001", "68001B"], baseFontColor: ["555555", "60634E",
"025B6A", "A15E01", "68001B"], borderColor: ["767575", "545454", "415D6F", "845001", "68001B"], borderAlpha: [50, 50, 50, 50, 50], legendBgColor: ["FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF"], legendBorderColor: ["545454", "545454", "415D6F", "845001", "D55979"], plotGradientColor: ["FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF"], plotBorderColor: ["333333", "8A8A8A", "FFFFFF", "FFFFFF", "FFFFFF"], plotFillColor: ["767575", "D8DCC5", "99C4CD", "DEC49C", "FEC1D0"], bgColor3D: ["FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF"], bgAlpha3D: ["100",
"100", "100", "100", "100"], bgAngle3D: [90, 90, 90, 90, 90], bgRatio3D: ["", "", "", "", ""], canvasBgColor3D: ["DDE3D5", "D8D8D7", "EEDFCA", "CFD2D8", "FEE8E0"], canvasBaseColor3D: ["ACBB99", "BCBCBD", "C8A06C", "96A4AF", "FAC7BC"], divLineColor3D: ["ACBB99", "A4A4A4", "BE9B6B", "7C8995", "D49B8B"], divLineAlpha3D: [100, 100, 100, 100, 100], legendBgColor3D: ["F0F3ED", "F3F3F3", "F7F0E8", "EEF0F2", "FEF8F5"], legendBorderColor3D: ["C6CFB8", "C8C8C8", "DFC29C", "CFD5DA", "FAD1C7"], toolTipbgColor3D: ["FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF"], toolTipBorderColor3D: ["49563A",
"666666", "49351D", "576373", "681C09"], baseFontColor3D: ["49563A", "4A4A4A", "49351D", "48505A", "681C09"], anchorBgColor3D: ["FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF"]
    }, l = d.colorManager = function (b, l) {
        var a = b.chart, B = d.extend2({}, P), N = l.defaultPaletteOptions || {}, t; B || (B = {}); for (t in N) B[t] = N[t]; B = this.paletteOptions = B; N = this.themeEnabled = a.palettethemecolor; this.paletteIndex = (0 < a.palette && 6 > a.palette ? a.palette : n(l.paletteIndex, 1)) - 1; this.iterator = 0; this.paletteColors = B.paletteColors[this.themeEnabled ? 0 :
this.paletteIndex]; t = a.palettecolors; void 0 !== t && null !== t && "" !== a.palettecolors && (this.paletteColors = a.palettecolors.split(",")); this.paletteLen = this.paletteColors.length; this.useFlatColors = n(a.useflatdataplotcolor, l.useFlatColor, 0); N && (this.paletteIndex = 5, B.bgColor.push(u(N, 35) + "," + u(N, 10)), B.bgAngle.push(270), B.bgRatio.push("0,100"), B.bgAlpha.push("50,50"), B.canvasBgColor.push("FFFFFF"), B.canvasBgAngle.push(0), B.canvasBgAlpha.push("100"), B.canvasBgRatio.push(""), B.canvasBorderColor.push(E(N, 80)),
B.canvasBorderAlpha.push(100), B.showShadow.push(1), B.divLineColor.push(E(N, 20)), B.divLineAlpha.push(40), B.altHGridColor.push(u(N, 20)), B.altHGridAlpha.push(15), B.altVGridColor.push(u(N, 80)), B.altVGridAlpha.push(10), B.anchorBgColor.push("FFFFFF"), B.toolTipBgColor.push("FFFFFF"), B.toolTipBorderColor.push(E(N, 80)), B.baseFontColor.push(N.split && N.split(",")[0]), B.borderColor.push(E(N, 60)), B.borderAlpha.push(50), B.legendBgColor.push("FFFFFF"), B.legendBorderColor.push(E(N, 80)), B.plotGradientColor.push("FFFFFF"),
B.plotBorderColor.push(E(N, 85)), B.plotFillColor.push(E(N, 85)), B.bgColor3D.push("FFFFFF"), B.bgAlpha3D.push("100"), B.bgAngle3D.push(90), B.bgRatio3D.push(""), B.canvasBgColor3D.push(u(N, 20)), B.canvasBaseColor3D.push(u(N, 40)), B.divLineColor3D.push(E(N, 20)), B.divLineAlpha3D.push(40), B.legendBgColor3D.push("FFFFFF"), B.legendBorderColor3D.push(E(N, 80)), B.toolTipbgColor3D.push("FFFFFF"), B.toolTipBorderColor3D.push(E(N, 80)), B.baseFontColor3D.push(N.split && N.split(",")[0]), B.anchorBgColor3D.push("FFFFFF"), B.tickColor &&
B.tickColor.push(E(N, 90)), B.trendDarkColor && B.trendDarkColor.push(E(N, 90)), B.trendLightColor && B.trendLightColor.push(u(N, B.TrendLightShadeOffset)), B.msgLogColor && B.msgLogColor.push(u(N, 80)), B.dialColor && B.dialColor.push(E(N, 95) + ",FFFFFF," + E(N, 95)), B.dialBorderColor && B.dialBorderColor.push(E(N, 95) + ",FFFFFF," + E(N, 95)), B.pivotColor && B.pivotColor.push(u(N, 95) + ",FFFFFF," + u(N, 95)), B.pivotBorderColor && B.pivotBorderColor.push(E(N, 95) + ",FFFFFF," + E(N, 95)), B.pointerBorderColor && B.pointerBorderColor.push(E(N,
75)), B.pointerBgColor && B.pointerBgColor.push(E(N, 75)), B.thmBorderColor && B.thmBorderColor.push(E(N, 90)), B.thmFillColor && B.thmFillColor.push(u(N, 55)), B.cylFillColor && B.cylFillColor.push(u(N, 55)), B.periodColor && B.periodColor.push(u(N, 10)), B.winColor && B.winColor.push("666666"), B.lossColor && B.lossColor.push("CC0000"), B.drawColor && B.drawColor.push("666666"), B.scorelessColor && B.scorelessColor.push("FF0000"), B.gridColor && B.gridColor.push(u(N, 30)), B.categoryBgColor && B.categoryBgColor.push(u(N, 10)), B.dataTableBgColor &&
B.dataTableBgColor.push(u(N, 10)), B.gridResizeBarColor && B.gridResizeBarColor.push(E(N, 90)), B.scrollBarColor && B.scrollBarColor.push(u(N, 50)))
    }; l.prototype = { getColor: function (b) { return this.paletteOptions[b][this.paletteIndex] }, getPlotColor: function (b) { var d = this.paletteColors; b = this.useFlatColors ? this.getColor("plotFillColor") : d[b % this.paletteLen]; b || (this.iterator === this.paletteLen && (this.iterator = 0), b = d[this.iterator], this.iterator += 1); return b }, parseColorMix: function (b, d) {
        var a = [], l, n, t, g, k, f, h,
s, P, m; d = d.replace(/\s/g, ""); d = d.toLowerCase(); if ("" === d || null === d || void 0 === d) a = [b]; else for (n = d.split(","), t = b.split(","), g = Math.max(n.length, t.length, 1), k = n[0], f = t[0], P = /[\{\}]/ig, m = 0; m < g; m++) h = (n[m] || k).replace(P, ""), s = t[m] || f, "color" == h ? a.push(s) : "light" == h.substr(0, 5) ? (l = h.indexOf("-"), l = -1 == l ? 1 : h.substr(l + 1, h.length - l), l = 100 - l, a.push(u(s, l))) : "dark" == h.substr(0, 4) ? (l = h.indexOf("-"), l = -1 == l ? 1 : h.substr(l + 1, h.length - l), l = 100 - l, a.push(E(s, l))) : a.push(h); return a
    }, parseAlphaList: function (b, d) {
        var a =
b.split(","), l = [], u, t = 100, g; for (g = 0; g < d; g++) u = n(a[g]), void 0 !== u && null !== u && (t = u), l[g] = t; return l.join()
    }, parseRatioList: function (b, d) { var a = b.split(","), l = [], n = 0, t, g; for (g = 0; g < d; g++) t = a[g], t = isNaN(t) || void 0 === t ? 0 : Math.abs(Number(t)), t = 100 < t ? 100 : t, l[g] = t, n += t; n = 100 < n ? 100 : n; if (a.length < d) for (g = a.length; g < d; g++) l[g] = (100 - n) / (d - a.length); l[-1] = 0; return l.join() } 
    }; l.prototype.constructor = l; d.defaultGaugePaletteOptions = { paletteColors: [b, b, b, b, b], bgColor: ["CBCBCB,E9E9E9", "CFD4BE,F3F5DD", "C5DADD,EDFBFE",
"A86402,FDC16D", "FF7CA0,FFD1DD"], bgAngle: [270, 270, 270, 270, 270], bgRatio: ["0,100", "0,100", "0,100", "0,100", "0,100"], bgAlpha: ["50,50", "60,50", "40,20", "20,10", "30,30"], toolTipBgColor: ["FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF"], toolTipBorderColor: ["545454", "545454", "415D6F", "845001", "68001B"], baseFontColor: ["555555", "60634E", "025B6A", "A15E01", "68001B"], tickColor: ["333333", "60634E", "025B6A", "A15E01", "68001B"], trendDarkColor: ["333333", "60634E", "025B6A", "A15E01", "68001B"], trendLightColor: ["f1f1f1", "F3F5DD",
"EDFBFE", "FFF5E8", "FFD1DD"], pointerBorderColor: ["545454", "60634E", "415D6F", "845001", "68001B"], pointerBgColor: ["545454", "60634E", "415D6F", "845001", "68001B"], canvasBgColor: ["FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF"], canvasBgAngle: [0, 0, 0, 0, 0], canvasBgAlpha: ["100", "100", "100", "100", "100"], canvasBgRatio: ["", "", "", "", ""], canvasBorderColor: ["545454", "545454", "415D6F", "845001", "68001B"], canvasBorderAlpha: [100, 100, 100, 90, 100], altHGridColor: ["EEEEEE", "D8DCC5", "99C4CD", "DEC49C", "FEC1D0"], altHGridAlpha: [50,
35, 10, 20, 15], altVGridColor: ["767575", "D8DCC5", "99C4CD", "DEC49C", "FEC1D0"], altVGridAlpha: [10, 20, 10, 15, 10], borderColor: ["767575", "545454", "415D6F", "845001", "68001B"], borderAlpha: [50, 50, 50, 50, 50], legendBgColor: ["ffffff", "ffffff", "ffffff", "ffffff", "ffffff"], legendBorderColor: ["545454", "545454", "415D6F", "845001", "D55979"], plotFillColor: ["767575", "D8DCC5", "99C4CD", "DEC49C", "FEC1D0"], plotBorderColor: ["999999", "8A8A8A", "6BA9B6", "C1934D", "FC819F"], msgLogColor: ["717170", "7B7D6D", "92CDD6", "965B01", "68001B"],
        TrendLightShadeOffset: 30
    }
} ]);
FusionCharts.register("module", ["private", "modules.renderer.js-annotations", function () {
    var d = this, n = d.core, E = d.hcLib, u = d.window, l = /msie/i.test(u.navigator.userAgent) && !u.opera, b = E.addEvent, P = E.removeEvent, c = E.hasTouch, J = u.Number, a = c ? 6 : 5, B = "rgba(192,192,192," + (l ? 0.002 : 1E-6) + ")", l = u.Math, N = l.abs, t = l.min, g = l.max, k = l.sin, f = l.cos, h = l.PI, s = 4 * h, sa = 2 * h, m = h / 180, z = d.extend, H = E.pluck, M = E.pluckNumber, $ = E.graphics.convertColor, C = E.getValidValue, V = E.parseUnsafeString, ba = E.setImageDisplayMode, da = E.graphics.parseColor,
xa = E.setLineHeight, ua = E.getMouseCoordinate, S = { style: {} }, ca = E.toRaphaelColor, ha = function (a, b) { return { start: -a, end: -b, angle: a - b} }, w = function (a, b, c, d, f) {
    var g, k, h = 0, l = 0; k = void 0 === b || null === b ? 1 : b; var m; if (!a || !a.toString) return { value: c, hasDynamicMacros: !1 }; a = a.toString(); a = a.toLowerCase().replace(/\s/g, ""); if (c = a.match(/^[\+\-]?\d+(\.\d+)?|[\+\-]\d+(\.\d+)?/g)) { for (b = 0; b < c.length; b += 1) h += Number(c[b]) || 0; h *= k } if (c = a.match(/^[\+\-]?(\$[a-z0-9\.]+)|[\+\-](\$[a-z0-9\.]+)/g)) for (b = 0; b < c.length; b += 1) {
        g = c[b];
        var s = d, n = f, w = g.split("."), z = void 0, t = void 0, C = 0; for (k = void 0; z = w.shift(); ) switch (typeof (t = s[z])) { case "object": s = t[z]; break; case "function": t = t(w, n), "-" === g.charAt() && (t *= -1), k = !0; default: C += J(t) || 0, w.length = 0 } g = C; k && (m = !0); l += g
    } if (c = a.match(/^[\+\-]?\$\d+(\.\d+)?|[\+\-]\$\d+(\.\d+)?/g)) for (b = 0; b < c.length; b += 1) l = l + Number(c[b].replace("$", "")) || 0; return { value: h + l, hasDynamicMacros: m}
}, Q = function (a, b, c) {
    if (!b.removed) {
        b = b.data("annotation"); var f = b.getRenderer(), g = ua(f.container, c), k = g.annotationOptions =
b.options, h = g.groupOptions = b.group.options; g._shape = b; "id" in k && (g.annotationId = k.id); "id" in h && (g.groupId = h.id); d.raiseEvent(a, g, f.fusionCharts, c)
    } 
}, K, aa, ja; aa = function (a, b, c, d, f) { this.options = a; this.attrs = {}; this.css = {}; this.bounds = {}; this.shared = b; this.snaps = c || {}; this.annotations = f; this.items = b = []; this._idstore = d; a.id && (this._id = a.id, d[a.id] = this); if (a = a.items) for (d = 0, c = a.length; d < c; d += 1) b.push(new ja(a[d], this)) }; z(aa.prototype, { scaleImageX: 1, scaleImageY: 1, scaleText: 1, scaleValue: 1, scaleValueComplement: 1,
    scaleX: 1, scaleY: 1
}); aa.prototype.setup = function () { var a = this.options, b = this.shared, c = this.getRenderer(); c && (this.isBelow = 0 !== M(a.showbelow, a.showbelowchart, b.showbelow), this.useTracker = !this.isBelow && c.layers.tracker && this.shared.useTracker, this.raiseOwnEvents = b.interactionevents) }; aa.prototype.scale = function () {
    var a = this.options, b = this.shared, c = this.bounds, d = this.snaps, f = this.getRenderer(), g = b.rootxscale, k = b.rootyscale, h = c.xs = M(a.xscale, b.xscale, 100) / 100, l = c.ys = M(a.yscale, b.yscale, 100) / 100, m, s, n;
    f && (this.scaleText *= l, this.scaleImageX *= h, this.scaleImageY *= l, 0 !== M(a.autoscale, b.autoscale) && (h = M(a.origw, b.origw), l = M(a.origh, b.origh), h = f.chartWidth / h, l = f.chartHeight / l, f = 0 !== M(a.constrainedscale, b.constrainedscale), m = h < l ? h : l, s = f ? m : h, n = f ? m : l, this.scaleValue = aa.prototype.scaleValue * m, this.scaleValueComplement = aa.prototype.scaleValueComplement * (f ? m : h < l ? l : h), this.scaleX = aa.prototype.scaleX * s, this.scaleY = aa.prototype.scaleX * n, c.xs *= s, c.ys *= n, g *= s, k *= n, "1" == H(a.scaletext, b.scaletext) && (this.scaleText =
aa.prototype.scaleText * n), "1" == H(a.scaleimages, b.scaleimages) && (this.scaleImageX = aa.prototype.scaleImageX * s, this.scaleImageY = aa.prototype.scaleImageY * n)), c.x = w(H(a.x, a.xpos), g, 0, d, this.isBelow).value + M(a.grpxshift, b.grpxshift, 0), c.y = w(H(a.y, a.ypos), k, 0, d, this.isBelow).value + M(a.grpyshift, b.grpyshift, 0), this.xshift = M(a.xshift, b.xshift, 0), this.yshift = M(a.yshift, b.yshift, 0))
}; aa.prototype.draw = function () {
    var a = this.getRenderer(), b = this.options, c = this.bounds, d = this.items, f = a && a.layers.dataset, g = this.wrapper;
    if (a) { g || (this.wrapper = g = a.paper.group("annotations"), f && (this.isBelow ? g.insertBefore(f) : g.insertAfter(a.layers.datalabels || f))); this.wrapper.attr({ x: 0, y: 0, visibility: M(b.visible, 1) ? "" : "hidden" }).translate(c.x, c.y); b = 0; for (c = d.length; b < c; b += 1) a = d[b], a.scale(!0), a.queueDraw ? a.queue() : (a.setup(), a.draw()); return this } 
}; aa.prototype.destroy = function () { for (var a = this.wrapper, b = this.items, c; c = b.shift(); ) c.destroy(); a && (this.wrapper = a.remove()); this._idstore[this._id] === this && delete this._idstore[this._id] };
    aa.prototype.addItem = function (a, b) { var c; this.items.push(c = new ja(a, this, this._idstore)); b && null !== this.getRenderer() && (c.scale(), c.setup(), c.draw()); return c }; aa.prototype.removeItem = function (a) { for (var b = this.items, c = b.length; c--; ) if (a === b[c]._id) return b.splice(c, 1) }; aa.prototype.getRenderer = function () { return this.annotations && this.annotations.getRenderer() || null }; ja = function (a, b) {
        var c = !1, d; this.options = a; this.group = b; this.args = []; this.attrs = {}; this.attrsTracker = {}; this.style = {}; this.bounds = {};
        this._idstore = b._idstore; a.id && (this._id = a.id, b._idstore[a.id] = this); this.type = a.type && a.type.toLowerCase && a.type.toLowerCase(); for (d in ja.eventNames) "function" === typeof a[d] && (this[d] = a[d], c = !0); this.hasEvents = c; "function" === typeof a.onload && (this.onload = a.onload)
    }; d.extend(ja.prototype, { getAbsoluteBounds: function () { var a = this.bounds, b = a.x1, c = a.y1, d = a.x2, f = a.y2, k = t(b, d), h = t(c, f), b = g(b, d) - k, c = g(c, f) - h; return { x: k, width: b, y: h, height: c, r: a.r, unscaled: { width: b / a.xs, height: c / a.ys}} }, queue: function () { this.group.annotations.shapesToDraw.push(this) },
        scale: function (a) {
            var b = this, c = b.group, d = c.bounds, f = b.bounds, g = b.options, k = c.snaps, h = H(g.x, g.xpos), l = H(g.y, g.ypos), m = H(g.tox, g.toxpos), s = H(g.toy, g.toypos), n = f.xs = d.xs, d = f.ys = d.ys, z = M(g.xshift, c.xshift, 0), t = M(g.yshift, c.yshift, 0), C; C = function (d, f, g, k) { d = w(d, f, g, k, c.isBelow); d.hasDynamicMacros && a && (b.queueDraw = !0); return d.value }; b.hasDimension = !0; b.hasDimensionX = !0; b.hasDimensionY = !0; f.x1 = C(h, n, 0, k) + z; void 0 === m ? (b.hasDimension = !1, b.hasDimensionX = !1, f.x2 = f.x1) : f.x2 = C(m, n, 0, k) + z; f.y1 = C(l, d, 0, k) + t; void 0 ===
s ? (b.hasDimension = !1, b.hasDimensionY = !1, f.y2 = f.y1) : f.y2 = C(s, d, 0, k) + t; ja.angularShapeTypes[b.type] && (f.angles = ha(C(g.startangle, 1, 0, k), C(g.endangle, 1, 360, k))); f.r = C(g.radius, c.scaleValue, 0, k)
        }, setup: function () {
            var a = this.options, b = this.group, c = b.options, d = this.attrs, f = this.style, g = b.scaleValue, k = M(c.fillalpha, c.alpha, 100), h = this.fillAlpha = H(a.fillalpha, a.alpha, k), l = this.fillColor = H(a.fillcolor, a.color, c.color), m = this.fillPattern = H(a.fillpattern && a.fillpattern.toLowerCase && a.fillpattern.toLowerCase(),
c.fillpattern && c.fillpattern.toLowerCase && c.fillpattern.toLowerCase()), s = this.bordered = M(a.showborder, ja.borderedShapeTypes[this.type], !!C(a.bordercolor)), n = this.borderColor = H(a.bordercolor, c.bordercolor, l), k = this.borderAlpha = M(a.borderalpha, a.alpha, c.borderalpha, k), w = this.dashed = !!M(a.dashed, 0), t = M(a.borderthickness, a.thickness, 2) * g; this.link = H(a.link, c.link); this.shadow = "1" == H(a.showshadow, c.showshadow); void 0 === l && (l = ja.borderedShapeTypes[this.type] && "none" || "#ff0000", void 0 === n && (n = "#ff0000"));
            s && t ? (d.stroke = $(n, k), d["stroke-linecap"] = "round", d["stroke-width"] = t, w && (d["stroke-dasharray"] = [M(a.dashlen, 5) * g, M(a.dashgap, 3) * g])) : d.stroke = "none"; this.fillOptions = { gradientUnits: "objectBoundingBox", color: l, alpha: h, ratio: H(a.fillratio, c.fillratio), angle: 360 - M(a.fillangle, 0), radialGradient: "radial" === m }; this.link && (f.cursor = "pointer", f._cursor = "hand"); d.visibility = M(a.visible, 1) ? "" : "hidden"; this.useTracker = b.useTracker; this.toolText = V(H(a.tooltext, c.tooltext)); if (this.useTracker || this.link || this.toolText) z(this.attrsTracker,
{ stroke: B, fill: B }), this.link && (this.attrsTracker.ishot = +new Date); this.raiseOwnEvents = b.raiseOwnEvents
        }, draw: function () {
            var a = this.getRenderer(), c = this.type, d = this.attrs, f = this.style, k = a && a.paper, h = ja.types[c] && ja.types[c].call && ja.types[c].call(this, a), l = ja.imageShapeTypes[h], m = ja.textShapeTypes[h], s = l || m || ja.trackerShapeTypes[h], n = this.link || this.toolText, w = this.wrapper, c = this.tracker, z = a && a.layers.tracker || this.group.wrapper, t = !1, C = c || w, B = ja.eventNames, u = ja.ownEvents, E, J; if (a) {
                if (h) {
                    if (w) if (w.elemType !==
h) { if (this.ownEventsAttached) { for (J in u) C["un" + J].apply(w, u[J]); this.ownEventsAttached = !1 } w = w.remove() } else if (this.hasEvents) for (E in B) (J = this[E]) && J.eventAttached && (P(C.node, B[E], J), J.eventAttached = !1); l || (d.fill = ca(this.fillOptions)); w ? w.attr(d).css(f) : (this.args.push(this.group.wrapper), w = this.wrapper = k[h].apply(k, this.args).attr(d).css(f), w.elemType = h, w.data("annotation", this), t = !0, this.args.pop()); !this.shadow || this.shadowAdded || l || m ? w.shadow(this.shadowAdded = !1) : w.shadow(this.shadowAdded =
!0, g(this.borderAlpha, this.fillOptions.alpha) / 100); n ? this.useTracker && (c || (this.args.push(z), c = this.tracker = s ? k.rect(0, 0, 0, 0, 0, z) : k[h].apply(k, this.args), this.args.pop()), c.attr(d).attr(this.attrsTracker)) : c && (c = c.remove()); C = c || w; if (this.raiseOwnEvents && !this.ownEventsAttached) { for (J in u) C[J].apply(w, u[J]); this.ownEventsAttached = !0 } this.link && C.click(a.linkClickFN, this); this.toolText && (C.tooltip(this.toolText || ""), this.group.wrapper.trackTooltip(!0)); if (this.hasEvents) for (E in B) (J = this[E]) && !J.eventAttached &&
(b(C.node, B[E], J, this), J.eventAttached = !0); l || (c && s && (a = w.getBBox(), c.attr({ x: a.x, y: a.y, width: a.width, height: a.height })), t && this.onload && this.onload(d))
                } return this
            } 
        }, destroy: function () {
            var a = this.wrapper, b = this.tracker, c = b || a, d = ja.eventNames, f = ja.ownEvents, g, k; if (a) { if (this.ownEventsAttached) { for (k in f) c["un" + k].apply(a, f[k]); this.ownEventsAttached = !1 } if (this.hasEvents) for (g in d) (k = this[g]) && k.eventAttached && (P(c.node, d[g], k), k.eventAttached = !1); b && (this.tracker = b.remove()); this.wrapper = a.remove() } this._idstore[this._id] ===
this && delete this._idstore[this._id]
        }, getRenderer: function () { return this.group && this.group.getRenderer() || null } 
    }); d.extend(ja, { imageShapeTypes: { image: !0 }, angularShapeTypes: { circle: !0, arc: !0 }, textShapeTypes: { text: !0 }, trackerShapeTypes: { image: !0, text: !0 }, borderedShapeTypes: { path: !0, line: !0 }, eventNames: { onmouseover: c ? "touchstart" : "mouseover", onmouseout: "mouseout", onmousemove: c ? "touchmove" : "mousemove", onclick: "click" }, ownEvents: { click: [function (a) { Q("annotationClick", this, a) } ], hover: [function (a) {
        Q("annotationRollOver",
this, a)
    }, function (a) { Q("annotationRollOut", this, a) } ]
    }, textAlignOptions: { left: "start", right: "end", center: "middle" }, textVerticalAlignOptions: { top: "bottom", middle: "middle", bottom: "top" }, textRotationOptions: { 0: "0", 1: "270", right: "90", cw: "90", left: "270", ccw: "270" }, types: { rectangle: function () { var a = this.args, b = this.attrs, c = this.getAbsoluteBounds(), d = 0.5 * c.width; c.r > d && (c.r = d); a[0] = b.x = c.x; a[1] = b.y = c.y; a[2] = b.width = c.width; a[3] = b.height = c.height; a[4] = b.r = c.r; return "rect" }, line: function () {
        var b = this.attrs,
c = this.bounds; this.args[0] = b.path = ["M", c.x1, c.y1, "L", c.x2, c.y2]; 1 === b["stroke-width"] && (b["shape-rendering"] = "crisp"); b["stroke-width"] < a && (this.attrsTracker["stroke-width"] = a); this.bordered && this.dashed && (this.attrsTracker["stroke-dasharray"] = "solid"); return "path"
    }, path: function () { var a = this.attrs, b = this.bounds; this.args[0] = a.path = this.options.path; a.transform = ["T", b.x1, b.y1, "S", b.xs, b.ys, b.x1, b.y1]; 1 === a["stroke-width"] && (a["shape-rendering"] = "crisp"); return "path" }, polygon: function () {
        var a = this.args,
b = this.attrs, c = this.options, d = this.bounds, f = this.group, g = f.snaps; a[0] = w(c.sides, 1, 5, g, f.isBelow).value; a[1] = d.x1; a[2] = d.y1; a[3] = d.r; a[4] = w(c.startangle, 1, 0, g, f.isBelow).value; a[5] = 0; b.polypath = a.slice(0); return "polypath"
    }, circle: function (a) {
        var b = this.args, c = this.attrs, d = this.options, g = this.bounds, l = a.chartWidth, n = a.chartHeight, z = this.group.scaleValueComplement, t = this.group.snaps, C = g.angles, B = this.group; a = g.r; H(d.radius) || (g.r = l < n ? l * g.xs : n * g.ys, g.r = a = 0.3 * g.r); d = w(d.yradius, z, a, t, B.isBelow).value;
        this.fillPattern || (this.fillOptions.radialGradient = !0, this.fillPattern = "radial"); "radial" === this.fillPattern && (this.fillOptions.cx = this.fillOptions.cy = 0.5); l = C.angle % 360; if (!l && a === d) return b[0] = c.cx = g.x1, b[1] = c.cy = g.y1, b[2] = c.r = g.r, "circle"; l || (C.start -= 0.001); z = C.start * m; l = C.end * m; n = C.angle * m; C = 0 > n ? 0 : 1; n = N(n % s); n = n >= h && n <= sa ? 1 : 0; t = g.x1; B = g.y1; g = t + f(z) * a; z = B + k(z) * d; t += f(l) * a; l = B + k(l) * d; b[0] = c.path = ["M", g, z, "A", a, d, 0, n, C, t, l, "Z"]; return "path"
    }, arc: function (a) {
        var b = this.options, c = this.args, d = this.attrs,
f = this.bounds, g = a.chartWidth; a = a.chartHeight; var k = this.group, h = k.scaleValue, l = f.angles; H(b.radius) || (f.r = g < a ? g * f.xs : a * f.ys, f.r *= 0.3); f.innerR = w(b.innerradius, h, 0.8 * f.r, this.group.snaps, k.isBelow).value; f.innerR > f.r && (f.innerR += f.r, f.r = f.innerR - f.r, f.innerR -= f.r); this.fillPattern || (this.fillOptions.radialGradient = !0, this.fillPattern = "radial"); "radial" === this.fillPattern && (this.fillOptions.cx = this.fillOptions.cy = 0.5); c[0] = f.x1; c[1] = f.y1; c[2] = f.r; c[3] = f.innerR; c[4] = l.start * m; c[5] = l.end * m; d.ringpath =
c.slice(0); return "ringpath"
    }, text: function (a) {
        var b = this.args, c = this.style, d = this.attrs, f = this.group, g = this.bounds, k = this.options, h = this.getAbsoluteBounds(), l = H(k.align, f.options.textalign, "center").toLowerCase(), m = H(k.valign, f.options.textvalign, "middle").toLowerCase(), s = V(H(k.text, k.label)), n = a.logic.smartLabel, w = M(k.wrap, f.options.wraptext, 1), t, C, B = H(k.rotatetext, f.options.rotatetext, "0").toLowerCase(), B = ja.textRotationOptions[B], u = "0" !== B ? "y" : "x", E = a.options.orphanStyles; a = z({}, E.defaultStyle.style ||
{}); E = f.id && E[f.id.toLowerCase()] || S; a = z(a, E.style); var E = parseFloat(a.fontSize), J = H(k.font, f.options.font, a.fontFamily), f = M(k.fontsize, f.options.fontsize, E) * f.scaleText; w && (t = M(k.wrapwidth, this.hasDimensionX ? h.width / g.xs : void 0), C = M(k.wrapheight, this.hasDimensionY ? h.height / g.ys : void 0), t && (t *= g.xs), C && (C *= g.ys)); c.fontFamily = J; c.fontWeight = M(k.bold, k.isbold, 0) ? "bold" : "normal"; M(k.italic, k.isitalic, 0) && (c.fontStyle = "italic"); k.bgcolor && (!d["text-bound"] && (d["text-bound"] = []), d["text-bound"][0] = da(k.bgcolor));
        k.bordercolor && (!d["text-bound"] && (d["text-bound"] = []), d["text-bound"][1] = da(k.bordercolor), d["text-bound"][2] = M(k.borderthickness, 1), d["text-bound"][3] = M(k.padding, 1)); k.fontcolor && (d.fill = da(k.fontcolor), this.fillOptions && (this.fillOptions.color = d.fill)); c.fontSize = f + "px"; f === E ? c.lineHeight = a.lineHeight : xa(c); d["text-anchor"] = ja.textAlignOptions[l] || ja.textAlignOptions.center; n.setStyle(c); c = n.getSmartText(s, t, C, !1); d["vertical-align"] = ja.textVerticalAlignOptions[m] || ja.textVerticalAlignOptions.middle;
        d["text-anchor"] === ja.textAlignOptions.left ? h[u] += M(k.leftmargin, 0) : d["text-anchor"] === ja.textAlignOptions.center && (h[u] += 0.5 * M(k.leftmargin, 0)); "0" !== B && (d.rotation = [parseFloat(B), h.x, h.y]); b[0] = d.x = h.x; b[1] = d.y = h.y; b[2] = d.text = c.text; c.tooltext && (d.title = c.tooltext); delete d.stroke; delete d["stroke-weight"]; return "text"
    }, image: function (a) {
        var b = this, c = b.style, d = a.chartWidth, f = a.chartHeight; a = b.options; var k = b.attrs, h = b.args, l = C(a.url), m = b.group.scaleImageX * H(Number(a.xscale), 100) / 100, s = b.group.scaleImageY *
H(Number(a.yscale), 100) / 100, n = b.getAbsoluteBounds(), w = { width: 1, height: 1 }, t; if (!l) return h[0] = k.x = n.x, h[1] = k.y = n.y, h[2] = k.width = n.width, h[3] = k.height = n.height, h[4] = k.r = n.r, "rect"; t = new u.Image; t.onload = function () {
    w = ba("none", "top", "left", 100, 0, d, f, t); delete w.x; delete w.y; w = z(w, { width: (b.hasDimensionX ? n.unscaled.width : w.width) * m, height: (b.hasDimensionY ? n.unscaled.height : w.height) * s }); setTimeout(function () {
        var a, d, f; if (a = b.wrapper) {
            a.attr(w); if (d = b.tracker) f = a.getBBox(), d.attr({ x: f.x, y: f.y, width: f.width,
                height: f.height
            }); a.css({ opacity: c.opacity = g(M(b.fillAlpha, b.borderAlpha), b.borderAlpha) / 100 })
        } b.onload && b.onload(w)
    }, 0)
}; t.src = l; h[0] = k.src = l; h[1] = k.x = n.x; h[2] = k.y = n.y; h[3] = k.width = (b.hasDimensionX ? n.unscaled.width : w.width) * m; h[4] = k.height = (b.hasDimensionY ? n.unscaled.height : w.height) * s; c.opacity = g(M(b.fillAlpha, b.borderAlpha), b.borderAlpha) / 100; delete k.stroke; delete k.fill; delete k["stroke-linecap"]; return "image"
    } 
    }
    }); K = function () { this.groups = []; this._idstore = {}; this._options = {} }; E.Annotations = K;
    d.extend(K.prototype, { reset: function (a, b, c) { var d = this.groups, f; this.clear(); if (c) { f = {}; for (var g in c) switch (typeof c[g]) { case "object": case "function": f["-$" + g] = f["$" + g] = f["+$" + g] = c[g]; break; default: f["$" + g] = f["+$" + g] = c[g], f["-$" + g] = -1 * c[g] } f = this._literals = f } b && (this._options = b); if (a && a.groups && d) for (c = 0; c < a.groups.length; c += 1) d.push(new aa(a.groups[c], b, f, this._idstore, this)) }, getRenderer: function () { return this._renderer }, addGroup: function (a) {
        var b = this.getRenderer(); this.groups.push(a = new aa(a,
this._options, this._literals, this._idstore, this)); b && (a.setup(), a.scale(), a.draw()); return a
    }, addItem: function (a, b, c) { var f, g = this.getRenderer(); "string" === typeof a ? f = this._idstore[a] : (c = b, b = a); if (f && f.addItem) { if (!g && c) { d.raiseWarning(this, "04031411430", "run", "Annotations~addItem()", "Cannot draw the shape if the group has not been drawn. Use Annotations~draw() to draw the group and pass the renderer to it."); return } a = f.addItem(b, c) } else a = this.addGroup({}).addItem(b, c); return a }, draw: function (a) {
        var b =
this.groups, c, d; if (b && (this._renderer = a || this._renderer)) for (c = 0, d = b.length; c < d; c++) a = b[c], a.setup(), a.scale(), a.draw()
    }, clear: function () { var a = this.groups, b; if (a) { for (; b = a.shift(); ) b.destroy(); this.shapesToDraw = [] } }, dispose: function () { var a; this.disposing = !0; this.clear(); for (a in this) delete this[a]; this.disposed = !0 }, hide: function (a) { if (a = this._idstore[a]) return a.attrs.visibility = "hidden", a.wrapper && a.wrapper.hide(), a }, show: function (a) {
        if (a = this._idstore[a]) return a.attrs.visibility = "", a.wrapper &&
a.wrapper.show(), a
    }, update: function (a, b, c) { a = this._idstore[a]; var d; if (a && b) { if ("object" === typeof b) for (d in b.id && delete b.id, b.type && delete b.type, b) a.options[(d + "").toLowerCase()] = b[d] + ""; else a.options[(b + "").toLowerCase()] = c + ""; a.wrapper && (a.scale(), a.setup(), a.draw()); return a } }, destroy: function (a) { var b = this._idstore[a], c = b.group; b && "function" === typeof b.destroy && (c && c.removeItem(a), b.destroy()) }, shapesToDraw: []
    }); d.core.addEventListener("beforeinitialize", function (a) {
        "javascript" === a.sender.options.renderer &&
(a.sender.annotations = new K)
    }); d.core.addEventListener("disposed", function (a) { a.sender.annotations && a.sender.annotations.dispose() }); d.addEventListener("internal.animationComplete", function (a) { var b = (a = a.sender.annotations) && a.shapesToDraw, c = b && b.length, d, f; if (c) { for (f = 0; f < c; f++) d = b[f], d.queueDraw = !1, d.scale(), d.setup(), d.draw(); a.shapesToDraw = [] } }); n.addEventListener("rendered", function (a, b) {
        if ("javascript" === b.renderer) {
            var c = a.sender, d = c.jsVars || {}, f = d.instanceAPI; d.hcObj && f && f.drawAnnotations ?
(c.showAnnotation || (c.showAnnotation = function () { c.annotations.show.apply(c.annotations, arguments) }), c.hideAnnotation || (c.hideAnnotation = function () { c.annotations.hide.apply(c.annotations, arguments) })) : (delete c.showAnnotation, delete c.hideAnnotation)
        } 
    })
} ]);
FusionCharts.register("module", ["private", "modules.renderer.js-thememanager", function () {
    var d = this, n, E, u, l = /\s+!important$/, b = /\\!important$/, P = function (a, b) { for (var c = b.length, d = -1; c--; ) if (a === b[c]) { d = c; break } return d }, c = function (a, b, d, h, l) {
        var n, m, z, t; l ? (h.push(a), l.push(b)) : (h = [a], l = [b]); if (b instanceof Array) for (n = 0; n < b.length; n += 1) {
            try { m = a[n], z = b[n] } catch (B) { continue } if ("object" !== typeof z) d && void 0 === z || (a[n] = z); else {
                if (null === m || "object" !== typeof m) m = a[n] = z instanceof Array ? [] : {}; t = P(z, l);
-1 !== t ? m = a[n] = h[t] : c(m, z, d, h, l)
            } 
        } else for (n in b) { try { m = a[n], z = b[n] } catch (u) { continue } if (null !== z && "object" === typeof z) if (t = Object.prototype.toString.call(z), "[object Object]" === t) { if (null === m || "object" !== typeof m) m = a[n] = {}; t = P(z, l); -1 !== t ? m = a[n] = h[t] : c(m, z, d, h, l) } else "[object Array]" === t ? (null !== m && m instanceof Array || (m = a[n] = []), t = P(z, l), -1 !== t ? m = a[n] = h[t] : c(m, z, d, h, l)) : a[n] = z; else a[n] = z } return a
    }, J = function (a, b, d) {
        if ("object" !== typeof a && "object" !== typeof b) return null; if ("object" !== typeof b ||
null === b) return a; "object" !== typeof a && (a = b instanceof Array ? [] : {}); c(a, b, d); return a
    }, a = function (a) { var c = { important: !1, str: "" }; if (!a) return c; a = a.toString(); l.test(a) ? (a = a.replace(l, ""), c.important = !0) : (a = a.replace(b, "!imporant"), c.important = !1); c.str = a; return c }, B = function (a, b) {
        var c, d, l, n, m, t, u = 0, E = 0; for (c in a) if (d = a[c], d instanceof Array) for (t = d.length, m = 0; m < t; m += 1) {
            if (n = d[m], "object" === typeof n) if ("category" === c) if ("true" === n.vline) { if (l = b.component("vline", u, n)) N(n, l), u += 1 } else {
                if (l = b.component("category",
E, n)) N(n, l), E += 1
            } else if (l = b.component(c, m, n)) N(n, l), B(n, l)
        } else "object" === typeof d && (l = b.component(c, null, d)) && (N(d, l), B(d, l))
    }, N = function (b, c) { var d = c.getAll(), l, n; for (l in d) n = d[l].toString(), n = a(n), n.important ? b[l.toLowerCase()] = n.str : void 0 === b[l.toLowerCase()] && (b[l.toLowerCase()] = n.str) }, t = function (a, b) { var c = a.sender, l = c.getChartData(d.dataFormats.JSON, !0), n; l.error || ((n = l.data.chart.theme) ? u.themify(n, c, b.newType, l.data) : c.jsVars.themeObject && c.jsVars.themeObject.dispose()) }; n = function () {
        this.themeStore =
{}
    }; n.prototype = { constructor: n, add: function (a) { for (var b = 0, c = a.length, d; b < c; b += 1) (d = a[b].name) && (this.themeStore[d] = a[b]) }, themify: function (a, b, c, l) {
        var n = b.jsVars; a = a.split(","); var B = [], m = a.length, z, u; if (m) {
            for (u = 0; u < m; u += 1) { z = this.themeStore; var J; J = a[u]; J = J.replace(/^\s\s*/, ""); for (var P = /\s/, C = J.length; P.test(J.charAt(C -= 1)); ); J = J.slice(0, C + 1); (z = z[J]) && B.push(this.evaluateThemeJSON(z.theme, b, c)) } B.length ? (n.themeObject = new E(B, b, !1, l), this.applyTheme(b), b.addEventListener("chartTypeChanged",
t)) : d.raiseWarning("Theme file not found")
        } 
    }, evaluateThemeJSON: function (a, b, c) { var d = {}, l = b.jsVars, n = function (a) { var b, c; for (b in a) c = a[b], d[b] = c instanceof Array ? J(d[b] || [], c) : "object" === typeof c ? J(d[b] || {}, c) : c }; c = c || b.args.type; l.themeObject && (l.themeObject.dispose(), delete l.themeObject); n(a.base); c && a[c] && n(a[c]); return d }, applyTheme: function (a) { a = a.jsVars.themeObject; var b = a.getThemedJSONData().data; b && B(b, a) } 
    }; E = function (a, b, c, d) {
        this.themeArray = a; this.themeComponents = {}; this.base = {}; this.chartInstance =
b; this.isChildInstance = Boolean(c); this.themedData = c ? null : J({}, d); this.length = a.length; b = 0; for (c = a.length; b < c; b += 1) this.parse(a[b])
    }; E.prototype = { constructor: E, pushTheme: function (a) { a && (this.themeArray.push(a), this.parse(a), this.length += 1) }, popTheme: function () { }, parse: function (b) {
        var c = this.themeComponents, d = this.chartInstance, l = this.base, n, t, m; for (t in b) if ("string" === typeof b[t] || "number" === typeof b[t]) if (l[t]) { if (n = a(b[t]), m = a(l[t]), n.important || !m.important) l[t] = b[t] } else l[t] = b[t]; else c[t] ||
(c[t] = []), n = c[t], b[t] instanceof Array ? n.push(J([], b[t])) : "object" === typeof b[t] ? n.push(new E([b[t]], d, !0)) : "function" === typeof b[t] && n.push(b[t])
    }, merge: function (b) { var c = this.base, d = b.base, l = this.themeComponents, n = b.themeComponents, t, m, z; for (z in d) if (t = a(c[z]), m = a(d[z]), !t.important || m.important) c[z] = d[z]; for (z in n) l[z] = l[z] ? l[z].concat(n[z]) : [].concat(n[z]); this.length += b.length }, get: function (a) { return this.base[a] }, getAll: function () { return J({}, this.base) }, component: function (a, b, c) {
        var d = this.themeComponents,
l = this.chartInstance, n = new E([], l, !0), m, t, B; t = d[a]; if (!t) return null; a = 0; for (d = t.length; a < d; a += 1) B = t[a], "function" === typeof B ? (b = b || 0, n.pushTheme(B.call(l, b, c))) : B instanceof Array ? (b = b || 0, m = B.length, b %= m, m = B[b], m instanceof E ? n.merge(m) : "function" === typeof m ? n.pushTheme(m.call(l, b, c)) : n.pushTheme(m)) : B instanceof E ? n.merge(B) : n.pushTheme(B); return n
    }, getThemedJSONData: function () { return { data: this.themedData} }, dispose: function () {
        var a = this.themeComponents, b = this.chartInstance, c, d; for (c in a) if (d = a[c].length) {
            for (; d--; ) a[c][d].dispose &&
a[c][d].dispose(); delete a[c]
        } this.isChildInstance || b.removeEventListener("chartTypeChanged", t); this.dataWithoutTheme = this.isChildInstance = this.themeArray = this.base = this.chartInstance = this.themeComponents = null
    } 
    }; u = new n; d.registerTheme = function (a) { u.add(a) }; d.addEventListener("beforeDataUpdate", function (a, b) { var c = a.sender, l = FusionCharts.transcodeData(b.data, b.format, d.dataFormats.JSON), n = l.chart && l.chart.theme; n ? u.themify(n, c, c.args.type, l) : (c.jsVars.themeObject && c.jsVars.themeObject.dispose(), delete c.jsVars.themeObject) })
} ]);
FusionCharts.register("module", ["private", "modules.renderer.js-base", function () {
    var d = this, n = d.hcLib, E = d.window, u = E.document, l = n.BLANKSTRING, b = n.createTrendLine, P = "https:" === E.location.protocol ? "https://export.api3.fusioncharts.com/" : "http://export.api3.fusioncharts.com/", c = n.pluck, J = n.getValidValue, a = n.pluckNumber, B = n.getFirstValue, N = n.getDefinedColor, t = n.parseUnsafeString, g = n.FC_CONFIG_STRING, k = n.extend2, f = n.getDashStyle, h = n.parseTooltext, s = n.toPrecision, sa = n.regex.dropHash, m = n.HASHSTRING, z = n.getSentenceCase,
H = n.addEvent, M = E.Math, $ = n.TOUCH_THRESHOLD_PIXELS, C = n.CLICK_THRESHOLD_PIXELS, V = M.min, ba = M.max, da = M.abs, xa = M.ceil, ua = M.floor, S = M.log, ca = M.pow, ha = n.graphics.getColumnColor, w = n.getFirstColor, Q = n.setLineHeight, K = n.pluckFontSize, aa = n.getFirstAlpha, ja = n.graphics.getDarkColor, I = n.graphics.getLightColor, G = n.graphics.convertColor, la = n.COLOR_TRANSPARENT, Xa = n.POSITION_CENTER, ga = n.POSITION_TOP, Aa = n.POSITION_BOTTOM, za = n.POSITION_RIGHT, Ga = n.POSITION_LEFT, X = n.chartAPI, ma = n.graphics.mapSymbolName, Ba = X.singleseries,
W = X.multiseries, fa = n.COMMASTRING, Ca = n.STRINGUNDEFINED, qa = n.ZEROSTRING, Ya = n.ONESTRING, Fa = n.HUNDREDSTRING, Pa = n.PXSTRING, Kb = n.COMMASPACE, Na = !/fusioncharts\.com$/i.test(E.location.hostname), qb = { left: "start", right: "end", center: "middle" }, yb = n.BLANKSTRINGPLACEHOLDER, bb = n.BGRATIOSTRING, hb = n.COLOR_WHITE, db = n.TESTSTR, wb = n.graphics.getAngle, tb = n.axisLabelAdder, mb = n.falseFN, Fb = n.NumberFormatter, q = n.getLinkAction, D = n.getAxisLimits, r = n.createDialog, L = function (a, b) { return 0 < a ? S(a) / S(b || 10) : null }, U = n.hasTouch = void 0 !==
u.documentElement.ontouchstart, T = n.fireEvent = function (a, b, c, d) { n.dem.fire(a, b, c, d) }, pa = { 1: "bold", 0: "normal" }, ka = { 1: "italic", 0: "normal" }, ia = { 1: "underline", 0: "none" }, Ba = { font: function (a, b) { b.style.fontFamily = a }, size: function (a, b) { a && (b.style.fontSize = K(a) + Pa) }, color: function (a, b, c) { b.style.color = a && a.replace && a.replace(sa, m) || l; c && (b.color = b.style.color) }, bgcolor: function (a, b) { b.style.backgroundColor = a && a.replace && a.replace(sa, m) || l }, bordercolor: function (a, b) {
    b.style.border = "1px solid"; b.style.borderColor =
a && a.replace && a.replace(sa, m) || l
}, ishtml: l, leftmargin: function (b, c) { c.style.marginLeft = a(b, 0) + Pa }, letterspacing: function (b, c) { c.style.letterSpacing = a(b, 0) + Pa }, bold: function (a, b) { b.style.fontWeight = pa[a] || "" }, italic: function (a, b) { b.style.fontStyle = ka[a] || "" }, underline: function (a, b) { b.style.textDecoration = ia[a] || "" } 
}, va = n.chartPaletteStr = { chart2D: { bgColor: "bgColor", bgAlpha: "bgAlpha", bgAngle: "bgAngle", bgRatio: "bgRatio", canvasBgColor: "canvasBgColor", canvasBaseColor: "canvasBaseColor", divLineColor: "divLineColor",
    legendBgColor: "legendBgColor", legendBorderColor: "legendBorderColor", toolTipbgColor: "toolTipbgColor", toolTipBorderColor: "toolTipBorderColor", baseFontColor: "baseFontColor", anchorBgColor: "anchorBgColor"
}, chart3D: { bgColor: "bgColor3D", bgAlpha: "bgAlpha3D", bgAngle: "bgAngle3D", bgRatio: "bgRatio3D", canvasBgColor: "canvasBgColor3D", canvasBaseColor: "canvasBaseColor3D", divLineColor: "divLineColor3D", divLineAlpha: "divLineAlpha3D", legendBgColor: "legendBgColor3D", legendBorderColor: "legendBorderColor3D", toolTipbgColor: "toolTipbgColor3D",
    toolTipBorderColor: "toolTipBorderColor3D", baseFontColor: "baseFontColor3D", anchorBgColor: "anchorBgColor3D"
}
}, Ka = function () {
    var a = {}, b, c = function () {
        var f, e, g, r, q = 0, k, l, h = parseInt(d.core.options.resizeTrackingInterval, 10) || 300, n; for (f in a) q += 1, e = a[f], g = e.jsVars, k = e.ref, !e.disposed && (r = k && k.parentNode) && (l = k.style) && (/\%/g.test(l.width) || /\%/g.test(l.height)) ? (k = r.offsetWidth, n = r.offsetHeight, !g.resizeLocked && (k && g._containerOffsetW !== k || n && g._containerOffsetH !== n) && (e.resizeTo && e.resizeTo(), g._containerOffsetW =
k, g._containerOffsetH = n)) : (delete a[f], q -= 1); b = q ? setTimeout(c, h) : clearTimeout(b)
    }; return function (f, e) { var g = f.jsVars, r = e || f.ref && f.ref.parentNode || {}; g._containerOffsetW = r.parentNode.offsetWidth; g._containerOffsetH = r.parentNode.offsetHeight; a[f.id] = f; b || (b = setTimeout(c, parseInt(d.core.options.resizeTrackingInterval, 10) || 300)) } 
} (), ra = { getExternalInterfaceMethods: function () {
    var a = X[this.jsVars.type], a = a && a.eiMethods, b = "saveAsImage,print,exportChart,getXML,hasRendered,signature,cancelExport,getSVGString,lockResize,showChartMessage,",
c; if ("string" === typeof a) b += a + fa; else if (void 0 !== a || null !== a) for (c in a) b += c + fa; return b.substr(0, b.length - 1)
}, drawOverlayButton: function (a) {
    var b = this.jsVars, c = b.overlayButton, f, e; if (a && a.show) {
        c || (c = b.overlayButton = u.createElement("span"), n.dem.listen(c, "click", function () { d.raiseEvent("OverlayButtonClick", a, b.fcObj) })); f = a.message ? a.message : "Back"; c.appendChild(u.createTextNode(f)); b.overlayButtonMessage = f; f = { border: "1px solid " + (a.borderColor ? a.borderColor.replace(sa, m) : "#7f8975"), backgroundColor: a.bgColor ?
a.bgColor.replace(sa, m) : "#edefec", fontFamily: a.font ? a.font : "Verdana,sans", color: "#" + a.fontColor ? a.fontColor : "49563a", fontSize: (a.fontSize ? a.fontSize : "10") + Pa, padding: (a.padding ? a.padding : "3") + Pa, fontWeight: 0 === parseInt(a.bold, 10) ? "normal" : "bold", position: "absolute", top: "0", right: "0", _cursor: "hand", cursor: "pointer"
        }; for (e in f) c.style[e] = f[e]; b.hcObj.container.appendChild(c); b.overlayButtonActive = !0
    } else c && (b.overlayButton = c.parentNode.removeChild(c), b.overlayButtonActive = !1, delete b.overlayButtonMessage)
},
    print: function (a) { return this.jsVars.hcObj && this.jsVars.hcObj.hasRendered && this.jsVars.hcObj.print(a) }, exportChart: function (a) { var b = this.jsVars.hcObj; return b && b.options && b.options.exporting && b.options.exporting.enabled ? b.exportChart(a) : !1 }, getSVGString: function () { return this.jsVars && this.jsVars.hcObj && this.jsVars.hcObj.paper && this.jsVars.hcObj.paper.toSVG() }, resize: function () {
        var a = this.jsVars, b = a.container, c = a.hcObj; c && (c && c.destroy && c.destroy(), n.createChart(a.fcObj, b, a.type, void 0, void 0, !1,
!0), delete a.isResizing)
    }, lockResize: function (a) { return "boolean" !== typeof a ? !!this.jsVars.resizeLocked : this.jsVars.resizeLocked = a }, showChartMessage: function (a, b, c) { var d = this.jsVars, e = d.hcObj; d.msgStore[a] && (a = d.msgStore[a]); b && e && e.hasRendered ? a ? e.showMessage(a, c) : e.hideLoading() : (e && e.destroy && e.destroy(), n.createChart(d.fcObj, d.container, d.type, void 0, a)); return a }, signature: function () { return "FusionCharts/3.4.0 (XT)" } 
}, Sa = n.HCstub = function (b, c, d, f) {
    b = b.chart; var e = a(b.charttopmargin, f.charttopmargin,
15), g = a(b.chartrightmargin, f.chartrightmargin, 15), r = a(b.chartbottommargin, f.chartbottommargin, 15), q = a(b.chartleftmargin, f.chartleftmargin, 15), k = e + r, h = q + g; d *= 0.7; c *= 0.7; k > d && (e -= (k - d) * e / k, r -= (k - d) * r / k); h > c && (q -= (h - c) * q / h, g -= (h - c) * g / h); c = { _FCconf: { 0: { stack: {} }, 1: { stack: {} }, x: { stack: {} }, oriCatTmp: [], noWrap: !1, marginLeftExtraSpace: 0, marginRightExtraSpace: 0, marginBottomExtraSpace: 0, marginTopExtraSpace: 0, marimekkoTotal: 0 }, chart: { alignTicks: !1, renderTo: l, ignoreHiddenSeries: !1, events: {}, reflow: !1, spacingTop: e,
    spacingRight: g, spacingBottom: r, spacingLeft: q, marginTop: e, marginRight: g, marginBottom: r, marginLeft: q, borderRadius: 0, plotBackgroundColor: "#FFFFFF", style: {}, animation: a(b.defaultanimation, b.animation, 1) ? { duration: 500 * a(b.animationduration, 1)} : !1
}, colors: "AFD8F8 F6BD0F 8BBA00 FF8E46 008E8E D64646 8E468E 588526 B3AA00 008ED6 9D080D A186BE CC6600 FDC689 ABA000 F26D7D FFF200 0054A6 F7941C CC3300 006600 663300 6DCFF6".split(" "), credits: { href: n.CREDIT_HREF, text: n.CREDIT_STRING, enabled: Na }, global: {}, labels: { items: [] },
    lang: {}, legend: { enabled: !0, symbolWidth: 12, borderRadius: 1, backgroundColor: "#FFFFFF", initialItemX: 0, title: { text: l, x: 0, y: 0, padding: 2 }, scroll: {}, itemStyle: {} }, loading: {}, plotOptions: { series: { pointPadding: 0, borderColor: "#333333", events: {}, animation: a(b.animation, b.defaultanimation, 1) ? { duration: 1E3 * a(b.animationduration, 1)} : !1, states: { hover: { enabled: !1 }, select: { enabled: !1} }, dataLabels: { enabled: !0, color: "#555555", style: {}, formatter: function () {
        return this.point.showPercentValues ? f.numberFormatter.percentValue(this.percentage) :
this.point.displayValue
    } 
    }, point: { events: {}}
    }, area: { states: { hover: { enabled: !1} }, marker: { lineWidth: 1, radius: 3, states: { hover: { enabled: !1 }, select: { enabled: !1}}} }, radar: { states: { hover: { enabled: !1} }, marker: { lineWidth: 1, radius: 3, states: { hover: { enabled: !1 }, select: { enabled: !1}}} }, areaspline: { states: { hover: { enabled: !1} }, marker: { lineWidth: 1, radius: 3, states: { hover: { enabled: !1 }, select: { enabled: !1}}} }, line: { shadow: !0, states: { hover: { enabled: !1} }, marker: { lineWidth: 1, radius: 3, states: { hover: { enabled: !1 }, select: { enabled: !1}}} },
        scatter: { states: { hover: { enabled: !1} }, marker: { lineWidth: 1, radius: 3, states: { hover: { enabled: !1 }, select: { enabled: !1}}} }, bubble: { states: { hover: { enabled: !1} }, marker: { lineWidth: 1, radius: 3, states: { hover: { enabled: !1 }, select: { enabled: !1}}} }, spline: { states: { hover: { enabled: !1} }, marker: { lineWidth: 1, radius: 3, states: { hover: { enabled: !1 }, select: { enabled: !1}}} }, pie: { size: "80%", allowPointSelect: !0, cursor: "pointer", point: { events: { legendItemClick: b.interactivelegend === qa ? mb : function () { this.slice() } }} }, pie3d: { size: "80%",
            allowPointSelect: !0, cursor: "pointer", point: { events: { legendItemClick: b.interactivelegend === qa ? mb : function () { this.slice() } }}
        }, column: {}, floatedcolumn: {}, column3d: {}, bar: {}, bar3d: {}
    }, point: {}, series: [], subtitle: { text: l, style: {} }, symbols: [], title: { text: l, style: {} }, toolbar: {}, tooltip: { style: {} }, xAxis: { steppedLabels: { style: {} }, labels: { x: 0, style: {}, enabled: !1 }, lineWidth: 0, plotLines: [], plotBands: [], title: { style: {}, text: l }, tickWidth: 0, scroll: { enabled: !1} }, yAxis: [{ startOnTick: !1, endOnTick: !1, title: { style: {},
        text: l
    }, tickLength: 0, labels: { x: 0, style: {} }, plotBands: [], plotLines: []
    }, { tickLength: 0, gridLineWidth: 0, startOnTick: !1, endOnTick: !1, title: { style: {}, text: l }, labels: { x: 0, style: {}, enabled: !1, formatter: function () { return this.value !== yb ? this.value : l } }, opposite: !0, plotBands: [], plotLines: []}], exporting: { buttons: { exportButton: {}, printButton: { enabled: !1}}}
}; b.palettecolors && "string" === typeof b.palettecolors && (c.colors = b.palettecolors.split(fa)); return f.hcJSON = c
}, na = n.placeVerticalAxis = function (b, c, d, f, e, r, q,
k, h, n) {
    var D = d[g], m = D.smartLabel, L, s, t, w, U = 0, z = D.marginRightExtraSpace, C = D.marginLeftExtraSpace, B = {}, T = {}, u = {}, pa = b.plotLines, E = b.plotBands, D = c.verticalAxisValuesPadding, ia = isNaN(c.fixedValuesPadding) ? 0 : c.fixedValuesPadding, G = D - ia, I = c.verticalAxisValuesPadding, ka = c.verticalAxisNamePadding, ra = c.verticalAxisNameWidth, va = c.rotateVerticalAxisName && String(c.rotateVerticalAxisName).toLowerCase(), P = "none" !== va, Ka = b.offset ? b.offset : 0, K = 0, Sa = 0, N = 0, Ua = 0, M = 0, Da = 0, V = 0, ib, H, ya, ta, D = 2, V = q ? z + 5 : C + 4, kb = ba(a(d.chart.plotBorderWidth,
1), 0), na = b.showLine ? b.lineThickness : kb, Q = function (a, b) { var d, e; a && a.label && void 0 !== J(a.label.text) && (ya = a.label, ya.style && ya.style !== H && (H = ya.style, m.setStyle(H)), L = m.getOriSize(a.label.text), e = (d = L.width) ? d + 2 : 0, a.isGrid ? (B[b] = { width: d, height: L.height, label: ya }, Ua <= e && (Ua = e, c.lYLblIdx = b)) : a.isTrend && (q && ya.textAlign === Ga || ya.textAlign === za ? (T[b] = { width: d, height: L.height, label: ya }, M = ba(M, e)) : (u[b] = { width: d, height: L.height, label: ya }, Da = ba(Da, e)))) }, cb = function (a, c) {
    var d, v = c ? U : U + a; s = s || {}; if (0 < v) return P ?
(v < s.height && (s = m.getSmartText(b.title.text, e, v)), d = s.height) : (v < s.width && (s = m.getSmartText(b.title.text, v, e)), d = s.width), b.title._actualWidth = d, b.title.text = s.text, s.tooltext && (b.title.originalText = s.tooltext), c ? v - d + a : v - d; b.title.text = l; return 0
}, Va = function (a, b, c) { for (var d in a) a[d].label.x = b, a[d].label.y = c }, N = 0; for (ib = E.length; N < ib; N += 1) Q(E[N], N); N = 0; for (ib = pa.length; N < ib; N += 1) Q(pa[N], N); b.title && b.title.text != l && (H = b.title.style, m.setStyle(H), t = m.getOriSize(db).height, b.title._originalText = b.title.text,
P ? (b.title.rotation = "cw" === va ? 90 : 270, s = m.getSmartText(b.title.text, e, r), U = s.height, w = t) : (b.title.rotation = 0, s = m.getSmartText(b.title.text, void 0 !== ra ? ra : r, e), U = s.width, w = 20)); 0 < Da && (Sa = Da + I); h && (f = a(f.chart.maxlabelwidthpercent, 0), 1 <= f && 100 >= f && (h = f * h / 100, Ua > h && (Ua = h))); K = ba(M, Ua); K += K ? G + ia : 0; 0 < U && (K += U + ka + V); (function () {
    if (Sa + K > r) {
        ta = Sa + K - r; if (Sa) { if (I >= ta) { I -= ta; return } ta -= I; I = 0 } if (G + ka >= ta) ka >= ta ? ka -= ta : (G -= ta - ka, ka = 0); else {
            ta -= G + ka; ka = G = 0; if (20 < Da) if (M > Ua) {
                if (Da - M >= ta) { Da -= ta; return } if (M - Da >=
ta) { M -= ta; return } M > Da ? (ta -= M - Da, M = Da) : (ta -= Da - M, Da = M); if (2 * (M - Ua) >= ta) { Da -= ta / 2; M -= ta / 2; return } ta -= 2 * (M - Ua); Da = M = Ua
            } else { if (Da - 20 >= ta) { Da -= ta; return } ta -= Da - 20; Da = 20 } if (M > Ua) { if (M - Ua >= ta) { M -= ta; return } ta -= M - Ua; M = Ua } U - w >= ta ? U -= ta : (ta -= U - w, U = w, Da >= ta ? Da = 0 : (ta -= Da, Da = 0, U >= ta ? U = 0 : (ta -= U, U = 0, Ua >= ta && (M = Ua -= ta))))
        } 
    } 
})(); N = function (a, b) {
    var c, d = 0, p = b ? Da - 2 : Da + a - 2, v; if (0 < Da) {
        for (v in u) ya = u[v].label, u[v].width > p ? (ya.style && ya.style !== H && (H = ya.style, m.setStyle(H)), c = m.getSmartText(ya.text, p, e, !0), ya.text = c.text,
c.tooltext && (ya.originalText = c.tooltext), u[v].height = c.height, d = ba(d, c.width)) : d = ba(d, u[v].width); return b ? p - d + a : p - d
    } for (v in u) u[v].label.text = l; return 0
} (0, !0); N = cb(N, !0); N = function (a) {
    var b = 0, c = ba(Ua, M) + a - 2, d; if (0 < c) {
        for (d in B) ya = B[d].label, B[d].width > c ? (ya.style && ya.style !== H && (H = ya.style, m.setStyle(H)), a = m.getSmartText(ya.text, c, e, !0), ya.text = a.text, a.tooltext && (ya.originalText = a.tooltext), B[d].height = a.height, b = ba(b, a.width)) : b = ba(b, B[d].width); for (d in T) ya = T[d].label, T[d].width > c ? (ya.style &&
ya.style !== H && (H = ya.style, m.setStyle(H)), a = m.getSmartText(ya.text, c, e, !0), ya.text = a.text, a.tooltext && (ya.originalText = a.tooltext), T[d].height = a.height, b = ba(b, a.width)) : b = ba(b, T[d].width); return c - b
    } for (d in B) B[d].label.text = l; for (d in T) T[d].label.text = l; return 0
} (N); N = cb(N); h = c.verticalAxisNamePadding - ka; N && h && (N > h ? (ka += h, N -= h) : (ka += N, N = 0)); h = c.verticalAxisValuesPadding - (G + ia); N && h && (N > h ? (G += h, N -= h) : (G += N, N = 0)); h = c.verticalAxisValuesPadding - I; N && h && (N > h ? (I += h, N -= h) : (I += N, N = 0)); 0 < Da && (Sa = Da + I); K =
ba(M, Ua); K += K ? G + ia : 0; 0 < U && (K += U + ka + V); h = ba(M, Ua); h += 0 < h ? G + ia : 0; 0 < U ? (P ? U < s.height && (s = m.getSmartText(b.title.text, e, U)) : (U < s.width && (s = m.getSmartText(b.title.text, U, e)), b.title.y = -((s.height - t) / 2)), b.title.text = s.text, s.tooltext && (b.title.originalText = s.tooltext), b.title.margin = h + ka + V + (P ? U - t : U / 2)) : b.title.text = l; t = -(G + ia + Ka + C + 2); z = z + I + Ka + 2; V = ba(M, Ua); b.labels.style && (D = 0.35 * parseInt(b.labels.style.fontSize, 10)); q ? (0 < Da && Va(u, t, D), 0 < V && (Va(B, z, D), Va(T, z, D))) : (0 < Da && Va(u, z, D), 0 < V && (Va(B, t, D), Va(T, t,
D))); b.labels._textY = D; b.labels._righttX = z; b.labels._leftX = t; K = K || na; Sa = Sa || (k ? 0 : kb); n ? (d.chart.marginLeft += q ? Sa : K - n, d.chart.marginRight += q ? K - n : Sa) : (d.chart.marginLeft += q ? Sa : K, d.chart.marginRight += q ? K : Sa); return Sa + K
}, W = n.titleSpaceManager = function (b, c, d, f) {
    var e = this.snapLiterals || (this.snapLiterals = {}); c = c.chart; var r = t(c.caption), q = t(c.subcaption), k = a(c.captionpadding, 10), h = k, n = b[g], D = this.smartLabel || n.smartLabel, m = !1, s, L = 0, w, U, z = 0, C = 0, B = c = 0, T = b.title, u = b.subtitle, pa = ba(a(b.chart.plotBorderWidth,
1), 0), ia = s = 0, E = (T.horizontalPadding || 0) + (T.alignWithCanvas ? b.chart.marginLeft : 0), G = T.alignWithCanvas ? d : n.width; k < pa && (k = pa + 2); r !== l && (w = T.style, c = a(parseInt(w.fontHeight, 10), parseInt(w.lineHeight, 10), 12)); q !== l && (U = u.style, B = a(parseInt(U.fontHeight, 10), parseInt(U.lineHeight, 10), 12)); if (0 < c || 0 < B) L = c + B + k, L > f ? (z = L - f, m = !0, z < k ? k -= z : (z -= k, k = 0, B > z ? (C = B - z + 10, B = 0, u._originalText = u.text, u.text = "") : (z -= B, B = 0, c > z && (C = c - z), c = 0, T._originalText = T.text, T.text = ""))) : C = f - L, 0 < c && (D.setStyle(w), c += C, s = D.getSmartText(r,
d, c), C = c - s.height, T.height = c = s.height, T.text = s.text, s.tooltext && (T.originalText = s.tooltext), s = s.width), 0 < B && (D.setStyle(U), B += C, d = D.getSmartText(q, d, B), C = B - d.height, B = d.height, u.text = d.text, u.height = d.height, d.tooltext && (u.originalText = d.tooltext), ia = d.width), m && 0 < C && (k += V(h - k, C)), L = c + B + k; L = L || pa; T.isOnTop ? (e.captionstarty = b.chart.marginTop, b.chart.marginTop += L) : (b.chart.marginBottom += L, e.captionstarty = T.y = n.height - b.chart.marginBottom + k, b.chart.marginTop += 5, L += 5); T.align === Ga ? d = b = 0 : T.align === za ?
(b = G - s, d = G - ia) : (b = (G - s) / 2, d = (G - ia) / 2); e.captionstartx = E + b - 2; e.captionwidth = s + 4; e.captionendx = e.captionstartx + e.captionwidth; e.captionstarty = e.captionstarty || 0; e.captionheight = c + 2; e.captionendy = e.captionstarty + e.captionheight; e.subcaptionstartx = E + d - 2; e.subcaptionwidth = ia + 4; e.subcaptionendx = e.subcaptionstartx + e.subcaptionwidth; e.subcaptionstarty = e.subcaptionstarty || e.captionendy || 0; e.subcaptionheight = B + 2; e.subcaptionendy = e.subcaptionstarty + e.subcaptionheight; return L
}, ya = n.stepYAxisNames = function (a,
b, c, d, e, f) {
    var r = 0, q = d.plotLines, k = [], h, n = d.plotLines.length; b = b[g].smartLabel; for (var D = parseFloat(K(c.basefontsize, 10)), m; r < n; r += 1) c = q[r], c.isGrid && c.label && c.label.text && (k.push(c), 0 === c.value && (h = k.length - 1)); if (n = k.length) if (d.labels.style ? b.setStyle(d.labels.style) : k[0].label && k[0].label.style && b.setStyle(d.labels.style), r = b.getOriSize("W").height, f || (r += 0.4 * D), a /= n - 1, a < r) {
        f = ba(1, xa(r / a)); for (r = a = h; r < n; r += 1) c = k[r], r === e && ((r - a) % f && m && (m.label.text = ""), a = e), c && c.label && ((r - a) % f ? c.label.text =
l : m = c); for (r = a = h; 0 <= r; r -= 1) c = k[r], r === e && ((a - r) % f && m && (m.label.text = ""), a = e), c && c.label && ((a - r) % f ? c.label.text = l : m = c)
    } 
}, Da = n.placeHorizontalAxis = function (b, c, d, f, e, r, q) {
    var k = d[g], h = f && f.chart || {}, n, D, m, s, L, t, w, U, z, B, C, T, u = 0, pa = 0, ia = 10, E = 1, G = 0, I = 0, ka = 0, ra = 0, va = !1, N = !1, K = !1, P = a(h.labelstep, 0), Ka = a(h.xaxisminlabelwidth, 0), Sa = c.labelDisplay, Da = c.rotateLabels, M = c.horizontalLabelPadding, Ua = k.marginBottomExtraSpace, ta = d.chart.marginLeft, ya = d.chart.marginRight, H = k.smartLabel, ib = k.plotBorderThickness, kb =
c.catCount, Q = c.slantLabels, na = e / (b.max - b.min), Va = 0, cb = 0, Za = 0, S = 0, Cb = f && f.chart || {}, hc = 1E3 * a(Cb.updateinterval, Cb.refreshinterval), cc = Cb.datastreamurl, X = Boolean(this.realtimeEnabled && hc && void 0 !== cc), $, aa, da, fa, ca, W, la, sa, qa, ja, ga, Ja, ma, ha, oa, Oa, Ba, Pa, eb, Fa, La, ub, vb, Ya, nb, Vb = null, Ib = null, Ia, Xb, tb, Mb, Nb, Yb, Jb, Wb, Gb, wa, Qb, fc, Ha = [], Pb = [], Eb, $a = 0, Bb = 0, Tb, gc, pb, bb, $b, Na, jb, db = c.horizontalAxisNamePadding, Hb = 0, ab = c.staggerLines, Ab = Va, hb = !1, ac, bc, wb, mb = !1, Kb, yb, Fb, sc, Hc, Vc, nc, Dc, Lc, xc, Mc, Ec, Ic; b.labels.style &&
(t = b.labels.style, H.setStyle(t), U = H.getOriSize("W"), ia = H.lineHeight, w = U.width + 4, T = H.getOriSize("WWW").width + 4); b.title && b.title.text != l && (t = b.title.style, H.setStyle(t), I = H.getOriSize("W").height, b.title.rotation = 0, s = H.getSmartText(b.title.text, e, r), pa = s.height); ta != parseInt(h.chartleftmargin, 10) && (Jb = !0); ya != parseInt(h.chartrightmargin, 10) && (Wb = !0); void 0 !== h.canvaspadding && "" !== h.canvaspadding && (mb = !0); Gb = e - q; switch (Sa) {
        case "none": va = K = !0; Da && (u = Q ? 300 : 270, U = ia, ia = w, w = U); break; case "rotate": u = Q ?
300 : 270; U = ia; ia = w; w = U; va = !0; break; case "stagger": N = va = !0; z = ua((r - I) / ia); z < ab && (ab = z); break; default: Da && (u = Q ? 300 : 270, U = ia, ia = w, w = U)
    } k.isBar && (va = !0); wa = 0; Qb = b.plotLines; if (typeof d._FCconf.isXYPlot !== Ca || k.isBar) {
        $ = {}; W = ca = 0; ja = qa = null; Pa = {}; hb = !0; na = e / (b.max - b.min); Kb = function (a, c, e) {
            var v, f, g, F, r, q; q = a.plotObj; r = a.labelTextWidth; r || (L = q.label, L.style && L.style !== t && (t = L.style, H.setStyle(t)), r = H.getOriSize(L.text).width + 4, a.oriWidth = r, r > aa && (r = aa), a.labelTextWidth = r, a.leftEdge = q.value * na - r / 2, a.rightEdge =
q.value * na + r / 2, e && (r = V(r, 2 * (D.value - b.min) * na + d.chart.marginLeft), a.labelTextWidth = r)); if (typeof c !== Ca) {
                if (e = c.plotObj, L = e.label, L.style && L.style !== t && (t = L.style, H.setStyle(t)), c.oriWidth ? g = c.oriWidth : (g = H.getOriSize(L.text).width + 4, c.oriWidth = g), g > aa && (g = aa), c.labelTextWidth = g, c.leftEdge = e.value * na - g / 2, c.rightEdge = e.value * na + g / 2, v = q.value * na, f = v + r / 2, F = e.value * na, g = F - g / 2, g < f) if (v + w < F - w) f -= g, v = F - v, a.labelTextWidth = f > v ? V(r, v) : ba(w, r - f / 2), c.labelTextWidth = 2 * (v - a.labelTextWidth / 2), a.leftEdge = q.value *
na - a.labelTextWidth / 2, a.rightEdge = q.value * na + a.labelTextWidth / 2, c.leftEdge = e.value * na - c.labelTextWidth / 2, c.rightEdge = e.value * na + c.labelTextWidth / 2; else return c.labelTextWidth = 0, e.label.text = l, !1
            } else e && (r = V(r, 2 * (b.max - D.value) * na + d.chart.marginRight), a.labelTextWidth = r, a.leftEdge = q.value * na - r / 2, a.rightEdge = q.value * na + r / 2); a.nextCat = c; return !0
        }; N ? ab > gc ? ab = gc : 2 > ab && (ab = 2) : ab = 1; for (jb = Qb.length; wa < jb; wa += 1) (D = Qb[wa]) && D.label && typeof D.label.text !== Ca && (D.isGrid ? (fa = { plotObj: D }, D.isCat && (sa = wa % ab,
$[sa] || ($[sa] = []), qa ? (ja = fa, $[sa].push(ja)) : (ja = qa = fa, $[sa].push(qa))), Ha.push(fa)) : D.isTrend && Pb.push({ plotObj: D })); fc = b.plotBands; wa = 0; for (jb = fc.length; wa < jb; wa += 1) (D = fc[wa]) && D.isTrend && D.label && typeof D.label.text !== Ca && Pb.push({ plotObj: D }); if (Ha.length) if (!K && !u) if (k.distributedColumns) for (wa = 0, jb = Ha.length; wa < jb; wa += 1) Oa = Ha[wa], Ba = wa % ab, D = Oa.plotObj, D.label && D.isCat && (0 <= wa - ab ? (Ja = Ha[wa - ab], vb = Ja.plotObj.value * na + Ja.plotObj._weight * na / 2) : (Ja = null, vb = b.min * na - ta), wa + ab < jb ? (ga = Ha[wa + ab], Ya = ga.plotObj.value *
na - ga.plotObj._weight * na / 2) : (ga = null, Ya = b.max * na + ya), L = D.label, L.style && L.style !== t && (t = L.style, H.setStyle(t)), ma = D.value * na, Fb = ma - D._weight * na / 2, yb = ma + D._weight * na / 2, 1 < ab ? (Fa = Fb - vb, La = yb + Ya, nb = yb - Fb + V(Fa, La)) : nb = yb - Fb, L = D.label, L.style && L.style !== t && H.setStyle(L.style), nb < w && w < H.getOriSize(L.text).width ? (D.label.text = l, Oa.labelTextWidth = 0) : (Oa.labelTextWidth = nb, n = H.getSmartText(L.text, nb - 4, r, va), nb = n.width + 4, Oa.labelTextWidth = nb, S = ba(S, n.height))); else {
            gc = Ha.length; Tb = Ha.length - 1; (Eb = (Ha[Tb].plotObj.value -
Ha[0].plotObj.value) * na) ? (aa = 0.1 * Eb, da = ba(0.2 * Eb, Eb / gc)) : da = aa = e; for (m in $) for (wa = 0, ha = $[m].length; wa < ha; ) { for (la = wa + 1; !Kb($[m][wa], $[m][la]); ) la += 1; wa = la } qa && (W = (qa.plotObj.value - b.min) * na + ta - qa.labelTextWidth / 2); D = Ha[0].plotObj; qa && D === qa.plotObj || (L = D.label, L.style && L.style !== t && (t = L.style, H.setStyle(t)), C = H.getOriSize(L.text).width + 4, ma = (D.value - b.min) * na + ta, qa && (Ia = W - ma, C = Ia < C && Ia > w / 2 ? 2 * Ia : 0), Ha[0].labelTextWidth = C, 0 < C && (U = ma - C / 2), U < W && (W = U)); ja && (C = ja.labelTextWidth, ca = (b.max - ja.plotObj.value) *
na + ya - C / 2); D = Ha[Tb].plotObj; ja && D === ja.plotObj || (L = D.label, L.style && L.style !== t && (t = L.style, H.setStyle(t)), C = H.getOriSize(L.text).width + 4, ma = (b.max - D.value) * na + ya, ja && (Ia = ma - ca, C = Ia < C && Ia > w / 2 ? 2 * Ia : 0), Ha[Tb].labelTextWidth = C, 0 < C && (U = ma - C / 2), U < ca && (ca = U)); $a = 0 > W ? -W : 0; Bb = 0 > ca ? -ca : 0; Na = $a + Bb; if (0 < Na) for (m in Gb > Na ? (oa = (oa = Bb * e / (Bb + e)) ? oa + 4 : 0, d.chart.marginRight += oa, e -= oa, oa = (oa = $a * e / ($a + e)) ? oa + 4 : 0, d.chart.marginLeft += oa, e -= oa, na = e / (b.max - b.min)) : $a < Bb ? Gb >= Bb && Wb ? (oa = (oa = Bb * e / (Bb + e)) ? oa + 4 : 0, d.chart.marginRight +=
oa, e -= oa, na = e / (b.max - b.min)) : Jb && (oa = (oa = $a * e / ($a + e)) ? oa + 4 : 0, d.chart.marginLeft += oa, e -= oa, na = e / (b.max - b.min)) : Gb >= $a && Jb ? (oa = (oa = $a * e / ($a + e)) ? oa + 4 : 0, d.chart.marginLeft += oa, e -= oa, na = e / (b.max - b.min)) : Wb && (oa = (oa = Bb * e / (Bb + e)) ? oa + 4 : 0, d.chart.marginRight += oa, e -= oa, na = e / (b.max - b.min)), ya = d.chart.marginRight, ta = d.chart.marginLeft, Eb = (Ha[Tb].plotObj.value - Ha[0].plotObj.value) * na, aa = 0.1 * Eb, da = ba(0.2 * Eb, Eb / gc), $) { wa = 0; for (ha = $[m].length; wa < ha; ) { for (la = wa + 1; !Kb($[m][wa], $[m][la], !0); ) la += 1; wa = la } m += 1 } wa = 0; for (jb =
Ha.length; wa < jb; wa += 1) if (Oa = Ha[wa], Ba = wa % ab, D = Oa.plotObj, D.label) if (D.isCat) Oa.labelTextWidth && (Pa[Ba] = Oa); else {
                ga = (Ja = Pa[Ba]) ? Ja.nextCat : $[Ba] ? $[Ba][0] : null; eb = null; if (wa >= ab) for (Ib = wa - ab, eb = Ha[Ib]; !eb.labelTextWidth; ) if (Ib >= ab) Ib -= ab, eb = Ha[Ib]; else { eb = null; break } vb = eb ? eb.rightEdge : b.min * na - ta; Ya = ga ? ga.leftEdge : b.max * na + ya; L = D.label; L.style && L.style !== t && (t = L.style, H.setStyle(t)); C = H.getOriSize(L.text).width + 4; Yb = D.value * na - C / 2; if (k.isBar && wa == jb - 1 && eb) vb > Yb && (eb.plotObj.label.text = l, eb.labelTextWidth =
0, vb = eb.leftEdge); else if (vb > Yb || Ya < Yb + C) { D.label.text = l; Oa.labelTextWidth = 0; continue } vb = ba(vb, Yb); ma = D.value * na; nb = 2 * V(ma - vb, Ya - ma); nb.toFixed && (nb = nb.toFixed(2)); L = D.label; L.style && L.style !== t && H.setStyle(L.style); nb < w && w < H.getOriSize(L.text).width ? (D.label.text = l, Oa.labelTextWidth = 0) : (Oa.labelTextWidth = nb, n = H.getSmartText(L.text, nb - 4, r, va), nb = n.width + 4, Oa.labelTextWidth = nb, Oa.leftEdge = ma - nb / 2, Oa.rightEdge = ma + nb / 2, S = ba(S, n.height))
            } eb = ub = null; wa = 0; for (jb = Ha.length; wa < jb; wa += 1) if (Oa = Ha[wa], D = Oa.plotObj,
Ba = wa % ab, D.isCat && Oa.labelTextWidth) {
                eb = ub = null; ma = D.value * na; if (wa >= ab) for (Ib = wa - ab, eb = Ha[Ib]; !eb.labelTextWidth; ) if (Ib > ab) Ib -= ab, eb = Ha[Ib]; else { eb = null; break } Fa = eb ? ma - eb.rightEdge : ma - b.min * na + d.chart.marginLeft; if (wa + ab < jb) for (Vb = wa + ab, ub = Ha[Vb]; !ub.labelTextWidth; ) if (Vb + ab < jb - 1) Vb += ab, ub = Ha[Vb]; else { ub = null; break } La = ub ? ub.leftEdge - ma : b.max * na + d.chart.marginRight - ma; nb = 2 * V(Fa, La); nb > da && (nb = da); nb > Oa.oriWidth && (nb = Oa.oriWidth); Oa.labelTextWidth = nb; L = D.label; L.style && L.style !== t && H.setStyle(L.style);
                n = H.getSmartText(L.text, nb - 4, r, va); Oa.labelTextWidth = n.width + 4; S = ba(S, n.height); Oa.rightEdge = ma + Oa.labelTextWidth / 2
            } 
        } else if (u) for (wa = 0, jb = Ha.length; wa < jb; wa += 1) if ((D = Ha[wa].plotObj) && D.label && D.label.text) {
            L = D.label; L.style && L.style !== t && (t = L.style, H.setStyle(t)); m = 1; if (wa + m < jb) for (sc = Ha[m + wa].plotObj; sc && (sc.value - D.value) * na < w; ) if (D.isCat) { if (sc.label) { sc.label.text = l; m += 1; if (m + wa >= jb - 1) break; sc = Qb[m + wa].plotObj } } else if (sc.isCat) {
                D.label.text = l; D = sc; wa += m - 1; L = D.label; L.style && L.style !== t && (t =
L.style, H.setStyle(t)); break
            } Za = ba(Za, H.getOriSize(L.text).width + 4)
        } m = 0; for (jb = Pb.length; m < jb; m += 1) (D = Pb[m].plotObj) && D.label && void 0 !== J(D.label.text) && (L = D.label, L.style && L.style !== t && (t = L.style, H.setStyle(t)), n = H.getOriSize(L.text), L.verticalAlign === Aa ? Va = ba(Va, n.height) : cb = ba(cb, n.height))
    } else {
        for (jb = Qb.length; wa < jb; wa += 1) (D = Qb[wa]) && (D.isGrid ? Ha.push(D) : D.isTrend && Pb.push(D)); fc = b.plotBands; wa = 0; for (jb = fc.length; wa < jb; wa += 1) (D = fc[wa]) && Pb.push(D); Tb = Ha.length - 1; gc = Ha.length; N && (ab > gc ? ab = gc :
2 > ab && (ab = 2)); if (gc) for (b.scroll && b.scroll.viewPortMin && b.scroll.viewPortMax ? (Mb = b.scroll.viewPortMin, Nb = b.scroll.viewPortMax, Wb = Jb = !1) : (Mb = b.min, Nb = b.max), Eb = (Ha[Tb].value - Ha[0].value) * na, pb = Eb / (kb - 1), bb = (Ha[0].value - Mb) * na, $b = (Nb - Ha[Tb].value) * na, "auto" === Sa ? pb < T && (u = Q ? 300 : 270, U = ia, ia = w, w = U, va = !0) : "stagger" === Sa && (pb *= ab), "line" !== this.defaultSeriesType && ("area" === this.defaultSeriesType ? k.drawFullAreaBorder && (ib > bb && (Mb = b.min -= ib / (2 * na), bb += (Ha[0].value - Mb) * na), ib > $b && (Nb = b.max += ib / (2 * na), $b += (Nb -
Ha[Tb].value) * na)) : (ib > bb && (Mb = b.min -= ib / (2 * na), bb += (Ha[0].value - Mb) * na), ib > $b && (Nb = b.max += ib / (2 * na), $b += (Nb - Ha[Tb].value) * na))), w < Ka && (w = Ka), E = N || K ? ba(1, P) : ba(1, P, xa(w / pb)), k.x && (k.x.stepValue = E), pb *= E, B = 2 * (bb + ta), (L = Qb[0].label) && L.text && (L.style && H.setStyle(L.style), C = 270 === u ? V(pb, H.getOriSize(L.text).height + 4) : V(pb, H.getOriSize(L.text).width + 4), C > B && (K || ($a = (C - B) / 2), Jb || (mb && ($a = 0), pb -= $a / (kb - 1), wb = pb * (kb - 1), na = pb, ac = (Eb - wb) / na, Nb = b.max += ac, Mb = b.min -= ac, $a = 0, Eb = wb, bb = (Ha[0].value - Mb) * na, $b = (Nb -
Ha[Tb].value) * na))), B = 2 * ($b + ya), (L = Qb[Tb].label) && L.text && (L.style && H.setStyle(L.style), C = 270 === u ? V(pb, H.getOriSize(L.text).height + 4) : V(pb, H.getOriSize(L.text).width + 4), C > B && (K || (Bb = (C - B) / 2), Wb || (mb && (Bb = 0), pb -= Bb / (kb - 1), wb = pb * (kb - 1), na = pb, ac = (Eb - wb) / na, Bb = 0, Eb = wb, bb = (Ha[0].value - Mb) * na, $b = (Nb - Ha[Tb].value) * na))), Na = $a + Bb, 0 < Na && (Gb > Na ? (oa = (oa = Bb * e / (Bb + e)) ? oa + 4 : 0, d.chart.marginRight += oa, e -= oa, oa = (oa = $a * e / ($a + e)) ? oa + 4 : 0, d.chart.marginLeft += oa, e -= oa, na = e / (b.max - b.min)) : $a < Bb ? Gb >= Bb && Wb ? (oa = (oa = Bb * e /
(Bb + e)) ? oa + 4 : 0, d.chart.marginRight += oa, e -= oa, na = e / (b.max - b.min)) : Jb && (oa = (oa = $a * e / ($a + e)) ? oa + 4 : 0, d.chart.marginLeft += oa, e -= oa, na = e / (b.max - b.min)) : Gb >= $a && Jb ? (oa = (oa = $a * e / ($a + e)) ? oa + 4 : 0, d.chart.marginLeft += oa, e -= oa, na = e / (b.max - b.min)) : Wb && (oa = (oa = Bb * e / (Bb + e)) ? oa + 4 : 0, d.chart.marginRight += oa, e -= oa, na = e / (b.max - b.min)), Eb = (Ha[Tb].value - Ha[0].value) * na, pb = Eb / (kb - 1), N && (pb *= ab), E = N || K ? ba(1, P) : u ? ba(1, P, xa(ia / pb)) : ba(1, P, xa(w / pb)), k.x && (k.x.stepValue = E), pb *= E), m = 0; m < gc; m += 1) {
            D = Ha[m]; if (m % E && D.label) {
                if (D.stepped =
!0, D.label.style = b.steppedLabels.style, !X) continue
            } else D.stepped = !1, D.label.style = b.labels.style; D && D.label && void 0 !== J(D.label.text) && (L = D.label, L.style && L.style !== t && (t = L.style, H.setStyle(t)), u && K ? (n = H.getOriSize(L.text), Za = ba(Za, n.width + 4), S = ba(S, n.height)) : K || (n = u || N ? H.getOriSize(L.text) : H.getSmartText(L.text, pb - 4, r, va), Za = ba(Za, n.width + 4), S = ba(S, n.height)))
        } m = 0; for (jb = Pb.length; m < jb; m += 1) (D = Pb[m]) && D.label && void 0 !== J(D.label.text) && (L = D.label, L.style && L.style !== t && (t = L.style, H.setStyle(t)),
n = H.getOriSize(L.text), L.verticalAlign === Aa ? Va = ba(Va, n.height) : cb = ba(cb, n.height)); b.scroll && b.scroll.enabled && !u && !K && (ac = Za / 2, d.chart.marginLeft < ac && (bc = ac - d.chart.marginLeft, Gb > bc && (e -= bc, Gb -= bc, d.chart.marginLeft += bc)), d.chart.marginRight < ac && (bc = ac - d.chart.marginRight, Gb > bc && (e -= bc, Gb -= bc, d.chart.marginRight += bc)))
    } K ? (Hb = ia, u && (Hb = Za)) : Hb = u ? Za : N ? ab * ia : S; 0 < Hb && (Ab += M + Hb); 0 < pa && (Ab += pa + db); Xb = M - 4; tb = cb + Ab + 2; U = 0; tb > r && (Ia = tb - r, db > Ia ? (db -= Ia, Ia = 0) : (Ia -= db, db = 0, Xb > Ia ? (Xb -= Ia, Ia = 0) : (Ia -= Xb, Xb = 0), M =
Xb + 4), cb > Ia ? (cb -= Ia, Ia = 0) : (0 < cb && (Ia -= cb, cb = 0), 0 < Ia && (Va > Ia ? (Va -= Ia, Ia = 0) : (0 < Va && (Ia -= Va, Va = 0), 0 < Ia && ((U = pa - I) > Ia ? (pa -= Ia, Ia = 0) : (Ia -= U, pa = I, 0 < Ia && ((U = Hb - ia) > Ia ? (Hb -= Ia, Ia = 0) : (Ia -= U, Hb = ia, 0 < Ia && (Ia -= pa + db, pa = 0, 0 < Ia && (Ia -= Hb, Hb = 0, 0 < Ia && (M -= Ia))))))))))); M += Ua; Hc = k.is3d ? -d.chart.xDepth : 0; Vc = Hb + M; xc = Hc; Mc = 0.5 * ia; G = ia + M; jb = Ha.length; ka = 0; if (hb) if (u) for (qb = za, nc = Q ? M + 8 : M + 4, jb = Ha.length, m = 0; m < jb; m += 1) (D = Ha[m].plotObj) && D.label && void 0 !== J(D.label.text) && (L = D.label, L.style && L.style !== t && (t = L.style, H.setStyle(t)),
wa = 1, n = H.getSmartText(L.text, Hb - 4, w, va), L.text = n.text, n.tooltext && (L.originalText = n.tooltext), xc = Hc + Mc / 2, L.y = nc, L.x = xc, L.rotation = u, L.textAlign = qb, ka += 1); else for (Dc = Hb, qb = Xa, nc = G, m = 0; m < jb; m += E) (D = Ha[m].plotObj) && D.label && void 0 !== J(D.label.text) && (L = D.label, L.style && L.style !== t && (t = L.style, H.setStyle(t)), K || (n = H.getSmartText(L.text, Ha[m].labelTextWidth - 4, Dc, va), L.text = n.text, n.tooltext && (L.originalText = n.tooltext), N && (nc = G + ka % ab * ia)), L.y = nc, L.x = xc, L.rotation = u, L.textAlign = qb, ka += 1); else {
        u ? (Dc = pb,
Lc = Hb - 4, qb = za, nc = Q ? M + 8 : M + 4) : N ? (Dc = ia, Lc = pb - 4, qb = Xa) : (Dc = Hb, Lc = pb - 4, qb = Xa, nc = G); for (m = 0; m < jb; m += E) (D = Ha[m]) && D.label && void 0 !== J(D.label.text) && (L = D.label, L.style && L.style !== t && (t = L.style, H.setStyle(t)), K || (n = H.getSmartText(L.text, Lc, Dc, va), L.text = n.text, n.tooltext && (L.originalText = n.tooltext), N && (nc = G + ka % ab * ia)), u && (xc = Hc + Mc), L.y = nc, L.x = xc, L.rotation = u, L.textAlign = qb, ka += 1); c._labelY = G; c._labelX = Hc; c._yShipment = nc; c._isStagger = N; c._rotation = u; c._textAlign = qb; c._adjustedPx = Mc; c._staggerLines = ab; c._labelHeight =
ia
    } jb = Pb.length; for (m = Ic = Ec = 0; m < jb; m += 1) (D = Pb[m].plotObj ? Pb[m].plotObj : Pb[m]) && D.label && void 0 !== J(D.label.text) && (L = D.label, L.style && L.style !== t && (t = L.style, H.setStyle(t)), L.verticalAlign === Aa ? (n = H.getSmartText(L.text, e, Va, !0), Ic = ba(Ic, n.height), L.text = n.text, n.tooltext && (L.originalText = n.tooltext), L.y = Vc + H.getOriSize(L.text).height, L.x = xc) : (n = H.getSmartText(L.text, e, cb, !0), Ec = ba(Ec, n.height), L.text = n.text, n.tooltext && (L.originalText = n.tooltext), L.y = -(cb - H.getOriSize("W").height + M + 2))); 0 < pa && (H.setStyle(b.title.style),
s = H.getSmartText(b.title.text, e, pa), b.title.text = s.text, s.tooltext && (b.title.originalText = s.tooltext), b.title.margin = Vc + Ic + db); Ab = Ic; 0 < Hb && (k.horizontalAxisHeight = M + Hb - Ua, Ab += k.horizontalAxisHeight); 0 < pa && (Ab += ra = pa + db); Ab = Ab || M - Ua; d.chart.marginBottom += Ab; 0 < Ec && (d.chart.marginTop += Ec, Ab += Ec); if (b.opposite) for (b.title.margin -= Hb - (s && s.height || 0) + M, Ab -= ra, d.chart.marginTop += Ab, d.chart.marginBottom -= Ab, d.xAxis.opposite = 1, jb = Qb.length, wa = 0; wa < jb; wa += 1) (D = Qb[wa]) && D.isGrid && (L = D.label) && void 0 !== L.text &&
(L.textAlign = Ga, L.y -= nc + M + 4); return Ab
}, Ua = n.configureLegendOptions = function (b, d, f, g, e) {
    g = b.legend; var r = b.chart, q = r.is3D ? va.chart3D : va.chart2D, k = r.useRoundEdges, h = a(d.legendiconscale, 1), D = (parseInt(g.itemStyle.fontSize, 10) || 10) + 1, n = this.colorManager, L; if (0 >= h || 5 < h) h = 1; g.padding = 4; 0 >= D && (D = 1); L = 3 * h; D = V(D * h, e - 8); 0 >= D && (L = D = 0); g.symbolWidth = D; g.symbolPadding = L; g.textPadding = 4; g.legendHeight = e = D + 2 * L; g.rowHeight = ba(parseInt(g.itemStyle.lineHeight, 10) || 12, e); f ? (g.align = za, g.verticalAlign = "middle", g.layout =
"vertical") : g.x = (r.marginLeft - r.spacingLeft - r.marginRight + r.spacingRight) / 2; f = c(d.legendbordercolor, n.getColor(q.legendBorderColor)); e = a(d.legendborderalpha, 100); r = a(d.legendbgalpha, 100); g.backgroundColor = G(c(d.legendbgcolor, n.getColor(q.legendBgColor)), r); g.borderColor = G(f, e); g.borderWidth = a(d.legendborderthickness, !k || d.legendbordercolor ? 1 : 0); g.shadow = Boolean(a(d.legendshadow, 1)); g.symbol3DLighting = Boolean(a(d.use3dlighting, d.useplotgradientcolor, 1)); g.shadow && (g.shadow = { enabled: g.shadow, opacity: ba(e,
r) / 100
}); g.reversed = Boolean(a(d.reverselegend, 0) - a(this.reverseLegend, 0)); g.style = { padding: 4 }; Boolean(a(d.interactivelegend, 1)) ? g.symbolStyle = { _cursor: "hand", cursor: "pointer"} : (b.legend.interactiveLegend = !1, g.itemStyle.cursor = "default", g.itemHoverStyle = { cursor: "inherit" }); g.borderRadius = a(d.legendborderradius, k ? 3 : 0); g.legendAllowDrag = Boolean(a(d.legendallowdrag, 0)); g.title.text = t(B(d.legendcaption, l)); g.legendScrollBgColor = w(c(d.legendscrollbgcolor, n.getColor("altHGridColor"))); g.legendScrollBarColor =
c(d.legendscrollbarcolor, f); g.legendScrollBtnColor = c(d.legendscrollbtncolor, f)
}, ta = n.placeLegendBlockRight = function (b, c, d, f, e) {
    this.configureLegendOptions(b, c.chart, !0, e, d); var r = this.snapLiterals || (this.snapLiterals = {}), q = 0, k = b.series, h, D = b[g], n = this.smartLabel || D.smartLabel, L = b.chart.spacingRight, m = b.legend, s, t = m.textPadding, w = m.title.padding, U = m.symbolWidth + 2 * m.symbolPadding, z = 2 * f, C = 0; c = a(c.chart.legendpadding, 7) + m.borderWidth / 2 + a(c.chart.canvasborderthickness, 1); var B = 2 * m.padding, u = B, T = !1, pa =
[]; d -= B; e && (k = k && k[0] && k[0].data); if (typeof k === Ca || typeof k.length === Ca) return 0; e = k.length; for (q = 0; q < e; q += 1) (h = k[q]) && !1 !== h.showInLegend && (h.__i = q, pa.push(h)); pa.sort(function (a, b) { return a.legendIndex - b.legendIndex || a.__i - b.__i }); e = pa.length; s = d - U - 2 - t; 0 > s && (s = 0); n.setStyle(m.itemStyle); m.reversed && pa.reverse(); for (q = 0; q < e; q += 1) h = pa[q], T = !0, h._legendX = 0, h._legendY = u, 0 === s ? (u += h._legendH = U, h.name = l) : (k = n.getSmartText(h.name, s, z), h.name = k.text, k.tooltext && (h.originalText = k.tooltext), k.height < U &&
(h._legendTestY = (U - k.height) / 2), u += h._legendH = ba(k.height, U), C = ba(k.width, C)); if (T) return m.itemWidth = C + U + 2 + t, m.width = m.itemWidth + B, m.title.text !== l && (n.setStyle(m.title.style), k = n.getSmartText(m.title.text, d, z), m.title.text = k.text, k.tooltext && (m.title.originalText = k.tooltext), q = k.width + B, m.width < q && (m.initialItemX = (q - m.width) / 2, m.width = q), m.initialItemY = k.height + w, u += m.initialItemY), m.height = m.totalHeight = u, m.height > f && (m.height = f, m.scroll.enabled = !0, m.scroll.flatScrollBars = D.flatScrollBars, m.scroll.scrollBar3DLighting =
D.scrollBar3DLighting, m.width += (m.scroll.scrollBarWidth = 10) + (m.scroll.scrollBarPadding = 2)), r.legendstartx = D.width - L - m.width, r.legendwidth = m.width, r.legendendx = r.legendstartx + r.legendwidth, r.legendheight = m.height, c = V(m.width + c, d), b.chart.marginRight += c, c; m.enabled = !1; return 0
}, cc = n.placeLegendBlockBottom = function (b, c, d, f, e) {
    this.configureLegendOptions(b, c.chart, !1, e, d); var r = this.snapLiterals || (this.snapLiterals = {}), q = 0, k = b.series, h = b[g], D = h.smartLabel || this.smartLabel, m = b.chart, n = m.spacingBottom,
L = m.spacingLeft, m = m.spacingRight, s = b.legend, t, w, U = s.textPadding, z = s.title.padding, C, B = s.symbolPadding, u = s.legendHeight, T = c.chart; C = 0; var pa = 2 * f, ia = s.rowHeight, E = 0.05 * ia, G = []; w = a(T.minimisewrappinginlegend, 0); var T = a(parseInt(T.legendnumcolumns, 10), 0), ka = 0, I = 0, ra = 0, J = q = 0, va = 2 * s.padding; c = a(c.chart.legendpadding, 7) + s.borderWidth / 2 + 1; var N = va, K = !1, H = [], P = !1, M = 0, Ka = 0; 0 > T && (T = 0); d -= va; D.setStyle(s.itemStyle); q = D.getOriSize(db).height; c = V(c, f - q - 8); f -= c; e && (k = k && k[0] && k[0].data); if (typeof k === Ca || typeof k.length ===
Ca) return 0; e = k.length; for (q = 0; q < e; q += 1) (t = k[q]) && !1 !== t.showInLegend && (t.__i = q, H.push(t)); H.sort(function (a, b) { return a.legendIndex - b.legendIndex || a.__i - b.__i }); e = H.length; D.setStyle(s.itemStyle); for (q = 0; q < e; q += 1) K = !0, t = D.getOriSize(H[q].name), ka = ba(ka, t.width), I += t.width, ra += 1; q = I / ra; k = u + E + U + B + va; I += k * ra; if (K) {
        q += k; ka += k; 0 < T && ra < T && (T = ra); I <= d && (0 >= T || T === ra) ? (T = ra, J = q = I / ra, P = !0) : 0 < T && (J = d / T) > q ? J > ka && (J = ka) : d > ka && (w || 1.5 * q > ka) ? (T = ua(d / ka), ra < T && (T = ra), J = ka) : d >= 2 * q ? (T = ua(d / q), ra < T && (T = ra), J = ua(d /
T), J > ka && (J = ka)) : (T = 1, J = d); s.itemWidth = J; w = J - k; 0 > w && (B = w = U = 0); s.symbolPadding = B; s.textPadding = U; s.width = J * T - E; s.title.text !== l && (D.setStyle(s.title.style), t = D.getSmartText(s.title.text, d, pa), s.title.text = t.text, t.tooltext && (s.title.originalText = t.tooltext), C = t.width + va, s.width < C && (s.initialItemX = (C - s.width) / 2, s.width = C), s.initialItemY = C = t.height + z); D.setStyle(s.itemStyle); s.reversed && H.reverse(); for (q = 0; q < e; q += 1) {
            d = H[q]; 0 === w && (G[M] = !0, d.name = l, z = 1, U = parseInt(M / T, 10), B = M % T, d._legendX = B * J, d._legendY =
U * ia + va, d._legendH = z * ia); if (P) t = D.getOriSize(d.name), t.height < ia && (d._legendTestY = (ia - t.height) / 2), d._legendX = Ka, d._legendY = va, d._legendH = ia, Ka += t.width + k; else { t = D.getSmartText(d.name, w, pa); d.name = t.text; for (t.tooltext && (d.originalText = t.tooltext); !0 === G[M]; ) M += 1; U = t.height / ia; B = M; for (z = 0; z < U; z += 1, B += T) G[B] = !0; t.height < ia && (d._legendTestY = (ia - t.height) / 2); U = parseInt(M / T, 10); B = M % T; d._legendX = B * J; d._legendY = U * ia + va; d._legendH = z * ia } M += 1
        } D = P ? 1 : xa(G.length / T); s.height = s.totalHeight = N + (D * ia + C); s.rowHeight =
ia; s.legendNumColumns = T; s.height > f && (s.height = f, s.scroll.enabled = !0, s.scroll.flatScrollBars = h.flatScrollBars, s.scroll.scrollBar3DLighting = h.scrollBar3DLighting, s.width += (s.scroll.scrollBarWidth = 10) + (s.scroll.scrollBarPadding = 2)); r.legendstartx = L + 0.5 * (h.width - L - m - s.width) + (s.x || 0); r.legendwidth = s.width; r.legendendx = r.legendstartx + r.legendwidth; r.legendstarty = h.height - n - s.height; r.legendheight = s.height; r.legendendy = r.legendstarty + r.legendheight; c += s.height; b.chart.marginBottom += c; return c
    } s.enabled =
!1; return 0
}, Va = function (a, b) { return a.value - b.value }, ib = function (a, b, c) { var d = b._originalText; a = a[g].smartLabel; b.text = b.rotation ? a.getSmartText(d, c, b._actualWidth).text : a.getSmartText(d, b._actualWidth, c).text; b.centerYAxisName = !0 }, cb = n.adjustVerticalAxisTitle = function (a, b, c) {
    if (b && b.text) {
        var d = b.text, e = a[g].smartLabel, f = 2 * V(a.chart.marginTop, a.chart.marginBottom) + c, r = c + a.chart.marginTop + a.chart.marginBottom; b.style && e.setStyle(b.style); d = e.getOriSize(d); void 0 === b.centerYAxisName && (b.centerYAxisName =
!0); b.rotation ? d.width > f && (b.y = r / 2 - (c / 2 + a.chart.marginTop), b.centerYAxisName = !1) : d.height > f && (b.y = (r / 2 - (c / 2 + a.chart.marginTop)) / 2, b.centerYAxisName = !1)
    } 
}, kb = n.adjustVerticalCanvasMargin = function (b, c, d, f) {
    var e = c.chart, g = c = 0, r = 0, q = a(e.canvastopmargin, 0), e = a(e.canvasbottommargin, 0), k = q / (q + e), l = b.chart.marginTop, h = b.chart.marginBottom; e > h && (c += e - h); q > l && (c += q - l); c > d ? q > l && e > h ? (g = d * k, r = d * (1 - k)) : q > l ? g = d : r = d : 0 < c && (e > h && (r = e - h), q > l && (g = q - l)); g && (b.chart.marginTop += g); r && (b.chart.marginBottom += r, f && f.title &&
(f.title.margin += r)); return g + r
}, hc = n.adjustHorizontalCanvasMargin = function (b, c, d, f, e) { var g = c.chart; c = a(g.canvasleftmargin, 0); var g = a(g.canvasrightmargin, 0), r = c / (c + g), q = 0, k = b.chart.marginLeft, l = b.chart.marginRight, h = 0, D = 0; c > k && (q += c - k); g > l && (q += g - l); q > d ? c > k && g > l ? (h = d * r, D = d * (1 - r)) : g > l ? D = d : h = d : 0 < q && (c > k && (h = c - k), g > l && (D = g - l)); h && (b.chart.marginLeft += h, f && f.title && (f.title.margin += h)); D && (b.chart.marginRight += D, e && e.title && (e.title.margin += D)); return D + h }, Cb = function (a, b) { return a - b }, Za = n.getDataParser =
{ column: function (b, d, A) {
    var r = b[g], e = d.borderWidth; return function (g, q, k) {
        var l = d.plotgradientcolor, h = d.is3d, D = d.isRoundEdges, m = d.plotBorderColor, n = c(g.color, d.color), L = c(g.ratio, d.ratio), s = aa(d.plotBorderAlpha), t = a(g.dashed, d.dashed), U = c(g.dashlen, d.dashLen), w = c(g.dashgap, d.dashGap), z = d.use3DLighting, C = aa(c(g.alpha, d.alpha)).toString(), B = { opacity: C / 100 }, T = d.isBar, u = d.fillAangle, pa = 0 > k ? T ? 180 - u : 360 - u : u, u = ha(n + fa + l, C, L, pa, D, m, V(C, s).toString(), T, h), ia = t ? f(U, w, e) : "none"; q = A.getPointStub(g, k, r.oriCatTmp[q],
b, d, d.showValues, d.yAxis); g = A.pointHoverOptions(g, d, { plotType: "column", is3d: h, isBar: T, use3DLighting: z, isRoundEdged: D, color: n, gradientColor: l, alpha: C, ratio: L, angle: pa, borderWidth: e, borderColor: m, borderAlpha: s, borderDashed: t, borderDashGap: w, borderDashLen: U, shadow: B }); q.y = k; q.shadow = B; q.color = u[0]; q.borderColor = u[1]; q.borderWidth = e; q.use3DLighting = z; q.dashStyle = ia; q.tooltipConstraint = A.tooltipConstraint; q.hoverEffects = g.enabled && g.options; q.rolloverProperties = g.enabled && g.rolloverOptions; return q
    } 
},
    line: function (b, d, A) {
        var r = b[g]; return function (e, g, q) {
            var k = a(e.alpha, d.lineAlpha), l = { opacity: k / 100 }, h = a(e.anchorsides, d.anchorSides, 0), D = a(e.anchorborderthickness, d.anchorBorderThickness, 1), m = w(c(e.anchorbordercolor, d.anchorBorderColor)), n = w(c(e.anchorbgcolor, d.anchorBgColor)), L = a(e.anchorstartangle, d.anchorStartAngle, 90), s = c(e.anchoralpha, d.anchorAlpha), t = c(e.anchorbgalpha, s), U = a(e.anchorradius, d.anchorRadius), z = Boolean(a(e.anchorshadow, d.anchorShadow, 0)); g = A.getPointStub(e, q, r.oriCatTmp[g], b,
d, d.showValues, d.yAxis); var C = c(e.anchorimageurl, d.imageUrl), B = c(e.anchorimagescale, d.imageScale), T = c(e.anchorimagealpha, d.imageAlpha); g.y = q; g.shadow = l; g.anchorShadow = d.anchorShadow; g.dashStyle = a(e.dashed, d.lineDashed) ? f(d.lineDashLen, d.lineDashGap, d.lineThickness) : null; g.color = { FCcolor: { color: w(c(e.color, d.lineColor)), alpha: k} }; g.valuePosition = c(e.valueposition, d.valuePosition); q = A.pointHoverOptions(e, d, { plotType: "anchor", anchorBgColor: n, anchorAlpha: s, anchorBgAlpha: t, anchorAngle: L, anchorBorderThickness: D,
    anchorBorderColor: m, anchorBorderAlpha: s, anchorSides: h, anchorRadius: U, imageUrl: C, imageScale: B, imageAlpha: T, shadow: l
}); g.marker = { enabled: void 0 === d.drawAnchors ? 0 !== k : !!d.drawAnchors, shadow: z && { opacity: s / 100 }, fillColor: { FCcolor: { color: w(c(e.anchorbgcolor, d.anchorBgColor)), alpha: (c(e.anchorbgalpha, d.anchorBgAlpha) * s / 100).toString()} }, lineColor: { FCcolor: { color: w(c(e.anchorbordercolor, d.anchorBorderColor)), alpha: s} }, imageUrl: C, imageScale: B, imageAlpha: T, lineWidth: a(e.anchorborderthickness, d.anchorBorderThickness),
    radius: a(e.anchorradius, d.anchorRadius), symbol: ma(a(e.anchorsides, d.anchorSides)), startAngle: c(e.anchorstartangle, d.anchorAngle)
}; g.hoverEffects = q.enabled && q.options; g.rolloverProperties = q.enabled && q.rolloverOptions; return g
        } 
    }, area: function (b, d, f) {
        var r = b[g]; return function (e, g, q) {
            var k = c(e.alpha, d.fillAlpha), l = { opacity: ba(k, d.lineAlpha) / 100, inverted: !0 }, h = a(e.anchorsides, d.anchorSides, 0), D = a(e.anchorborderthickness, d.anchorBorderThickness, 1), m = w(c(e.anchorbordercolor, d.anchorBorderColor)), n = w(c(e.anchorbgcolor,
d.anchorBgColor)), L = a(e.anchorstartangle, d.anchorStartAngle, 90), s = c(e.anchoralpha, d.anchorAlpha), t = c(e.anchorbgalpha, s), U = a(e.anchorradius, d.anchorRadius), z = Boolean(a(e.anchorshadow, d.anchorShadow, 0)); g = f.getPointStub(e, q, r.oriCatTmp[g], b, d, d.showValues, d.yAxis); var C = c(e.anchorimageurl, d.imageUrl), B = c(e.anchorimagescale, d.imageScale), T = c(e.anchorimagealpha, d.imageAlpha); g.y = q; g.shadow = l; g.anchorShadow = d.anchorShadow; g.color = { FCcolor: { color: w(c(e.color, d.fillColor)), alpha: k} }; g.valuePosition = c(e.valueposition,
d.valuePosition); q = f.pointHoverOptions(e, d, { plotType: "anchor", anchorBgColor: n, anchorAlpha: s, anchorBgAlpha: t, anchorAngle: L, anchorBorderThickness: D, anchorBorderColor: m, anchorBorderAlpha: s, anchorSides: h, anchorRadius: U, imageUrl: C, imageScale: B, imageAlpha: T, shadow: l }); g.marker = { enabled: d.drawAnchors, shadow: z && { opacity: s / 100 }, fillColor: { FCcolor: { color: w(c(e.anchorbgcolor, d.anchorBgColor)), alpha: (c(e.anchorbgalpha, d.anchorBgAlpha) * s / 100).toString()} }, lineColor: { FCcolor: { color: w(c(e.anchorbordercolor, d.anchorBorderColor)),
    alpha: s
}
}, imageUrl: C, imageScale: B, imageAlpha: T, lineWidth: a(e.anchorborderthickness, d.anchorBorderThickness), radius: U, symbol: ma(a(e.anchorsides, d.anchorSides)), startAngle: c(e.anchorstartangle, d.anchorAngle)
}; g.hoverEffects = q.enabled && q.options; g.rolloverProperties = q.enabled && q.rolloverOptions; g.events = { click: d.getLink }; return g
        } 
    } 
}; d.core.options.resizeTrackingInterval = 300; d.core.options.preventTrackResize = !1; n.createChart = function (a, b, c, f, e, g, q) {
    var k = a.jsVars, l = k.msgStore, h, D, m = X[c], L, s = k.hasNativeMessage,
t; t = function (e) {
    var g = { renderer: "javascript" }, r = k.fcObj, l = r.width, h = r.height, D = m && m.eiMethods, t = k.overlayButton, U; b.jsVars = a.jsVars; k.container = b; k.hcObj = e; k.type = c; k.width = b.offsetWidth; k.height = b.offsetHeight; k.instanceAPI = L; if (e.hasRendered) { d.extend(b, ra); if (D && "string" !== typeof D) for (U in D) b[U] = D[U]; k.overlayButtonActive && t && (t.innerHTML = "", t.appendChild(u.createTextNode(k.overlayButtonMessage)), e.container.appendChild(t)) } (/\%/g.test(l) || /\%/g.test(h)) && b && b.parentNode && !d.core.options.preventTrackResize &&
Ka(r, b); f && (f({ success: e.hasRendered, ref: b, id: a.id }), e.hasRendered && (n.raiseEvent("loaded", { type: c, renderer: "javascript" }, a, [a.id]), s || (r.__state.firstRenderNotified = !0, setTimeout(function () { n.raiseEvent("rendered", { renderer: "javascript" }, r, [r.id]) }, 0)))); e.hasRendered && k.previousDrawCount < k.drawCount && (g.width = k.width, g.height = k.height, g.drawCount = k.drawCount, g.displayingMessage = s, g.renderer = r.options.renderer, n.raiseEvent("drawcomplete", g, r, [r.id]), s || q || setTimeout(function () {
    r.__state.firstRenderNotified ||
n.raiseEvent("rendered", { renderer: "javascript" }, r, [r.id]); d.raiseEvent("renderComplete", g, r)
}, 0))
}; k.instanceAPI && k.instanceAPI.dispose && k.instanceAPI.dispose(); L = m ? new X(c) : new X("stub"); L.chartInstance = a; L.origRenderWidth = a.__state.renderedWidth; L.origRenderHeight = a.__state.renderedHeight; void 0 !== e ? "string" === typeof e && (e = new r(b, e), s = k.hasNativeMessage = !0) : !m || !m.init || m && "stub" === m.name ? (e = new r(b, l.ChartNotSupported), s = k.hasNativeMessage = !0) : k.message ? (e = new r(b, k.message), s = k.hasNativeMessage =
!0) : k.loadError ? (e = new r(b, l.LoadDataErrorText), s = k.hasNativeMessage = !0) : k.stallLoad ? (e = new r(b, l.XMLLoadingText), s = k.hasNativeMessage = !0) : (h = a.jsVars && a.jsVars.themeObject && a.jsVars.themeObject.getThemedJSONData() || a.getChartData(d.dataFormats.JSON, !0), D = h.data, h.error instanceof Error ? (e = new r(b, l.InvalidXMLText), s = k.hasNativeMessage = !0, a.__state.dataReady = !1, q || d.raiseEvent("dataInvalid", { error: h.error }, k.fcObj, void 0, function () { n.raiseEvent("dataxmlinvalid", {}, a, [a.id]) })) : (q || n.raiseEvent("dataloaded",
{}, a, [a.id]), e = L.init(b, D, a, t), L.inited = !0, k.previousDrawCount = k.drawCount, k.drawCount += 1, 0 === e.series.length ? (e = new r(b, l.ChartNoDataText), s = k.hasNativeMessage = !0, a.__state.dataReady = !1, q || n.raiseEvent("nodatatodisplay", {}, a, [a.id])) : (a.__state.dataReady = !0, s = k.hasNativeMessage = !1, delete k.message))); e || (e = new r(b, "Error rendering chart {0x01}"), s = k.hasNativeMessage = !0); s && !L.inited && L.init(b, D, a, t); e.chart = e.chart || {}; e.chart.renderTo = b; e.credits = e.credits || {}; e.credits.enabled = m && !0 === m.creditLabel ?
!0 : !1; !1 === g && (e.chart.animation = !1, e.plotOptions || (e.plotOptions = {}), e.plotOptions.series || (e.plotOptions.series = {}), e.plotOptions.series.animation = !1); b.style && (e.chart.containerBackgroundColor = n.getContainerBackgroundColor(a)); return L.draw(e, t)
}; X("base", { useScaleRecursively: !0, tooltipConstraint: "chart", rendererId: "root", canvasPaddingModifiers: ["anchor", "anchorlabel"], drawAnnotations: !0, draw: function (a, b) {
    var c = this.renderer; c || (c = this.renderer = new X("renderer." + this.rendererId)); this.updateDefaultAnnotations();
    return c.init(this, a, b)
}, init: function (b, c, d) {
    var f = this.chartInstance || d, e = f.jsVars; d = e._reflowData || (e._reflowData = {}); var g = e._reflowClean, r, l; this.dataObj = c = k({}, c); l = c.chart = c.chart || c.graph || c.map || {}; delete c.graph; delete c.map; d && !this.stateless && (r = d.hcJSON, delete d.hcJSON, k(this, d, !0), this.preReflowAdjustments && this.preReflowAdjustments.call(this), d.hcJSON = r); this.containerElement = b; this.config = {}; this.smartLabel = e.smartLabel; this.smartLabel.useEllipsesOnOverflow(a(l.useellipseswhenoverflow,
l.useellipsewhenoverflow, 1)); this.colorManager = new n.colorManager(c, this); this.linkClickFN = q(c, f); this.numberFormatter = new Fb(c.chart, this); if (!this.standaloneInit) return new n.createDialog(b, e.msgStore.ChartNotSupported); b = this.chart(b.offsetWidth || parseFloat(b.style.width), b.offsetHeight || parseFloat(b.style.height), f); d && !this.stateless && (d.hcJSON && k(b, d.hcJSON, !0), this.postReflowAdjustments && this.postReflowAdjustments.call(this), g && this.cleanedData && (this.cleanedData(this, g), this.cleanedData(d,
g))); return b
}, chart: function (b, v) {
    var A = this.name, r = this.dataObj, e = r.chart, q = this.colorManager, h, D, m, n, L, s, z, T = this.defaultSeriesType, u, ia, ka, ra, N, H, M, P, Y, Ka, ea, na, Da, Ua, ta, ya, ib, V, kb, Va, cb, S, Za, Cb, hc, cc, X, aa, ca, W, la, sa, ma, Ba, Ca, ha, xa, ua, db, Na, ec, Ob, Ta, lb, ic, zb, kc, xb, Ub, rb, Ja, yb, hb, oa, Oa, Db, Rb, eb, mb, La, ub, vb, Fb, nb, Vb, Ib, Ia, Xb, uc, Mb, Nb, Yb, Jb, Wb, Gb, wa, Qb, fc, Ha, Pb, Eb, $a, Bb, Tb, gc, pb, Zc, $b, $c, jb, ad, Hb, ab, Ab, Sc, ac, bc, Tc, Uc; h = Sa(r, b, v, this); Y = h.chart; P = h.xAxis; u = h[g]; this.snapLiterals || (this.snapLiterals =
{}); ea = this.snapLiterals; ea.chartstartx = 0; ea.chartstarty = 0; ea.chartwidth = b; ea.chartheight = v; ea.chartendx = b; ea.chartendy = v; ea.chartcenterx = b / 2; ea.chartcentery = v / 2; ea.chartbottommargin = Y.spacingBottom; ea.chartleftmargin = Y.spacingLeft; ea.chartrightmargin = Y.spacingRight; ea.charttopmargin = Y.spacingTop; this.updateSnapPoints && this.updateSnapPoints(); this.postHCJSONCreation && this.postHCJSONCreation.call(this, h); d.raiseEvent("internal.postlogic", this, this.chartInstance); h.labels.smartLabel = s = u.smartLabel =
this.smartLabel; u.width = b; u.height = v; ka = h.plotOptions; u.isDual = this.isDual; u.numberFormatter = this.numberFormatter; u.axisGridManager = new tb(T, e); u.tooltext = e.plottooltext; u.trendLineToolText = e.trendlinetooltext; Y.is3D = D = u.is3d = /3d$/.test(T); Y.isBar = ia = u.isBar = this.isBar; z = /^pie/.test(T); M = 1 == e.useroundedges; H = D ? va.chart3D : va.chart2D; Y.events.click = h.plotOptions.series.point.events.click = this.linkClickFN; Y.defaultSeriesType = T; ya = 0 < e.palette && 6 > e.palette ? e.palette : a(this.paletteIndex, 1); ya -= 1; Y.paletteIndex =
ya; Y.usePerPointLabelColor = e.colorlabelsfromplot == Ya; Y.syncLabelWithAnchor = a(e.synclabelwithanchoronhover, 1); Y.useRoundEdges = M && !D && !this.distributedColumns && "pie" !== this.defaultSeriesType; void 0 !== c(e.clickurl) && (Y.link = e.clickurl, Y.style.cursor = "pointer", h.plotOptions.series.point.events.click = function () { Y.events.click.call({ link: e.clickurl }) }); ib = c(e.basefont, "Verdana,sans"); V = K(e.basefontsize, 10); kb = c(e.basefontcolor, q.getColor(H.baseFontColor)); Va = c(e.outcnvbasefont, ib); cb = K(e.outcnvbasefontsize,
V); S = cb + Pa; Za = c(e.outcnvbasefontcolor, kb).replace(/^#?([a-f0-9]+)/ig, "#$1"); cc = V; V += Pa; kb = kb.replace(/^#?([a-f0-9]+)/ig, "#$1"); u.trendStyle = u.outCanvasStyle = { fontFamily: Va, color: Za, fontSize: S }; Cb = Q(u.trendStyle); u.inCanvasStyle = { fontFamily: ib, fontSize: V, color: kb }; hc = Q(u.inCanvasStyle); u.divlineStyle = { fontFamily: ib, fontSize: V, color: kb, lineHeight: hc }; P.labels.style = { fontFamily: Va, fontSize: S, lineHeight: Cb, color: Za }; P.steppedLabels.style = { fontFamily: Va, fontSize: S, lineHeight: Cb, color: Za, visibility: "hidden" };
    h.yAxis[0].labels.style = { fontFamily: Va, fontSize: S, lineHeight: Cb, color: Za }; h.yAxis[1].labels.style = { fontFamily: Va, fontSize: S, lineHeight: Cb, color: Za }; aa = c(e.legenditemfont, Va); ca = K(e.legenditemfontsize, cb); W = c(e.legenditemfontcolor, Za).replace(/^#?([a-f0-9]+)/ig, "#$1"); la = pa[a(e.legenditemfontbold, 0)] || ""; X = K(e.legendcaptionfontsize, ca) + Pa; ca += Pa; h.legend.itemStyle = { fontFamily: aa, fontSize: ca, color: W, fontWeight: la }; Q(h.legend.itemStyle); h.legend.itemHiddenStyle = { fontFamily: aa, fontSize: ca, color: c(e.legenditemhiddencolor,
"cccccc").replace(/^#?([a-f0-9]+)/ig, "#$1"), fontWeight: la
    }; Q(h.legend.itemHiddenStyle); h.legend.itemHoverStyle = { color: c(e.legenditemhoverfontcolor, W).replace(/^#?([a-f0-9]+)/ig, "#$1") }; h.legend.title.style = { fontFamily: c(e.legendcaptionfont, aa), fontSize: X, color: c(e.legendcaptionfontcolor, W).replace(/^#?([a-f0-9]+)/ig, "#$1"), fontWeight: pa[a(e.legendcaptionbold, 1)] || "" }; Q(h.legend.title.style); h.legend.title.align = qb[e.legendcaptionalignment && e.legendcaptionalignment.toLowerCase() || Xa] || qb.center; Ka =
(Ka = B(e.valuebordercolor, l)) ? G(Ka, a(e.valueborderalpha, e.valuealpha, 100)) : l; h.plotOptions.series.dataLabels.style = { fontFamily: c(e.valuefont, ib), fontSize: c(e.valuefontsize, parseInt(V, 10)) + Pa, lineHeight: hc, color: G(c(e.valuefontcolor, kb), a(e.valuefontalpha, e.valuealpha, 100)), fontWeight: a(e.valuefontbold) ? "bold" : "normal", fontStyle: a(e.valuefontitalic) ? "italic" : "normal", border: Ka || e.valuebgcolor ? a(e.valueborderthickness, 1) + "px solid" : "", borderColor: Ka, borderThickness: a(e.valueborderthickness, 1), borderPadding: a(e.valueborderpadding,
2), borderRadius: a(e.valueborderradius, 0), backgroundColor: e.valuebgcolor ? G(e.valuebgcolor, a(e.valuebgalpha, e.valuealpha, 100)) : l, borderDash: a(e.valueborderdashed, 0) ? f(a(e.valueborderdashlen, 4), a(e.valueborderdashgap, 2), a(e.valueborderthickness, 1)) : "none"
}; Q(h.plotOptions.series.dataLabels.style); h.plotOptions.series.dataLabels.color = h.plotOptions.series.dataLabels.style.color; h.tooltip.style = { fontFamily: ib, fontSize: V, lineHeight: hc, color: kb }; h.title.style = { fontFamily: c(e.captionfont, Va), color: c(e.captionfontcolor,
Za).replace(/^#?([a-f0-9]+)/ig, "#$1"), fontSize: a(e.captionfontsize, cb + 3) + Pa, fontWeight: 0 === a(e.captionfontbold) ? "normal" : "bold"
}; h.title.align = c(e.captionalignment, Xa); h.title.isOnTop = a(e.captionontop, 1); h.title.alignWithCanvas = a(e.aligncaptionwithcanvas, this.alignCaptionWithCanvas, 1); h.title.horizontalPadding = a(e.captionhorizontalpadding, h.title.alignWithCanvas ? 0 : 15); Q(h.title.style); h.subtitle.style = { fontFamily: c(e.subcaptionfont, e.captionfont, Va), color: c(e.subcaptionfontcolor, e.captionfontcolor,
Za).replace(/^#?([a-f0-9]+)/ig, "#$1"), fontSize: a(e.subcaptionfontsize, a(ba(a(e.captionfontsize) - 3, -1), cb) + a(this.subTitleFontSizeExtender, 1)) + Pa, fontWeight: 0 === a(e.subcaptionfontbold, this.subTitleFontWeight, e.captionfontbold) ? "normal" : "bold"
}; h.subtitle.align = h.title.align; h.subtitle.isOnTop = h.title.isOnTop; h.subtitle.alignWithCanvas = h.title.alignWithCanvas; h.subtitle.horizontalPadding = h.title.horizontalPadding; Q(h.subtitle.style); Ka = (Ka = B(e.xaxisnamebordercolor, l)) ? G(Ka, a(e.xaxisnameborderalpha,
e.xaxisnamealpha, 100)) : l; P.title.style = { fontFamily: c(e.xaxisnamefont, Va), fontSize: c(e.xaxisnamefontsize, parseInt(S, 10)) + Pa, color: G(c(e.xaxisnamefontcolor, Za), a(e.xaxisnamefontalpha, e.xaxisnamealpha, 100)), fontWeight: a(e.xaxisnamefontbold, 1) ? "bold" : "normal", fontStyle: a(e.xaxisnamefontitalic) ? "italic" : "normal", border: Ka || e.xaxisnamebgcolor ? a(e.xaxisnameborderthickness, 1) + "px solid" : void 0, borderColor: Ka, borderThickness: a(e.xaxisnameborderthickness, 1), borderPadding: a(e.xaxisnameborderpadding, 2), borderRadius: a(e.xaxisnameborderradius,
0), backgroundColor: e.xaxisnamebgcolor ? G(e.xaxisnamebgcolor, a(e.xaxisnamebgalpha, e.xaxisnamealpha, 100)) : l, borderDash: a(e.xaxisnameborderdashed, 0) ? f(a(e.xaxisnameborderdashlen, 4), a(e.xaxisnameborderdashgap, 2), a(e.xaxisnameborderthickness, 1)) : "none"
}; Q(P.title.style); Ka = (Ka = c(e.pyaxisnamebordercolor, e.yaxisnamebordercolor, l)) ? G(Ka, a(e.pyaxisnameborderalpha, e.yaxisnameborderalpha, e.pyaxisnamealpha, e.yaxisnamealpha, 100)) : l; h.yAxis[0].title.style = { fontFamily: c(e.pyaxisnamefont, e.yaxisnamefont, Va), fontSize: c(e.pyaxisnamefontsize,
e.yaxisnamefontsize, parseInt(S, 10)) + Pa, color: G(c(e.pyaxisnamefontcolor, e.yaxisnamefontcolor, Za), a(e.pyaxisnamefontalpha, e.yaxisnamefontalpha, e.pyaxisnamealpha, e.yaxisnamealpha, 100)), fontWeight: a(e.pyaxisnamefontbold, e.yaxisnamefontbold, 1) ? "bold" : "normal", fontStyle: a(e.pyaxisnamefontitalic, e.yaxisnamefontitalic) ? "italic" : "normal", border: Ka || e.pyaxisnamebgcolor || e.yaxisnamebgcolor ? a(e.pyaxisnameborderthickness, e.yaxisnameborderthickness, 1) + "px solid" : void 0, borderColor: Ka, borderThickness: a(e.pyaxisnameborderthickness,
e.yaxisnameborderthickness, 1), borderPadding: a(e.pyaxisnameborderpadding, e.yaxisnameborderpadding, 2), borderRadius: a(e.pyaxisnameborderradius, e.yaxisnameborderradius, 0), backgroundColor: e.pyaxisnamebgcolor || e.yaxisnamebgcolor ? G(c(e.pyaxisnamebgcolor, e.yaxisnamebgcolor), a(e.pyaxisnamebgalpha, e.yaxisnamebgalpha, e.pyaxisnamealpha, e.yaxisnamealpha, 100)) : l, borderDash: a(e.pyaxisnameborderdashed, e.yaxisnameborderdashed, 0) ? f(a(e.pyaxisnameborderdashlen, e.yaxisnameborderdashlen, 4), a(e.pyaxisnameborderdashgap,
e.yaxisnameborderdashgap, 2), a(e.pyaxisnameborderthickness, e.yaxisnameborderthickness, 1)) : "none"
}; Q(h.yAxis[0].title.style); h.yAxis[1].title.style = { fontFamily: Va, color: Za, fontSize: S, lineHeight: void 0, fontWeight: "bold" }; Ka = (Ka = c(e.syaxisnamebordercolor, e.yaxisnamebordercolor, l)) ? G(Ka, a(e.syaxisnameborderalpha, e.yaxisnameborderalpha, e.syaxisnamealpha, e.yaxisnamealpha, 100)) : l; h.yAxis[1].title.style = { fontFamily: c(e.syaxisnamefont, e.yaxisnamefont, Va), fontSize: c(e.syaxisnamefontsize, e.yaxisnamefontsize,
parseInt(S, 10)) + Pa, color: G(c(e.syaxisnamefontcolor, e.yaxisnamefontcolor, Za), a(e.syaxisnamefontalpha, e.yaxisnamefontalpha, e.syaxisnamealpha, e.yaxisnamealpha, 100)), fontWeight: a(e.syaxisnamefontbold, e.yaxisnamefontbold, 1) ? "bold" : "normal", fontStyle: a(e.syaxisnamefontitalic, e.yaxisnamefontitalic) ? "italic" : "normal", border: Ka || e.syaxisnamebgcolor || e.yaxisnamebgcolor ? a(e.syaxisnameborderthickness, e.yaxisnameborderthickness, 1) + "px solid" : void 0, borderColor: Ka, borderThickness: a(e.syaxisnameborderthickness,
e.yaxisnameborderthickness, 1), borderPadding: a(e.syaxisnameborderpadding, e.yaxisnameborderpadding, 2), borderRadius: a(e.syaxisnameborderradius, e.yaxisnameborderradius, 0), backgroundColor: e.syaxisnamebgcolor || e.yaxisnamebgcolor ? G(c(e.syaxisnamebgcolor, e.yaxisnamebgcolor), a(e.syaxisnamebgalpha, e.yaxisnamebgalpha, e.syaxisnamealpha, e.yaxisnamealpha, 100)) : l, borderDash: a(e.syaxisnameborderdashed, e.yaxisnameborderdashed, 0) ? f(a(e.syaxisnameborderdashlen, e.yaxisnameborderdashlen, 4), a(e.syaxisnameborderdashgap,
e.yaxisnameborderdashgap, 2), a(e.syaxisnameborderthickness, e.yaxisnameborderthickness, 1)) : "none"
}; Q(h.yAxis[1].title.style); Y.overlapColumns = a(e[ia && "overlapbars" || "overlapcolumns"], D ? 0 : 1); h.orphanStyles = { defaultStyle: { style: k({}, u.inCanvasStyle) }, connectorlabels: { style: k({}, h.plotOptions.series.dataLabels) }, vyaxisname: { style: k({}, h.yAxis[0].title.style)} }; h.plotOptions.series.dataLabels.tlLabelStyle = { fontFamily: J(e.tlfont, ib), color: w(J(e.tlfontcolor, kb)), fontSize: K(e.tlfontsize, cc) + "px" }; Q(h.plotOptions.series.dataLabels.tlLabelStyle);
    h.plotOptions.series.dataLabels.trLabelStyle = { fontFamily: J(e.trfont, ib), color: w(J(e.trfontcolor, kb)), fontSize: K(e.trfontsize, cc) + "px" }; Q(h.plotOptions.series.dataLabels.trLabelStyle); h.plotOptions.series.dataLabels.blLabelStyle = { fontFamily: J(e.blfont, ib), color: w(J(e.blfontcolor, kb)), fontSize: K(e.blfontsize, cc) + "px" }; Q(h.plotOptions.series.dataLabels.blLabelStyle); h.plotOptions.series.dataLabels.brLabelStyle = { fontFamily: J(e.brfont, ib), color: w(J(e.brfontcolor, kb)), fontSize: K(e.brfontsize, cc) + "px" };
    Q(h.plotOptions.series.dataLabels.brLabelStyle); this.parseStyles(h); delete h.xAxis.labels.style.backgroundColor; delete h.xAxis.labels.style.borderColor; delete h.yAxis[0].labels.style.backgroundColor; delete h.yAxis[0].labels.style.borderColor; delete h.yAxis[1].labels.style.backgroundColor; delete h.yAxis[1].labels.style.borderColor; u.showTooltip = a(e.showtooltip, this.showtooltip, 1); u.tooltipSepChar = c(e.tooltipsepchar, this.tooltipsepchar, Kb); u.showValues = a(e.showvalues, this.showValues, 1); u.seriesNameInToolTip =
a(e.seriesnameintooltip, 1); u.showVLines = a(e.showvlines, 1); u.showVLinesOnTop = a(e.showvlinesontop, 0); u.showVLineLabels = a(e.showvlinelabels, this.showVLineLabels, 1); u.showVLineLabelBorder = a(e.showvlinelabelborder, 1); u.rotateVLineLabels = a(e.rotatevlinelabels, 0); u.vLineColor = c(e.vlinecolor, "333333"); u.vLineLabelColor = c(e.vlinelabelcolor); u.vLineThickness = c(e.vlinethickness, 1); u.vLineAlpha = a(e.vlinealpha, 80); u.vLineLabelBgColor = c(e.vlinelabelbgcolor, "ffffff"); u.vLineLabelBgAlpha = a(e.vlinelabelbgalpha, D ?
50 : 100); u.trendlineColor = c(e.trendlinecolor, "333333"); u.trendlineThickness = c(e.trendlinethickness, 1); u.trendlineAlpha = a(e.trendlinealpha); u.showTrendlinesOnTop = c(e.showtrendlinesontop, 0); u.trendlineValuesOnOpp = c(e.trendlinevaluesonopp, e.trendlinevaluesonright, 0); u.trendlinesAreDashed = a(e.trendlinesaredashed, 0); u.trendlinesDashLen = a(e.trendlinedashlen, 5); u.trendlinesDashGap = a(e.trendlinedashgap, 2); u.showTrendlines = a(e.showtrendlines, 1); u.showTrendlineLabels = a(e.showtrendlinelabels, this.showTrendlineLabels,
1); u.flatScrollBars = a(e.flatscrollbars, 0); u.scrollBar3DLighting = a(e.scrollbar3dlighting, 1); Y.anchorTrackingRadius = a(e.anchortrackingradius, U ? $ : C); h.plotOptions.series.connectNullData = a(e.connectnulldata, 0); Y.backgroundColor = { FCcolor: { color: c(e.bgcolor, q.getColor(H.bgColor)), alpha: c(e.bgalpha, q.getColor(H.bgAlpha)), angle: c(e.bgangle, q.getColor(H.bgAngle)), ratio: c(e.bgratio, q.getColor(H.bgRatio))} }; Y.borderRadius = a(e.borderradius, 0); Y.rotateValues = a(e.rotatevalues, 0); Y.placeValuesInside = a(e.placevaluesinside,
0); Y.valuePosition = c(e.valueposition, "auto"); Y.valuePadding = a(e.valuepadding, 2); Y.managePlotOverflow = a(e.manageplotoverflow, 1); Y.borderColor = G(c(e.bordercolor, D ? "#666666" : q.getColor("borderColor")), c(e.borderalpha, D ? "100" : q.getColor("borderAlpha"))); ra = a(e.showborder, D ? 0 : 1); Y.borderWidth = ra ? a(e.borderthickness, 1) : 0; Y.plotBorderColor = G(c(e.canvasbordercolor, q.getColor("canvasBorderColor")), c(e.canvasborderalpha, q.getColor("canvasBorderAlpha"))); "0" !== e.showcanvasborder && (N = Boolean(c(e.canvasborderthickness,
M ? 0 : 1)), "1" !== e.showaxislines && "1" !== e.showxaxisline && "1" !== e.showyaxisline && "1" !== e.showsyaxisline || "1" === e.showcanvasborder || (N = 0)); Y.plotBorderWidth = D || !N ? 0 : a(e.canvasborderthickness, this.canvasborderthickness, Y.useRoundEdges ? 1 : 2); Y.bgSWF = c(e.bgimage, e.bgswf); Y.bgSWFAlpha = a(e.bgimagealpha, e.bgswfalpha, 100); sa = c(e.bgimagedisplaymode, "none").toLowerCase(); ma = J(e.bgimagevalign, l).toLowerCase(); Ba = J(e.bgimagehalign, l).toLowerCase(); "tile" == sa || "fill" == sa || "fit" == sa ? (ma != ga && "middle" != ma && ma != Aa && (ma =
"middle"), Ba != Ga && "middle" != Ba && Ba != za && (Ba = "middle")) : (ma != ga && "middle" != ma && ma != Aa && (ma = ga), Ba != Ga && "middle" != Ba && Ba != za && (Ba = Ga)); Y.bgImageDisplayMode = sa; Y.bgImageVAlign = ma; Y.bgImageHAlign = Ba; Y.bgImageScale = a(e.bgimagescale, 100); Y.logoURL = J(e.logourl); Y.logoPosition = c(e.logoposition, "tl").toLowerCase(); Y.logoAlpha = a(e.logoalpha, 100); Y.logoLink = J(e.logolink); Y.logoScale = a(e.logoscale, 100); Y.logoLeftMargin = a(e.logoleftmargin, 0); Y.logoTopMargin = a(e.logotopmargin, 0); Ca = Y.toolbar = { button: {} }; ha = Ca.button;
    ha.scale = a(e.toolbarbuttonscale, 1.15); ha.width = a(e.toolbarbuttonwidth, 15); ha.height = a(e.toolbarbuttonheight, 15); ha.radius = a(e.toolbarbuttonradius, 2); ha.spacing = a(e.toolbarbuttonspacing, 5); ha.fill = G(c(e.toolbarbuttoncolor, "ffffff")); ha.labelFill = G(c(e.toolbarlabelcolor, "cccccc")); ha.symbolFill = G(c(e.toolbarsymbolcolor, "ffffff")); ha.hoverFill = G(c(e.toolbarbuttonhovercolor, "ffffff")); ha.stroke = G(c(e.toolbarbuttonbordercolor, "bbbbbb")); ha.symbolStroke = G(c(e.toolbarsymbolbordercolor, "9a9a9a")); ha.strokeWidth =
a(e.toolbarbuttonborderthickness, 1); ha.symbolStrokeWidth = a(e.toolbarsymbolborderthickness, 1); xa = ha.symbolPadding = a(e.toolbarsymbolpadding, 5); ha.symbolHPadding = a(e.toolbarsymbolhpadding, xa); ha.symbolVPadding = a(e.toolbarsymbolvpadding, xa); ua = Ca.position = c(e.toolbarposition, "tr").toLowerCase(); switch (ua) {
        case "tr": case "rt": case "top right": case "right top": ua = "tr"; break; case "br": case "rb": case "bottom right": case "right bottom": ua = "br"; break; case "tl": case "lt": case "top left": case "left top": ua = "tl";
            break; case "bl": case "lb": case "bottom left": case "left bottom": ua = "bl"; break; default: ua = "tr"
    } db = Ca.hAlign = "left" === (l + e.toolbarhalign).toLowerCase() ? "l" : ua.charAt(1); Na = Ca.vAlign = "bottom" === (l + e.toolbarvalign).toLowerCase() ? "b" : ua.charAt(0); Ca.hDirection = a(e.toolbarhdirection, "r" === db ? -1 : 1); Ca.vDirection = a(e.toolbarvdirection, "b" === Na ? -1 : 1); Ca.vMargin = a(e.toolbarvmargin, 6); Ca.hMargin = a(e.toolbarhmargin, 10); Ca.x = a(e.toolbarx, "l" === db ? 0 : b); Ca.y = a(e.toolbary, "t" === Na ? 0 : v); ec = c(e.divlinecolor, q.getColor(H.divLineColor));
    Ob = c(e.divlinealpha, D ? q.getColor("divLineAlpha3D") : q.getColor("divLineAlpha")); Ta = a(e.divlinethickness, 1); lb = Boolean(a(e.divlinedashed, e.divlineisdashed, this.divLineIsDashed, 0)); ic = a(e.divlinedashlen, 4); zb = a(e.divlinedashgap, 2); h.yAxis[0].gridLineColor = G(ec, Ob); h.yAxis[0].gridLineWidth = Ta; h.yAxis[0].gridLineDashStyle = lb ? f(ic, zb, Ta) : "none"; h.yAxis[0].alternateGridColor = ia ? G(c(e.alternatevgridcolor, q.getColor("altVGridColor")), 1 === a(e.showalternatevgridcolor, 1) ? c(e.alternatevgridalpha, q.getColor("altVGridAlpha")) :
qa) : G(c(e.alternatehgridcolor, q.getColor("altHGridColor")), "0" === e.showalternatehgridcolor ? 0 : c(e.alternatehgridalpha, q.getColor("altHGridAlpha"))); La = a(e.vdivlinethickness, 1); ub = Boolean(a(e.vdivlinedashed, e.vdivlineisdashed, 0)); vb = a(e.vdivlinedashlen, 4); Fb = a(e.vdivlinedashgap, 2); P.gridLineColor = G(c(e.vdivlinecolor, q.getColor(H.divLineColor)), c(e.vdivlinealpha, q.getColor("divLineAlpha"))); P.gridLineWidth = La; P.gridLineDashStyle = ub ? f(vb, Fb, La) : "none"; P.alternateGridColor = G(c(e.alternatevgridcolor, q.getColor("altVGridColor")),
"1" === e.showalternatehgridcolor ? c(e.alternatevgridalpha, q.getColor("altVGridAlpha")) : 0); xb = c(e.canvasbgcolor, q.getColor(H.canvasBgColor)); rb = c(e.canvasbgalpha, q.getColor("canvasBgAlpha")); c(e.showcanvasbg, Ya) == qa && (rb = "0"); h.plotOptions.series.shadow = a(e.showshadow, e.showcolumnshadow, this.defaultPlotShadow, q.getColor("showShadow")); this.inversed && (h.yAxis[0].reversed = !0, h.yAxis[1].reversed = !0); this.isStacked && (this.distributedColumns ? (u.showStackTotal = Boolean(a(e.showsum, 1)), L = a(e.usepercentdistribution,
1), kc = a(e.showpercentvalues, 0), Ub = a(e.showpercentintooltip, L, 0), u.showXAxisPercentValues = a(e.showxaxispercentvalues, 1)) : (u.showStackTotal = Boolean(a(this.showSum, e.showsum, 0)), L = a(this.stack100percent, e.stack100percent, 0), kc = a(e.showpercentvalues, L, 0), Ub = a(e.showpercentintooltip, kc)), u.showPercentValues = kc, u.showPercentInToolTip = Ub, L ? (u.isValueAbs = !0, ka[T].stacking = "percent", u[0].stacking100Percent = !0) : ka[T].stacking = "normal"); this.isDual && ("0" === e.primaryaxisonleft && (h.yAxis[0].opposite = !0, h.yAxis[1].opposite =
!1), h.yAxis[0].showAlways = !0, h.yAxis[1].showAlways = !0); Y.useRoundEdges && (h.plotOptions.series.shadow = a(e.showshadow, e.showcolumnshadow, 1), h.plotOptions.series.borderRadius = 1, h.tooltip.style.borderRadius = "2px", Y.plotBorderRadius = 3, N || (Y.plotBorderWidth = 0), Y.plotShadow = h.plotOptions.series.shadow ? { enabled: !0, opacity: rb / 100} : 0); 1 === a(e.use3dlighting, 1) && (h.legend.lighting3d = !0); h.plotOptions.series.userMaxColWidth = ia ? e.maxbarheight : a(e.maxcolwidth, this.maxColWidth); h.plotOptions.series.maxColWidth = da(a(h.plotOptions.series.userMaxColWidth,
50)) || 1; h.title.text = t(e.caption); h.subtitle.text = t(e.subcaption); 0 === a(e.showtooltip, this.showtooltip) && (h.tooltip.enabled = !1); Ja = h.tooltip.style; Ja.backgroundColor = G(c(Ja.backgroundColor, e.tooltipbgcolor, q.getColor("toolTipBgColor")), c(e.tooltipbgalpha, 100)); Ja.borderColor = G(c(Ja.borderColor, e.tooltipbordercolor, q.getColor("toolTipBorderColor")), c(e.tooltipborderalpha, 100)); h.tooltip.shadow = a(e.showtooltipshadow, e.showshadow, 1) ? { enabled: !0, opacity: ba(a(e.tooltipbgalpha, 100), a(e.tooltipborderalpha,
100)) / 100
} : !1; h.tooltip.constrain = a(e.constraintooltip, 1); Ja.borderWidth = a(e.tooltipborderthickness, 1) + "px"; e.tooltipborderradius && (Ja.borderRadius = a(e.tooltipborderradius, 1) + "px"); Ja.padding = a(e.tooltippadding, this.tooltippadding, 3) + "px"; e.tooltipcolor && (Ja.color = w(e.tooltipcolor)); u.userPlotSpacePercent = h.plotOptions.series.userPlotSpacePercent = e.plotspacepercent; yb = a(e.plotspacepercent, 20) % 100; u.plotSpacePercent = h.plotOptions.series.groupPadding = yb / 200; D && !z ? (Y.series2D3Dshift = "mscombi3d" === A ?
!0 : Boolean(a(e.use3dlineshift, 0)), Y.canvasBaseColor3D = c(e.canvasbasecolor, q.getColor("canvasBaseColor3D")), Y.canvasBaseDepth = a(e.canvasbasedepth, 10), Y.canvasBgDepth = a(e.canvasbgdepth, 3), Y.showCanvasBg = Boolean(a(e.showcanvasbg, 1)), Y.showCanvasBase = Boolean(a(e.showcanvasbase, 1)), ia ? (Y.xDepth = 5, Y.yDepth = 5, Y.showCanvasBg && (u.marginTopExtraSpace += Y.canvasBgDepth), u.marginLeftExtraSpace += Y.yDepth + (Y.showCanvasBase ? Y.canvasBaseDepth : 0), u.marginBottomExtraSpace += 5) : (Y.xDepth = 10, Y.yDepth = 10, Y.showCanvasBg &&
(u.marginRightExtraSpace += Y.canvasBgDepth), u.marginBottomExtraSpace += Y.yDepth + (Y.showCanvasBase ? Y.canvasBaseDepth : 0)), xb = xb.split(fa)[0], rb = rb.split(fa)[0], Y.use3DLighting = Boolean(a(e.use3dlighting, 1)), Y.plotBackgroundColor = Y.use3DLighting ? { FCcolor: { color: ja(xb, 85) + fa + I(xb, 55), alpha: rb + fa + rb, ratio: bb, angle: wb(b - (Y.marginLeft + Y.marginRight), v - (Y.marginTop + Y.marginBottom), 1)}} : G(xb, rb), Y.canvasBgColor = G(ja(xb, 80), rb), m = c(e.zeroplanecolor, e.divlinecolor, q.getColor(H.divLineColor)), n = c(e.zeroplanealpha,
e.divlinealpha, q.getColor("divLineAlpha")), Y.zeroPlaneColor = G(m, n), Y.zeroPlaneBorderColor = G(c(e.zeroplanebordercolor, m), a(e.zeroplaneshowborder, 1) ? n : 0)) : (Y.is3D = !1, Y.plotBackgroundColor = { FCcolor: { color: xb, alpha: rb, angle: c(e.canvasbgangle, q.getColor("canvasBgAngle")), ratio: c(e.canvasbgratio, q.getColor("canvasBgRatio"))} }); this.parseExportOptions(h); this.parseHoverEffectOptions(Y); this.preSeriesAddition && this.preSeriesAddition(h, r, b, v); this.series && this.series(r, h, A, b, v); this.postSeriesAddition(h, r,
b, v); this.spaceManager(h, r, b, v); this.postSpaceManager && this.postSpaceManager(h, r, b, v); hb = a(e.drawquadrant, 0); u.isXYPlot && hb && (oa = P.min, Oa = P.max, Db = h.yAxis[0].min, Rb = h.yAxis[0].max, eb = a(e.quadrantxval, (oa + Oa) / 2), mb = a(e.quadrantyval, (Db + Rb) / 2), mb >= Db && mb <= Rb && eb >= oa && eb <= Oa && (nb = G(c(e.quadrantlinecolor, Y.plotBorderColor), c(e.quadrantlinealpha, Fa)), Vb = a(e.quadrantlinethickness, Y.plotBorderWidth), Ib = a(e.quadrantlinedashed, e.quadrantlineisdashed, 0), Ia = a(e.quadrantlinedashLen, 4), Xb = a(e.quadrantlinedashgap,
2), uc = J(e.quadrantlabeltl, l), Mb = J(e.quadrantlabeltr, l), Nb = J(e.quadrantlabelbl, l), Yb = J(e.quadrantlabelbr, l), Jb = a(e.quadrantlabelpadding, 3), Wb = Ib ? f(Ia, Xb, Vb) : "none", P.plotLines.push({ color: nb, value: eb, width: Vb, dashStyle: Wb, zIndex: 3 }), h.yAxis[0].plotLines.push({ color: nb, value: mb, width: Vb, dashStyle: Wb, zIndex: 3 }), Gb = b - Y.marginRight - Y.marginLeft, wa = v - Y.marginTop - Y.marginBottom, $a = u.inCanvasStyle, Qb = Gb / (Oa - oa) * (eb - oa), fc = Gb - Qb, Pb = wa / (Rb - Db) * (mb - Db), Ha = wa - Pb, Qb -= Jb, fc -= Jb, Ha -= Jb, Pb -= Jb, Bb = Jb + Pa, Tb = wa - Jb +
Pa, gc = Jb + Pa, pb = Gb - Jb + Pa, s.setStyle($a), 0 < Ha && (uc !== l && 0 < Qb && (Eb = s.getSmartText(uc, Qb, Ha), h.labels.items.push({ html: Eb.text, zIndex: 3, vAlign: ga, style: { left: gc, top: Bb, fontSize: $a.fontSize, lineHeight: $a.lineHeight, fontFamily: $a.fontFamily, color: $a.color} })), Mb !== l && 0 < fc && (Eb = s.getSmartText(Mb, fc, Ha), h.labels.items.push({ html: Eb.text, textAlign: za, vAlign: ga, zIndex: 3, style: { left: pb, top: Bb, fontSize: $a.fontSize, lineHeight: $a.lineHeight, fontFamily: $a.fontFamily, color: $a.color} }))), 0 < Pb && (Nb !== l && 0 < Qb && (Eb =
s.getSmartText(Nb, Qb, Pb), h.labels.items.push({ html: Eb.text, vAlign: Aa, zIndex: 3, style: { left: gc, top: Tb, fontSize: $a.fontSize, lineHeight: $a.lineHeight, fontFamily: $a.fontFamily, color: $a.color} })), Yb !== l && 0 < fc && (Eb = s.getSmartText(Yb, fc, Pb), h.labels.items.push({ html: Eb.text, textAlign: za, vAlign: Aa, zIndex: 3, style: { left: pb, top: Tb, fontSize: $a.fontSize, lineHeight: $a.lineHeight, fontFamily: $a.fontFamily, color: $a.color} }))))); if (this.hasVDivLine && (Zc = a(e.showvdivlines, 0), $b = a(e.numvdivlines, 0) + 1, Zc && ($b = u.x.catCount -
1), 1 < $b)) {
        ad = P.min; Hb = u.x.catCount - 1; ab = P.max; Sc = Hb / $b; ac = !0; bc = ad; P.scroll && !isNaN(P.scroll.viewPortMax) && (ab = P.scroll.viewPortMax); $c = c(e.vdivlinecolor, ec); jb = a(e.vdivlinealpha, Ob); La = a(e.vdivlinethickness, Ta); ub = a(e.vdivlinedashed, e.vdivlineisdashed, lb); vb = a(e.vdivlinedashlen, ic); Fb = a(e.vdivlinedashgap, zb); (Uc = a(e.showalternatevgridcolor, 0)) && (Tc = G(c(e.alternatevgridcolor, q.getColor("altVGridColor")), c(e.alternatevgridalpha, q.getColor("altVGridAlpha")))); for (Ab = Sc; Ab < Hb; Ab += Sc, ac = !ac) ac && Uc && P.plotBands.push({ isNumVDIV: !0,
            color: Tc, from: bc, to: Ab, zIndex: 1
        }), P.plotLines.push({ isNumVDIV: !0, width: La, color: G($c, jb), dashStyle: ub ? f(vb, Fb, La) : "none", value: Ab, zIndex: 1 }), bc = Ab; ac && Uc && P.plotBands.push({ isNumVDIV: !0, color: Tc, from: bc, to: ab, zIndex: 1 })
    } na = Y.marginTop; Da = Y.marginBottom; Ua = Y.marginLeft; ta = Y.marginRight; ea.canvasstartx = Ua; ea.canvasstarty = na; ea.canvasendx = b - ta; ea.canvasendy = v - Da; ea.canvaswidth = ea.canvasendx - ea.canvasstartx; ea.canvasheight = ea.canvasendy - ea.canvasstarty; h.legend && h.legend.enabled && "vertical" === h.legend.layout &&
(ea.legendstarty = na + 0.5 * (u.height - Da - na - ea.legendheight) + (h.legend.y || 0), ea.legendendy = ea.legendstarty + ea.legendheight); D && Y.xDepth > Y.marginLeft && (Y.marginLeft = Y.xDepth); E.console && E.console.log && E.FC_DEV_ENVIRONMENT && console.log(h); return h
}, parseHoverEffectOptions: function (b) {
    var d = this.dataObj.chart, f; b.showHoverEffect = d.showhovereffect; b.plotHoverEffect = a(d.plothovereffect, d.anchorhovereffect, b.showHoverEffect); f = b.plotHoverEffects = { enabled: b.plotHoverEffect }; f.highlight = a(d.highlightonhover,
d.highlightplotonhover, b.plotHoverEffect); f.columnHighlight = a(f.highlight, d.highlightcolumnonhover, d.highlightbaronhover); f.anchorHighlight = a(f.highlight, d.highlightanchoronhover); f.imageHighlight = a(f.highlight, d.highlightanchorimageonhover); f.anchorImageHoverAlpha = c(d.anchorimagehoveralpha); f.anchorImageHoverScale = c(d.anchorimagehoverscale); f.bubbleHighlight = a(f.highlight, d.highlightbubbleonhover); f.color = c(d.plotfillhovercolor, d.columnhovercolor, d.barhovercolor, d.bubblehovercolor); f.alpha = c(d.plotfillhoveralpha,
d.columnhoveralpha, d.barhoveralpha, d.bubblehoveralpha); f.scale = c(d.plothoverscale, d.columnhoverscale, d.barhoverscale, d.bubblehoverscale); f.gradientColor = d.plothovergradientcolor; f.ratio = d.plothoverratio; f.angle = d.plothoverangle; f.borderColor = d.plotborderhovercolor; f.borderAlpha = d.plotborderhoveralpha; f.borderThickness = d.plotborderhoverthickness; f.borderDashed = d.plotborderhoverdashed; f.borderDashGap = d.plotborderhoverdashgap; f.borderDashLen = d.plotborderhoverdashlen; f.shadow = d.plothovershadow; f.anchorScale =
d.anchorhoverscale; f.anchorSides = d.anchorhoversides; f.anchorRadius = d.anchorhoverradius; f.anchorAlpha = d.anchorhoveralpha; f.anchorBgColor = c(d.anchorbghovercolor, d.anchorhovercolor); f.anchorBgAlpha = d.anchorbghoveralpha; f.anchorBorderColor = d.anchorborderhovercolor; f.anchorBorderAlpha = d.anchorborderhoveralpha; f.anchorBorderThickness = d.anchorborderhoverthickness; f.anchorStartAngle = d.anchorhoverstartangle; f.anchorDip = a(d.anchorhoverdip); f.anchorAnimation = a(d.anchorhoveranimation, 1); f.negativeColor = c(d.negativehovercolor,
d.negativecolor); f.is3DBubble = a(d.is3donhover)
}, parseExportOptions: function (b) {
    var d, f = this.dataObj.chart, g = this.chartInstance.jsVars.transparent ? "" : this.chartInstance.options.containerBackgroundColor || "#ffffff"; d = E.navigator.userAgent.match(/(iPad|iPhone|iPod)/g); b.exporting.enabled = a(f.exportenabled, 0); b.exporting.bgcolor = g; b.exporting.exporttargetwindow = c(f.exporttargetwindow, d ? "_blank" : "_self"); b.exporting.exportaction = f.exportaction && "save" === f.exportaction.toString().toLowerCase() && "save" ||
"download"; d = z(b.exporting.exportaction); b.exporting.exportfilename = c(f.exportfilename, "FusionCharts"); b.exporting.exporthandler = c(f.html5exporthandler, f.exporthandler, P); b.exporting.exportparameters = c(f.exportparameters, ""); b.exporting.exportformat = c(f.exportformat, "PNG"); b.exporting.exportatclient = a(f.exportatclient, 0); var g = b.exporting, e = f.exportformats; d = { JPG: d + " as JPEG image", PNG: d + " as PNG image", PDF: d + " as PDF document", SVG: d + " as SVG vector image" }; var q, r, k, h = 0; if (e) for (e = e.split("|"), h =
0; h < e.length; h++) k = (r = e[h].split("=")) && r[0].toUpperCase() || "", r = r && r[1] || "", d[k] && (q || (q = {}), q[k] = r || d[k]); g.exportformats = q || d; b.exporting.buttons.printButton.enabled = "1" == f.showprintmenuitem; b.exporting.buttons.exportButton.enabled = "1" == f.exportenabled ? "0" != f.exportshowmenuitem : !1
}, defaultSeriesType: l, paletteIndex: 1, creditLabel: Na, titleSpaceManager: W, placeLegendBlockBottom: cc, configureLegendOptions: Ua, placeLegendBlockRight: ta, placeHorizontalAxis: Da, placeVerticalAxis: na, placeHorizontalCanvasMarginAdjustment: hc,
    placeVerticalCanvasMarginAdjustment: kb, placeHorizontalXYSpaceManager: function (b, d, f, r) {
        var e = b[g], q, k, h, l, D = d.chart, m, n, L, s, t, U, w, u = b.chart, z = e.marginLeftExtraSpace, C = e.marginTopExtraSpace, T = e.marginBottomExtraSpace, B = e.marginRightExtraSpace; l = f - (z + B + u.marginRight + u.marginLeft); var pa = r - (T + u.marginBottom + u.marginTop), ia = 0.3 * l; f = 0.3 * pa; var ka = b.xAxis.showLine ? b.xAxis.lineThickness : 0; h = b.yAxis[0].showLine ? b.yAxis[0].lineThickness : 0; q = l - ia; r = pa - f; m = c(D.legendposition, Aa).toLowerCase(); b.legend.enabled &&
m === za && (q -= this.placeLegendBlockRight(b, d, q / 2, pa)); t = a(D.xaxisnamepadding, 5); U = a(D.labelpadding, 4); w = D.rotatexaxisname !== qa; n = c(D.showplotborder, e.is3d ? qa : Ya) === Ya; n = e.plotBorderThickness = n ? e.is3d ? 1 : a(D.plotborderthickness, 1) : 0; L = ba(a(u.plotBorderWidth, 1), 0); !e.isDual && u.marginRight < L && void 0 === D.chartrightmargin && (k = L - u.marginRight, l > ia + k && (u.marginRight = L, l -= k, ia = 0.3 * l, q = l - ia)); k = e.x; s = ba(L, n / 2); U < s && (U = s); k.verticalAxisNamePadding = t; k.verticalAxisValuesPadding = U + ka; k.rotateVerticalAxisName = w;
        k.verticalAxisNameWidth = a(D.xaxisnamewidth); q -= na(b.xAxis, k, b, d, pa, q, !1, !1, l); b.xAxis.lineEndExtension = h; q -= hc(b, d, q, b.xAxis); l = q + ia; b.legend.enabled && m !== za && (r -= this.placeLegendBlockBottom(b, d, l, r / 2)); r -= this.titleSpaceManager(b, d, l, r / 2); k = e[0]; k.horizontalAxisNamePadding = a(D.yaxisnamepadding, 5); k.horizontalLabelPadding = ba(a(D.yaxisvaluespadding, 4)) + h; k.labelDisplay = "auto"; k.staggerLines = a(D.staggerlines, 2); k.slantLabels = a(D.slantlabels, 0); k.horizontalLabelPadding = k.horizontalLabelPadding < L ? L : k.horizontalLabelPadding;
        this.xAxisMinMaxSetter(b, d, l); h = b.xAxis; t = h.plotLines; q = r / (h.max - h.min); t && t.length && (L = (t[0].value - h.min) * q, t = (h.max - t[t.length - 1].value) * q, e.isBar && (n > L && (h.min -= (n - L) / (2 * q)), n > t && (h.max += (n - t) / (2 * q)))); r -= this.placeHorizontalAxis(b.yAxis[0], k, b, d, l, r, ia); r -= kb(b, d, r, b.yAxis[0]); ya(f + r, b, D, b.xAxis, e.x.lYLblIdx, !0); cb(b, b.xAxis.title, r); b.legend.enabled && m === za && (b = b.legend, d = f + r, b.height > d && (b.height = d, b.scroll.enabled = !0, d = (b.scroll.scrollBarWidth = 10) + (b.scroll.scrollBarPadding = 2), b.width += d, u.marginRight +=
d), b.y = 20); u.marginLeft += z; u.marginTop += C; u.marginBottom += T; u.marginRight += B
    }, placeVerticalXYSpaceManager: function (b, d, f, r) {
        var e = b[g], q, k, h = !0, l = 0, D = d.chart, m = !1, L, n, s, t, U = b.chart, w, u, z = e.marginLeftExtraSpace, C = e.marginTopExtraSpace, T = e.marginBottomExtraSpace, B = e.marginRightExtraSpace; q = f - (z + B + U.marginRight + U.marginLeft); var pa = r - (T + U.marginBottom + U.marginTop), ia = 0.3 * q; r = 0.3 * pa; var ka = q - ia; f = pa - r; var l = e.drawFullAreaBorder = a(D.drawfullareaborder, 1), E = c(D.legendposition, Aa).toLowerCase(); t = b.xAxis.showLine ?
b.xAxis.lineThickness : 0; w = b.yAxis[0].showLine ? b.yAxis[0].lineThickness : 0; u = e.isDual && b.yAxis[1].showLine ? b.yAxis[1].lineThickness : 0; L = a(D.yaxisnamepadding, 5); n = a(D.yaxisvaluespadding, D.labelypadding, 4); k = c(D.showplotborder, e.is3d ? qa : Ya) === Ya; k = e.plotBorderThickness = k ? e.is3d ? 1 : a(D.plotborderthickness, 1) : 0; s = ba(a(U.plotBorderWidth, 1), 0); k = ba(s, k / 2); "area" !== this.defaultSeriesType || l || (k = s); n < s && (n = s); !e.isDual && U.marginRight < s && void 0 === D.chartrightmargin && (l = s - b.chart.marginRight, q > ia + l && (q -= l, ia =
0.3 * q, ka = q - ia)); b.legend.enabled && E === za && (ka -= this.placeLegendBlockRight(b, d, ka / 2, pa)); e.isDual && (m = !0, q = e[1], h = b.yAxis[1].opposite, l = c(D.rotateyaxisname, h ? "cw" : "ccw"), l = l === qa ? "none" : l, q.verticalAxisNamePadding = L, q.verticalAxisValuesPadding = n + u, q.rotateVerticalAxisName = l, q.verticalAxisNameWidth = a(D.syaxisnamewidth), ka -= na(b.yAxis[1], q, b, d, pa, ka / 2, h, m)); q = e[0]; h = !h; l = c(D.rotateyaxisname, h ? "cw" : "ccw"); l = l === qa ? "none" : l; q.verticalAxisNamePadding = L; q.verticalAxisValuesPadding = n + w; q.rotateVerticalAxisName =
l; q.verticalAxisNameWidth = a(m ? D.pyaxisnamewidth : D.yaxisnamewidth); ka -= na(b.yAxis[0], q, b, d, pa, ka, h, m); ka -= hc(b, d, ka, b.yAxis[0], b.yAxis[1]); h = ka + ia; b.legend.enabled && E !== za && (f -= this.placeLegendBlockBottom(b, d, h, f / 2)); f -= this.titleSpaceManager(b, d, h, f / 2); q = e.x; q.horizontalAxisNamePadding = a(D.xaxisnamepadding, 5); q.horizontalLabelPadding = a(D.labelpadding, D.labelxpadding, 4) + t; q.labelDisplay = c(D.labeldisplay, "auto").toLowerCase(); q.rotateLabels = a(D.rotatelabels, D.rotatexaxislabels, 0); q.staggerLines = a(D.staggerlines,
2); q.slantLabels = a(D.slantlabels, D.slantlabel, 0); b.yAxis[0].opposite ? (b.xAxis.lineEndExtension = w, b.xAxis.lineStartExtension = u) : (b.xAxis.lineEndExtension = u, b.xAxis.lineStartExtension = w); q.horizontalLabelPadding < k && (q.horizontalLabelPadding = k); t = { left: 0, right: 0 }; t = U.managePlotOverflow && this.canvasPaddingModifiers && this.calculateCanvasOverflow(b, !0) || t; w = t.left + t.right; u = 0.6 * h; w > u && (L = t.left / w, t.left -= L * (w - u), t.right -= (1 - L) * (w - u)); this.xAxisMinMaxSetter(b, d, h, t.left, t.right); f -= this.placeHorizontalAxis(b.xAxis,
q, b, d, h, f, ia); f -= kb(b, d, f, b.xAxis); b.title.alignWithCanvas || ("left" === b.title.align && b.yAxis[0].title.text && ib(b, b.yAxis[0].title, r + f), "right" === b.title.align && m && b.yAxis[1].title.text && ib(b, b.yAxis[1].title, r + f)); m && (ya(r + f, b, D, b.yAxis[1], e[1].lYLblIdx), cb(b, b.yAxis[1].title, r + f)); ya(r + f, b, D, b.yAxis[0], e[0].lYLblIdx); cb(b, b.yAxis[0].title, r + f); b.legend.enabled && E === za && (b = b.legend, d = r + f, b.height > d && "gradient" !== b.type && (b.height = d, b.scroll.enabled = !0, d = (b.scroll.scrollBarWidth = 10) + (b.scroll.scrollBarPadding =
2), b.width += d, U.marginRight += d)); U.marginLeft += z; U.marginTop += C; U.marginBottom += T; U.marginRight += B
    }, placeVerticalAxisTitle: cb, calculateCanvasOverflow: function (a, b) {
        for (var c = this.canvasPaddingModifiers, d = a.chart, e = this.smartLabel, f = 0, g = 0, q = 0, r = 0, k = f = !1, h = !1, D = c && c.length || 0, m, L, n, s, t; D--; ) switch (g = c[D], g) { case "anchor": k = L = f = !0; break; case "anchorlabel": n = L = f = !0; break; case "errorbar": h = f = !0 } if (f && (D = (c = a.series) && c.length || 0, b)) for (; D--; ) m = c[D], L && (f = m && m.data || [], 1 < f.length && (s = f[0], t = f[f.length -
1], k && (f = s && s.marker && s.marker.enabled && (s.marker.radius || 0) + (s.marker.lineWidth || 0) || 0, g = t && t.marker && t.marker.enabled && (t.marker.radius || 0) + (t.marker.lineWidth || 0) || 0, q = ba(f + 2, q), r = ba(g + 2, r)), n && (e.setStyle(a.plotOptions.series.dataLabels.style), d.rotateValues ? (g = e.getOriSize(s && s.displayValue || l), f = g.height / 2, g = e.getOriSize(t && t.displayValue || l), g = g.height / 2) : (g = e.getOriSize(s && s.displayValue || l), f = g.width / 2, g = e.getOriSize(t && t.displayValue || l), g = g.width / 2), q = ba(f + 2, q), r = ba(g + 2, r)))), h && (g = f = m.errorBarWidth /
2 + m.errorBarThickness || 0, q = ba(f + 2, q), r = ba(g + 2, r)); return { left: q, right: r}
    }, spaceManager: function () { return this.placeVerticalXYSpaceManager.apply(this, arguments) }, axisMinMaxSetter: function (b, c, d, f, e, g, q, r) {
        d = c.stacking100Percent ? D(99, 1, 100, 0, e, g, q, r) : D(a(c.max, d), a(c.min, f), d, f, e, g, q, r); b.min = Number(s(d.Min, 10)); b.max = Number(s(d.Max, 10)); b.tickInterval = Number(s(d.divGap, 10)); c.numdivlines = M.round((b.max - b.min) / b.tickInterval) - 1; 2 >= d.Range / d.divGap && (b.alternateGridColor = la); this.highValue = c.max; this.lowValue =
c.min; delete c.max; delete c.min
    }, configurePlotLines: function (b, d, f, q, e, r, k, h, D, m, L) {
        var n; n = f.min; var t = f.max, U = f.tickInterval, w = m ? "xAxis" : q.stacking100Percent ? "percentValue" : "yAxis", u = n, z = 1, C = f.gridLineColor, T = f.gridLineWidth, B = f.gridLineDashStyle, pa = 0 > n && 0 < t ? !0 : !1, ia = 0 === n, ka = 0 === t, E = 0 === a(q.showzeroplanevalue, b.showzeroplanevalue), I = !0, ra, J = 1, va = 0 < a(b.numdivlines, 0); d = d[g].axisGridManager; var H = this.colorManager; L = a(L, D ? 1 : 0); delete f._altGrid; delete f._lastValue; m && !q.catOccupied && (q.catOccupied =
{}); !pa || m && q.catOccupied[0] || (m ? (I = a(b.showvzeroplane, 1), ra = a(b.showvzeroplanevalue, r), va = a(b.vzeroplanethickness, 1), H = c(b.vzeroplanealpha, b.vdivlinealpha, H.getColor("divLineAlpha")), b = 0 < va ? G(c(b.vzeroplanecolor, C), H) : la) : (H = a(b.divlinealpha, H.getColor("divLineAlpha")), ra = a(q.showzeroplanevalue, b.showzeroplanevalue, r), !1 === this.defaultZeroPlaneHighlighted ? (I = a(q.showzeroplane, b.showzeroplane, !(this.defaultZeroPlaneHidden && !va)), va = T) : (va = 1 === T ? 2 : T, J = 5, H = V(2 * H, 100)), va = a(q.zeroplanethickness, b.zeroplanethickness,
va), H = c(q.zeroplanealpha, b.zeroplanealpha, H), b = 0 < va ? G(c(q.zeroplanecolor, b.zeroplanecolor, C), H) : la), I && (ra = ra ? h[w](0, L) : l, (J = d.addAxisGridLine(f, 0, ra, va, B, b, J, m)) && (J.isZeroPlane = !0)), f.effectiveZeroPlaneThickness = I && parseInt(H, 10) && va); 1 !== e || m && q.catOccupied[n] || (ra = ia && E ? l : h[w](n, L), (J = d.addAxisGridLine(f, n, ra, 0.1, void 0, la, 1, m)) && (J.isMinLabel = !0)); 0 >= T && (T = 0.1, C = la); for (n = Number(s(u + U, 10)); n < t; n = Number(s(n + U, 10)), z += 1) pa && 0 > u && 0 < n && !D && (d.addAxisAltGrid(f, 0), z += 1), 0 === n || m && q.catOccupied[n] ||
(ra = 1 === r && 0 === z % k ? h[w](n, L) : l, d.addAxisGridLine(f, n, ra, T, B, C, 2, m)), u = n, D || d.addAxisAltGrid(f, n); D || d.addAxisAltGrid(f, t); 1 !== e || 0 !== z % k || m && q.catOccupied[t] || (ra = ka && E ? l : h[w](t, L), (J = d.addAxisGridLine(f, t, ra, 0.1, B, la, 2, m)) && (J.isMaxLabel = !0)); this.realtimeEnabled && (f.labels._enabled = f.labels.enabled, f._gridLineWidth = f.gridLineWidth, f._alternateGridColor = f.alternateGridColor); f.labels.enabled = !1; f.gridLineWidth = 0; f.alternateGridColor = la; f.plotLines.sort(Va)
    }, xAxisMinMaxSetter: function (c, d, f, q, e) {
        var r =
c[g], k = r.x, h = d.chart, l = k.min = a(k.min, 0), D = k.max = a(k.max, k.catCount - 1), m = 0, n = 0, L = c.chart.defaultSeriesType, s = /^(column|column3d|bar|bar3d|floatedcolumn|sparkwinloss|boxandwhisker2d|dragcolumn)$/.test(L), t = /^(line|area|spline|areaspline)$/.test(L), L = /^(scatter|bubble|candlestick|dragnode)$/.test(L), U = c.xAxis, w = U.scroll; q = V(a(h.canvaspadding, q, 0), f / 2 - 10); e = V(a(h.canvaspadding, e, 0), f / 2 - 10); var u, z, C, T; k.adjustMinMax && (l = a(h.setadaptivexmin, 1), D = l = !l, u = a(this.numVDivLines, h.numvdivlines, 4), z = h.adjustvdiv !==
qa, C = a(h.showxaxisvalues, h.showxaxisvalue, 1), T = a(h.showvlimits, C), C = a(h.showvdivlinevalue, h.showvdivlinevalues, C), this.axisMinMaxSetter(U, k, h.xaxismaxvalue, h.xaxisminvalue, l, D, u, z), l = U.min, D = U.max, k.requiredAutoNumericLabels && (u = a(parseInt(h.xaxisvaluesstep, 10), 1), this.configurePlotLines(h, c, U, k, T, C, 1 > u ? 1 : u, r.numberFormatter, !1, !0)), U.plotLines.sort(Va)); U.labels.enabled = !1; U.gridLineWidth = 0; U.alternateGridColor = la; !s && !r.isScroll || r.hasNoColumn || (n = m = 0.5); r.is3d && (q += a(c.chart.xDepth, 0)); c = (f - (q +
e)) / (D - l + (m + n)); m = ba(m, q / c); n = ba(n, e / c); U.min = l - m; U.max = D + n; w && w.enabled && (n = w.vxLength, m = U.max - U.min, w.viewPortMin = U.min, w.viewPortMax = U.max, w.scrollRatio = n / m, w.flatScrollBars = r.flatScrollBars, w.scrollBar3DLighting = r.scrollBar3DLighting, U.max = U.min + n); t && U.min === U.max && (U.min -= 0.65, U.max += 0.65); L && d.vtrendlines && b(d.vtrendlines, U, r, !1, !0, !0)
    }, postSeriesAddition: function (b) {
        var d = b[g], f = d.isBar, q = d.is3d, e = b.chart.rotateValues && !f ? 270 : 0, r = d[0], l = r && r.stacking100Percent, D, m, n, L, s, t, U, w, u, z, C, T, B, pa,
ia, ka, E, G, I, ra, J, va, H; if (this.isStacked) for (n in D = d.plotSpacePercent, m = b.chart.defaultSeriesType, D = 1 - 2 * D, ka = b.series, E = this.numberFormatter, J = k({}, b.plotOptions.series.dataLabels.style), va = parseFloat(J.fontSize), H = !r.stacking100Percent, J.color = b.plotOptions.series.dataLabels.color, L = r.stack, L) {
            r = L[n].length; s = D / r; U = -(D - s) / 2; pa = []; T = 0; for (w = ka.length; T < w; T += 1) u = ka[T], u.yAxis || c(u.type, m) !== n || pa.push(u); for (t = 0; t < r; t += 1, U += s) {
                C = L[n][t]; ia = []; T = 0; for (w = pa.length; T < w; T += 1) u = pa[T], a(u.columnPosition,
0) === t && ia.push(u.data); if (C && C.length) for (z = 0, u = C.length; z < u; z += 1) if (T = C[z]) for (B = (T.n || 0) + (T.p || 0), d.showStackTotal && (w = z, w += U, T = 0 > B ? T.n : T.p, b.xAxis.plotLines.push({ value: w, width: 0, isVline: H, isTrend: !H, zIndex: 4, _isStackSum: 1, _catPosition: z, _stackIndex: t, label: { align: Xa, textAlign: q || 270 !== e ? f ? 0 > B ? za : Ga : Xa : 0 > B ? za : Ga, offsetScale: H ? T : void 0, offsetScaleIndex: 0, rotation: e, style: J, verticalAlign: ga, y: f ? 0 : 0 > B ? 270 === e ? 4 : va : -4, x: 0, text: d.numberFormatter.yAxis(B)} })), T = 0, w = ia.length; T < w; T += 1) if (I = ia[T][z]) if (ra =
B && (I.y || 0) / B * 100, G = E.percentValue(ra), I.toolText = h(I.toolText, [14, 24, 25, 112], { percentValue: G, sum: E.dataLabels(B), unformattedSum: B }), I.y || 0 === I.y) l && (I.y = ra, I.previousY || 0 === I.previousY) && (I.previousY = I.previousY / B * 100), I.showPercentValues && (I.displayValue = G)
            } 
        } 
    }, styleMapForFont: Ba, styleApplicationDefinition_font: function (a, b, c) {
        var d, e, f = !1, q, r, k = this.styleMapForFont; switch (b) {
            case "caption": d = a.title; break; case "datalabels": d = a.xAxis.labels; break; case "datavalues": d = a.plotOptions.series.dataLabels;
                f = !0; break; case "tldatavalues": d = { style: a.plotOptions.series.dataLabels.tlLabelStyle }; break; case "trdatavalues": d = { style: a.plotOptions.series.dataLabels.trLabelStyle }; break; case "bldatavalues": d = { style: a.plotOptions.series.dataLabels.blLabelStyle }; break; case "brdatavalues": d = { style: a.plotOptions.series.dataLabels.brLabelStyle }; break; case "subcaption": d = a.subtitle; break; case "tooltip": d = a.tooltip; break; case "trendvalues": d = { style: a[g].trendStyle }; break; case "xaxisname": d = a.xAxis.title; break; case "yaxisname": case "pyaxisname": case "axistitle": d =
[]; b = 0; for (q = a.yAxis.length; b < q; b += 1) d.push(a.yAxis[b].title); break; case "yaxisvalues": d = []; b = 0; for (q = a.yAxis.length; b < q; b += 1) d.push(a.yAxis[b].labels); break; case "vlinelabels": d = { style: a[g].divlineStyle }; break; case "legend": d = { style: a.legend.itemStyle }; break; default: (d = a.orphanStyles[b]) || (a.orphanStyles[b] = d = { text: "", style: {} })
        } if ("object" === typeof d) if (d instanceof Array) for (b = 0, q = d.length; b < q; b += 1) { r = d[b]; for (e in c) if (a = e.toLowerCase(), "function" === typeof k[a]) k[a](c[e], r, f); Q(r.style) } else {
            for (e in c) if (a =
e.toLowerCase(), "function" === typeof k[a]) k[a](c[e], d, f); Q(d.style)
        } 
    }, parseStyles: function (a) {
        var b, c, d, e = {}, f, g = this.dataObj; if (g.styles && g.styles.definition instanceof Array && g.styles.application instanceof Array) {
            for (b = 0; b < g.styles.definition.length; b += 1) c = g.styles.definition[b], c.type && c.name && this["styleApplicationDefinition_" + c.type.toLowerCase()] && (e[c.name.toLowerCase()] = c); for (b = 0; b < g.styles.application.length; b += 1) for (c = g.styles.application[b].styles && g.styles.application[b].styles.split(fa) ||
[], f = 0; f < c.length; f += 1) if (d = c[f].toLowerCase(), e[d] && g.styles.application[b].toobject) this["styleApplicationDefinition_" + e[d].type.toLowerCase()](a, g.styles.application[b].toobject.toLowerCase(), e[d])
        } 
    }, updateDefaultAnnotations: function () {
        var b = this.renderer, d = this.dataObj, f = this.chartInstance, g = d && d.annotations, e = {}, q; if (this.drawAnnotations && f.dataReady() && d.chart && a(d.chart.showannotations, 1) && g && g.groups && g.groups.length) {
            q = a(g.scaleonresize, d.chart.scaleonresize, 1); var b = { interactionevents: c(this.annotationInteractionEvents,
!0), showbelow: c(g.showbelow, g.showbelowchart), autoscale: g.autoscale, scaletext: g.scaletext, scaleimages: g.scaleimages, constrainedscale: g.constrainedscale, scaleonresize: q, origw: c(g.origw, d.chart.origw, q ? this.origRenderWidth : b.chartWidth), origh: c(g.origh, d.chart.origh, q ? this.origRenderHeight : b.chartHeight), xshift: g.xshift, yshift: g.yshift, grpxshift: g.grpxshift, grpyshift: g.grpyshift, xscale: g.xscale, yscale: g.yscale, rootxscale: a(g.xscale, 100) / 100, rootyscale: a(g.yscale, 100) / 100
            }, r; b || (b = {}); for (r in e) b[r] =
e[r]; f.annotations.reset(g, b, this.snapLiterals)
        } else f.annotations.clear()
    }, dispose: function () { var a; this.disposing = !0; this.renderer && this.renderer.dispose(); this.numberFormatter && this.numberFormatter.dispose(); this.hcJSON && this.hcJSON.chart && this.hcJSON.chart.renderTo && delete this.hcJSON.chart.renderTo; for (a in this) delete this[a]; delete this.disposing; this.disposed = !0 } 
}); X("stub", { init: function (a, b, c) { this.containerElement = a; this.smartLabel = c.jsVars.smartLabel }, standaloneInit: !0 }, X.base); X("barbase",
{ spaceManager: function () { return this.placeHorizontalXYSpaceManager.apply(this, arguments) } }, X.base); X("singleseries", { series: function (a, c, d) { var f = a.data || a.dataset && a.dataset[0] && a.dataset[0].data, e; f && 0 < f.length && f instanceof Array && (e = { data: [], hoverEffects: this.parseSeriesHoverOptions(a, c, {}, d), colorByPoint: !0 }, c.legend.enabled = !1, d = this.point(d, e, f, a.chart, c), d instanceof Array ? c.series = c.series.concat(d) : c.series.push(d), this.configureAxis(c, a), a.trendlines && b(a.trendlines, c.yAxis, c[g], !1, this.isBar)) },
    defaultSeriesType: l, configureAxis: function (b, d) {
        var f = b[g], q = b.xAxis, e = d.chart, r = b.chart.is3D, k, h, l, D, m, n, L, s, U, w, u, z, T = 0, C, B, pa, ia, ka, E, I, ra = this.numberFormatter, J = a(e.syncaxislimits, 0), va; q.title.text = t(e.xaxisname); va = a(parseInt(e.yaxisvaluesstep, 10), parseInt(e.yaxisvaluestep, 10), 1); va = 1 > va ? 1 : va; k = b.yAxis[0]; h = f[0]; f.isDual ? (l = ra.getCleanValue(e.pyaxismaxvalue), D = ra.getCleanValue(e.pyaxisminvalue), k.title.text = t(e.pyaxisname), J && !h.stacking100Percent ? (z = f[1], u = a(z.max), z = a(z.min), void 0 !== u && void 0 !==
z && (h.min = V(h.min, z), h.max = ba(h.max, u)), u = ra.getCleanValue(e.syaxismaxvalue), z = ra.getCleanValue(e.syaxisminvalue), null !== z && (D = null !== D ? V(D, z) : z), null !== u && (l = null !== l ? ba(l, u) : u)) : J = 0) : (l = ra.getCleanValue(e.yaxismaxvalue), D = ra.getCleanValue(e.yaxisminvalue), k.title.text = t(e.yaxisname)); L = a(this.isStacked ? 0 : this.setAdaptiveYMin, e.setadaptiveymin, this.defSetAdaptiveYMin, 0); n = m = !L; s = a(f.numdivlines, e.numdivlines, this.numdivlines, 4); U = e.adjustdiv !== qa; w = a(this.showYAxisValues, e.showyaxisvalues, e.showyaxisvalue,
1); u = a(e.showlimits, w); z = a(e.showdivlinevalue, e.showdivlinevalues, w); r || (T = a(e.showaxislines, e.drawAxisLines, 0), pa = a(e.axislinethickness, 1), ka = a(e.axislinealpha, 100), 100 < ka && (ka = 100), B = G(c(e.axislinecolor, "#000000"), ka), k.showLine = a(e.showyaxisline, T), C = q.showLine = a(e.showxaxisline, T), ia = q.lineThickness = a(e.xaxislinethickness, pa), k.lineThickness = a(e.yaxislinethickness, pa), E = q.lineAlpha = a(e.xaxislinealpha, ka), 100 < E && (E = q.lineAlpha = 100), I = k.lineAlpha = a(e.yaxislinealpha, ka), 100 < I && (I = k.lineAlpha = 100),
q.lineColor = G(c(e.xaxislinecolor, B), E), k.lineColor = G(c(e.yaxislinecolor, B), I), b.chart.xAxisLineVisible = C && !!ia && 0 < E); this.axisMinMaxSetter(k, h, l, D, m, n, s, U); this.configurePlotLines(e, b, k, h, u, z, va, f.numberFormatter, !1); k.reversed && 0 <= k.min && (b.plotOptions.series.threshold = k.max); f.isDual && (k = b.yAxis[1], h = f[1], u = a(e.showsecondarylimits, u), z = a(e.showdivlinesecondaryvalue, w), J ? (q = b.yAxis[0], k.min = q.min, k.max = q.max, k.tickInterval = q.tickInterval, delete h.max, delete h.min) : (l = ra.getCleanValue(e.syaxismaxvalue),
D = ra.getCleanValue(e.syaxisminvalue), L = a(e.setadaptivesymin, L), n = m = !L, this.axisMinMaxSetter(k, h, l, D, m, n, s, U)), r || (k.showLine = a(e.showsyaxisline, T), k.lineThickness = a(e.syaxislinethickness, pa), r = k.lineAlpha = a(e.syaxislinealpha, ka), 100 < r && (r = 100), k.lineColor = G(c(e.syaxislinecolor, B), r)), this.configurePlotLines(e, b, k, h, u, z, va, f.numberFormatter, !0), k.title.text = t(e.syaxisname))
    }, pointValueWatcher: function (b, d, f, q, e, r, k) {
        b = b[g]; var h; if (null !== d) return f = a(f, 0), b[f] || (b[f] = {}), f = b[f], q && (this.distributedColumns &&
(b.marimekkoTotal += d), q = f.stack, e = a(e, 0), r = a(r, 0), k = c(k, Ca), q[k] || (q[k] = []), k = q[k], k[r] || (k[r] = []), r = k[r], r[e] || (r[e] = {}), e = r[e], 0 <= d ? e.p ? (h = e.p, d = e.p += d) : e.p = d : e.n ? (h = e.n, d = e.n += d) : e.n = d), f.max = f.max > d ? f.max : d, f.min = f.min < d ? f.min : d, h
    }, parseSeriesHoverOptions: function (b, d, f) {
        b = d.chart.plotHoverEffects; d = { enabled: c(f.showhovereffect, f.hovereffect, b.enabled) }; d.highlight = a(f.highlightonhover, f.highlightplotonhover, b.highlight); d.columnHighlight = a(d.highlight, f.highlightcolumnonhover, f.highlightbaronhover,
b.columnHighlight); d.anchorHighlight = a(d.highlight, f.highlightanchoronhover, b.anchorHighlight); d.anchorHighlight = a(d.highlight, f.highlightimageonhover, b.imageHighlight); d.bubbleHighlight = a(d.highlight, f.highlightbubbleonhover, f.highlightbaronhover, b.bubbleHighlight); d.imageHoverAlpha = c(f.anchorimagehoveralpha, b.anchorImageHoverAlpha); d.imageHoverScale = c(f.anchorimagehoverscale, b.anchorImageHoverScale); d.color = c(f.hovercolor, f.bubblehovercolor, b.color); d.alpha = c(f.hoveralpha, b.alpha); d.scale = c(f.hoverscale,
f.bubblehoverscale, b.scale); d.gradientColor = void 0 !== f.hovergradientcolor ? f.hovergradientcolor : b.gradientColor; d.ratio = c(f.hoverratio, b.ratio); d.angle = c(f.hoverangle, b.angle); d.borderColor = c(f.borderhovercolor, b.borderColor); d.borderAlpha = c(f.borderhoveralpha, b.borderAlpha); d.borderThickness = a(f.borderhoverthickness, b.borderThickness); d.borderDashed = a(f.borderhoverdashed, b.borderDashed); d.borderDashGap = a(f.borderhoverdashgap, b.borderDashGap); d.borderDashLen = a(f.borderhoverdashlen, b.borderDashLen);
        d.shadow = c(f.hovershadow, b.shadow); d.anchorSides = c(f.anchorhoversides, b.anchorSides); d.anchorRadius = c(f.anchorhoverradius, b.anchorRadius); d.anchorScale = c(f.anchorhoverscale, b.anchorScale); d.anchorAlpha = c(f.anchorhoveralpha, f.hoveralpha, b.anchorAlpha); d.anchorBgColor = c(f.anchorbghovercolor, f.anchorhovercolor, b.anchorBgColor); d.anchorBgAlpha = c(f.anchorbghoveralpha, b.anchorBgAlpha); d.anchorBorderColor = c(f.anchorborderhovercolor, b.anchorBorderColor); d.anchorBorderAlpha = f.anchorborderhoveralpha; d.anchorBorderThickness =
a(f.anchorborderhoverthickness, b.anchorBorderThickness); d.anchorStartAngle = c(f.anchorhoverstartangle, b.anchorStartAngle); d.anchorDip = c(f.anchorhoverdip, b.anchorDip); d.anchorAnimation = a(f.anchorhoveranimation, b.anchorAnimation, 1); d.negativeColor = c(f.negativehovercolor, b.negativeColor); d.is3DBubble = a(f.is3donhover, b.is3DBubble); return d
    }, pointHoverOptions: function (b, d, g) {
        var q, e, r, k = {}; q = d.hoverEffects; d = a(b.hovereffect, q && q.enabled); e = !1; var h = { enabled: d }, D = g && l + g.plotType.toLowerCase(); if (void 0 ===
d) if (this.forceHoverEnable) e = d = h.enabled = !0; else {
            "anchor" == D && (e = g.imageUrl ? d = h.enabled = void 0 !== c(b.anchorimagehoveralpha, q.imageHoverAlpha, b.anchorimagehoverscale, q.imageHoverScale, void 0) : d = h.enabled = void 0 !== c(b.hovercolor, b.anchorhovercolor, b.anchorbghovercolor, q.anchorBgColor, q.color, b.hoveralpha, b.anchorhoveralpha, q.anchorAlpha, b.bghoveralpha, b.anchorbghoveralpha, q.anchorBgAlpha, b.anchorborderhovercolor, b.borderhovercolor, q.anchorBorderColor, b.anchorborderhoverthickness, b.borderhoverthickness,
q.anchorBorderThickness, b.anchorborderhoveralpha, b.borderhoveralpha, q.anchorBorderAlpha, b.hoverdip, b.anchorhoverdip, q.anchorDip, b.anchorhoverstartangle, q.anchorStartAngle, b.hoversides, b.anchorhoversides, q.anchorSides, b.hoverradius, b.anchorhoverradius, q.anchorRadius, void 0)); if ("column" == D || "bubble" == D) e = d = h.enabled = void 0 !== c(b.hoveralpha, q.alpha, b.hovergradientcolor, q.gradientColor, b.borderhovercolor, q.borderColor, b.borderhoverthickness, q.borderThickness, b.hoverratio, q.ratio, b.hoverangle, q.angle,
b.borderhoveralpha, q.borderAlpha, b.borderhoverdashed, q.borderDashed, b.borderhoverdashgap, q.borderDashGap, b.borderhoverdashlen, q.borderDashLen, b.hovercolor, q.color, void 0); e || "bubble" != D || (e = d = h.enabled = void 0 !== c(b.negativehovercolor, q.negativeColor, b.is3donhover, q.is3DBubble, b.hoverscale, q.scale, void 0)); "pie" == D && (e = d = h.enabled = void 0 !== c(b.hovercolor, q.color, b.hoveralpha, q.alpha, b.borderhovercolor, q.borderColor, b.borderhoverthickness, q.borderThickness, b.borderhoveralpha, q.borderAlpha, void 0))
        } if (d) {
            h.highlight =
a(b.highlightonhover, q.highlight); h.columnHighlight = a(h.highlight, b.highlightcolumnonhover, b.highlightbaronhover); h.anchorHighlight = a(h.highlight, b.highlightanchoronhover); h.bubbleHighlight = a(h.highlight, b.highlightbubbleonhover); h.alpha = c(b.hoveralpha, q.alpha, g.alpha); h.scale = c(b.scale, q.scale, 1); h.gradientColor = void 0 === b.hovergradientcolor ? q.gradientColor : b.hovergradientcolor; h.borderColor = c(b.borderhovercolor, q.borderColor, g.borderColor); h.borderThickness = a(b.borderhoverthickness, q.borderThickness,
g.borderWidth); h.ratio = c(b.hoverratio, q.ratio, g.ratio); h.angle = c(b.hoverangle, q.angle, g.angle); h.borderAlpha = c(b.borderhoveralpha, q.borderAlpha, g.borderAlpha); h.borderDashed = a(b.borderhoverdashed, q.borderDashed, g.borderDashed, 0); h.borderDashGap = a(b.borderhoverdashgap, q.borderDashGap, g.borderDashGap); h.borderDashLen = a(b.borderhoverdashlen, q.borderDashLen, g.borderDashLen); h.shadow = c(b.hovershadow, q.shadow, 0); h.color = c(b.hovercolor, q.color); "anchor" == D && (g.imageUrl ? (h.imageHoverAlpha = a(b.anchorimagehoveralpha,
q.imageHoverAlpha, 100), h.imageHoverScale = g.imageScale * da(a(b.anchorimagehoverscale, q.imageHoverScale, 110)) * 0.01, h.anchorAnimation = a(b.anchorhoveranimation, q.anchorAnimation, 1)) : (h.anchorColor = w(c(b.hovercolor, b.anchorhovercolor, b.anchorbghovercolor, q.anchorBgColor, q.color, g.anchorBgColor)), h.anchorAlpha = c(b.hoveralpha, b.anchorhoveralpha, q.anchorAlpha, g.anchorAlpha), h.anchorBgAlpha = c(b.bghoveralpha, b.anchorbghoveralpha, q.anchorBgAlpha, h.anchorAlpha, g.anchorBgAlpha), h.anchorBorderColor = c(b.anchorborderhovercolor,
b.borderhovercolor, q.anchorBorderColor, g.anchorBorderColor), h.anchorBorderThickness = c(b.anchorborderhoverthickness, b.borderhoverthickness, q.anchorBorderThickness, g.anchorBorderThickness), h.anchorBorderAlpha = a(b.anchorborderhoveralpha, b.borderhoveralpha, q.anchorBorderAlpha, h.anchorAlpha, g.anchorBorderAlpha), h.anchorDip = a(b.hoverdip, b.anchorhoverdip, q.anchorDip), h.startAngle = c(b.anchorhoverstartangle, q.anchorStartAngle, g.anchorAngle), h.anchorSides = a(b.hoversides, b.anchorhoversides, q.anchorSides, g.anchorSides),
h.anchorRadius = a(b.hoverradius, b.anchorhoverradius, q.anchorRadius), h.anchorScale = a(b.hoverscale, b.anchorhoverscale, q.anchorScale), h.anchorAnimation = a(b.anchorhoveranimation, q.anchorAnimation, 1), void 0 === h.anchorRadius && (h.anchorRadius = !e || h.anchorHighlight ? g.anchorRadius && g.anchorRadius + 1 : g.anchorRadius))); if (e || (h.columnHighlight || h.bubbleHighlight) && h.color && 1 == h.highlight) h.highlight = 0; "column" == D && (h.color = (c(h.color, g.color) + fa + (void 0 === h.gradientColor ? g.gradientColor : h.gradientColor)).replace(/,+?$/,
"")); "pie" === D && (h.color = c(h.color, g.color).replace(/,+?$/, "")); "bubble" == D && (h.negativeColor = c(b.negativehovercolor, q.negativeColor, g.negativeColor), h.is3d = a(b.is3donhover, q.is3DBubble, g.is3d), h.color = h.negativeColor && 0 > b.z ? h.negativeColor : h.color || g.color, r = "string" == typeof h.color, h.color = w(r ? h.color : h.color.FCcolor.color), h.color = h.is3d ? X.bubble.getPointColor(h.color, h.alpha) : h.color); if (1 == h.highlight && "anchor" !== D) {
                b = (r = "string" == typeof h.color) ? h.color.split(/\s{0,},\s{0,}/) : h.color.FCcolor.color.split(/\s{0,},\s{0,}/);
                q = b.length; for (e = 0; e < q; e++) b[e] = I(b[e], 70); r ? h.color = b.join(",") : h.color.FCcolor.color = b.join(",")
            } "pie" === D && (k = { color: this.getPointColor(h.color, h.alpha, g.radius3D), alpha: h.alpha, borderColor: G(h.borderColor, h.borderAlpha), borderWidth: h.borderThickness }); "column" == D && (h.colorArr = ha(h.color, h.alpha, h.ratio, h.angle, g.isRoundEdged, h.borderColor, V(h.alpha, h.borderAlpha).toString(), g.isBar, g.is3d), h.dashStyle = h.borderDashed ? f(h.borderDashLen, h.borderDashGap, h.borderThickness) : "none", k = { shadow: h.shadow,
                color: h.colorArr[0], borderColor: h.colorArr[1], borderWidth: h.borderThickness, use3DLighting: g.use3DLighting, dashStyle: h.dashStyle
            }); "anchor" == D && (k = g.imageUrl ? { animation: h.anchorAnimation, imageHoverAlpha: h.imageHoverAlpha, imageHoverScale: h.imageHoverScale} : { animation: h.anchorAnimation, shadow: h.shadow, fillColor: { FCcolor: { color: h.anchorColor, alpha: h.anchorBgAlpha * h.anchorAlpha / 100 + l} }, lineColor: { FCcolor: { color: h.anchorBorderColor, alpha: h.anchorBorderAlpha} }, lineWidth: h.anchorBorderThickness, radius: h.anchorRadius,
                symbol: ma(h.anchorSides), startAngle: h.startAngle, sides: h.anchorSides, scale: h.anchorScale, dip: h.anchorDip
            }); "bubble" == D && (k = { symbol: h.seriesAnchorSymbol, shadow: h.shadow, scale: h.scale, fillColor: h.color, lineColor: { FCcolor: { color: h.borderColor, alpha: h.alpha} }, lineWidth: h.borderThickness })
        } return { enabled: d, options: h, rolloverOptions: k}
    }, getPointStub: function (b, d, f, q) {
        var e = this.dataObj.chart; q = q[g]; d = null === d ? d : q.numberFormatter.dataLabels(d); var r = J(t(c(b.tooltext, q.tooltext))), k = J(t(b.displayvalue)),
e = q.showTooltip ? void 0 !== r ? h(r, [1, 2, 3, 5, 6, 7], { formattedValue: d, label: f, yaxisName: t(e.yaxisname), xaxisName: t(e.xaxisname) }, b, e) : null === d ? !1 : f !== l ? f + q.tooltipSepChar + d : d : l; q = a(b.showvalue, q.showValues) ? void 0 !== k ? k : d : l; b = c(b.link); return { displayValue: q, categoryLabel: f, toolText: e, link: b}
    }, updateSnapPoints: function () {
        var a = this, b = a.snapLiterals, c = function (a, b) {
            var c = 0; switch (a) {
                case "startx": c = b.x; break; case "starty": c = b.y; break; case "x": case "middlex": case "centerx": c = b.x + b.width / 2; break; case "y": case "middley": case "centery": c =
b.y + b.height / 2; break; case "endx": c = b.x + b.width; break; case "endy": c = b.y + b.height; break; default: c = 0
            } return c
        }; b.dataset = function (b, d) { var f = a.renderer && a.renderer.plots, g, q, r, h; r = a.is3D; if (!f || !f.length) return 0; isNaN(b[0]) ? g = 0 : (g = Number(b[0]), b = b.slice(1)); q = b[0]; if ("set" === q) { isNaN(b[1]) ? (h = 0, b = b.slice(1)) : (h = Number(b[1]), b = b.slice(2)); q = b[0]; f = (f = f[g] && f[g].items[h]) && f.graphic; if (!f) return 0; r = d && r ? f._getBBox2() : f.getBBox(); h = c(q, r) } return h }; b.xaxis = function (b) {
            var d = a.renderer && a.renderer.xAxis &&
a.renderer.xAxis[0] && a.renderer.xAxis[0].labels, f, g; if (!d || !d.length) return 0; g = b[0]; if ("label" === g) { isNaN(b[1]) ? (f = 0, b = b.slice(1)) : (f = Number(b[1]), b = b.slice(2)); g = b[0]; b = d[f]; if (!b) return 0; b = b.getBBox(); f = c(g, b) } return f
        }; b.yaxis = function (b) {
            var d = a.renderer && a.renderer.yAxis, f, g; if (!d || !d.length) return 0; isNaN(b[0]) ? f = 0 : (f = Number(b[0]), b = b.slice(1)); f = d[f]; if (!f) return 0; d = b[0]; if ("label" === d) {
                g = f.labels; isNaN(b[1]) ? (f = 0, b = b.slice(1)) : (f = Number(b[1]), b = b.slice(2)); d = b[0]; b = g[f]; if (!b) return 0;
                b = b.getBBox(); g = c(d, b)
            } return g
        } 
    } 
}, X.base); X("multiseries", { series: function (c, d, f) {
    var q, e, r = d[g], h, k; d.legend.enabled = Boolean(a(c.chart.showlegend, 1)); if (c.dataset && 0 < c.dataset.length) {
        this.categoryAdder(c, d); q = 0; for (e = c.dataset.length; q < e; q += 1) h = c.dataset[q], k = { hoverEffects: this.parseSeriesHoverOptions(c, d, h, f), visible: !a(h.initiallyhidden, 0), data: [] }, this.isStacked || (k.numColumns = e), h = this.point(f, k, h, c.chart, d, r.oriCatTmp.length, q), h instanceof Array ? d.series = d.series.concat(h) : d.series.push(h);
        this.configureAxis(d, c); c.trendlines && !this.isLog && b(c.trendlines, d.yAxis, r, !1, this.isBar, void 0, this.inversed)
    } 
}, categoryAdder: function (b, c) {
    var d, f = 0, e = c[g], q = e.axisGridManager, r = b.chart, h = c.xAxis, k, e = e.x, D, m, n; if (b.categories && b.categories[0] && b.categories[0].category) for (b.categories[0].font && (c.xAxis.labels.style.fontFamily = b.categories[0].font), void 0 !== (d = a(b.categories[0].fontsize)) && (1 > d && (d = 1), c.xAxis.labels.style.fontSize = d + Pa, Q(c.xAxis.labels.style)), b.categories[0].fontcolor && (c.xAxis.labels.style.color =
b.categories[0].fontcolor.split(fa)[0].replace(/^\#?/, "#")), m = c[g].oriCatTmp, n = b.categories[0].category, d = 0; d < n.length; d += 1) n[d].vline ? q.addVline(h, n[d], f, c) : (D = a(n[d].showlabel, r.showlabels, 1), k = t(B(b.categories[0].category[d].label, b.categories[0].category[d].name)), q.addXaxisCat(h, f, f, D ? k : l), m[f] = B(t(b.categories[0].category[d].tooltext), k), f += 1); e.catCount = f
}, getPointStub: function (b, d, f, q, e, r, k, D, m, n) {
    var L = this.dataObj.chart, s = this.isDual, U = this.isXY, w = this.isMLAxis, u = this.isStacked, z = this.isErrorChart,
T; q = q[g]; var C, pa, ia = null === d ? d : this.numberFormatter.dataLabels(d, k), ka, E = J(t(c(b.tooltext, e.plottooltext, q.tooltext))), I = q.tooltipSepChar, ra, G = {}, va, H, P, N, Ka, K, M, na, Sa; z && (H = null === D ? D : this.numberFormatter.dataLabels(D, k), K = null === d ? l : this.numberFormatter.percentValue(D / d * 100), ra = [1, 2, 3, 4, 5, 6, 7, 99, 100, 101, 102], d = { yaxisName: N = t(s ? k ? L.syaxisname : L.pyaxisname : L.yaxisname), xaxisName: Ka = t(L.xaxisname), formattedValue: ia, label: f, errorDataValue: H, errorPercentValue: K }, U ? (P = null === m ? m : this.numberFormatter.xAxis(m),
M = null === n ? l : this.numberFormatter.percentValue(m / n * 100), ra.push(103, 104, 105, 106, 107, 108, 109, 110), Sa = c(b.horizontalerrorvalue, b.errorvalue), d.errorValue = na = c(b.verticalerrorvalue, b.errorvalue), n = J(t(c(b.verticalerrorplottooltext, b.errorplottooltext, e.verticalerrorplottooltext, e.errorplottooltext, L.verticalerrorplottooltext, L.errorplottooltext))), null !== D && (d.verticalErrorDataValue = H, d.verticalErrorPercentValue = K, d.verticalErrorValue = na), null !== m && (d.horizontalErrorDataValue = P, d.horizontalErrorPercentValue =
M, d.horizontalErrorValue = Sa), va = J(t(c(b.horizontalerrorplottooltext, b.errorplottooltext, e.horizontalerrorplottooltext, e.errorplottooltext, L.horizontalerrorplottooltext, L.errorplottooltext))), G._hErrortoolText = q.showTooltip ? void 0 !== va ? h(va, ra, { yaxisName: N = t(s ? k ? L.syaxisname : L.pyaxisname : L.yaxisname), xaxisName: Ka = t(L.xaxisname), formattedValue: ia, label: f, errorDataValue: P, errorPercentValue: M, errorValue: Sa, verticalErrorDataValue: H, verticalErrorPercentValue: K, verticalErrorValue: na, horizontalErrorDataValue: P,
    horizontalErrorPercentValue: M, horizontalErrorValue: Sa
}, b, L, e) : null === D ? !1 : P : !1) : (n = J(t(c(b.errorplottooltext, e.errorplottooltext, L.errorplottooltext))), d.errorValue = na = c(b.errorvalue)), G._errortoolText = q.showTooltip ? void 0 !== n ? h(n, ra, d, b, L, e) : null === D ? !1 : H : !1); q.showTooltip ? void 0 !== E ? (u = [4, 5, 6, 7], k = { yaxisName: N || t(s ? k ? L.syaxisname : L.pyaxisname : w ? e._yAxisName : L.yaxisname), xaxisName: Ka || t(L.xaxisname) }, U ? (u.push(8, 9, 10, 11), k.yDataValue = ia, k.xDataValue = f, z && (u.push(103, 104, 105, 106, 107, 108, 109, 110),
null !== D && (k.verticalErrorDataValue = H, k.verticalErrorPercentValue = K, k.verticalErrorValue = na), null !== m && (k.horizontalErrorDataValue = P, k.horizontalErrorPercentValue = M, k.horizontalErrorValue = Sa))) : (u.push(1, 2, 3), k.formattedValue = ia, k.label = f, z && (u.push(99, 100, 101, 102), k.errorValue = na, null !== D && (k.errorDataValue = H, k.errorPercentValue = K))), e = h(E, u, k, b, L, e)) : null === ia ? e = !1 : (q.seriesNameInToolTip && (ka = B(e && e.seriesname)), e = ka ? ka + I : l, e += f ? f + I : l, q.showPercentInToolTip && u ? (pa = !0, e += "$percentValue") : e += ia) :
e = !1; a(b.showvalue, r) ? void 0 !== J(b.displayvalue) ? T = t(b.displayvalue) : q.showPercentValues ? C = !0 : T = ia : T = l; G.link = c(b.link); G.displayValue = T; G.categoryLabel = f; G.toolText = e; G.showPercentValues = C; G.showPercentInToolTip = pa; return G
} 
}, X.singleseries); X("xybase", { hideRLine: function () { var a = this.chart.series[this.index + 1]; a && a.hide && a.hide() }, showRLine: function () { var a = this.chart.series[this.index + 1]; a && a.show && a.show() }, getRegressionLineSeries: function (a, b, c) {
    var d, e, f, g; g = a.sumXY; var q = a.sumX, r = a.sumY; e =
a.xValues; f = a.sumXsqure; d = a.yValues; a = a.sumYsqure; b ? (e.sort(Cb), d = e[0], e = e[e.length - 1], g = (c * g - q * r) / (c * f - ca(q, 2)), f = isNaN(g) ? r / c : g * (d - q / c) + r / c, c = isNaN(g) ? r / c : g * (e - q / c) + r / c, c = [{ x: d, y: f }, { x: e, y: c}]) : (d.sort(Cb), f = d[0], d = d[d.length - 1], g = (c * g - q * r) / (c * a - ca(r, 2)), e = isNaN(g) ? q / c : g * (f - r / c) + q / c, c = isNaN(g) ? q / c : g * (d - r / c) + q / c, c = [{ x: e, y: f }, { x: c, y: d}]); return c
}, pointValueWatcher: function (a, b, c, d) {
    var e = a[g]; null !== b && (a = e[0], a.max = a.max > b ? a.max : b, a.min = a.min < b ? a.min : b); null !== c && (a = e.x, a.max = a.max > c ? a.max : c, a.min =
a.min < c ? a.min : c); d && (c = c || 0, b = b || 0, d.sumX += c, d.sumY += b, d.sumXY += c * b, d.sumXsqure += ca(c, 2), d.xValues.push(c), d.sumYsqure += ca(b, 2), d.yValues.push(b))
} 
}, X.multiseries); X("scrollbase", { postSeriesAddition: function () {
    var b = this.hcJSON, d = b.xAxis.scroll, f = b[g], q = f.width, e = f.x.catCount, r = this.dataObj.chart, h = this.colorManager, k, l, D, m, n, L; f.isScroll = !0; b.chart.hasScroll = !0; if (this.isStacked) k = 1; else {
        l = k = 0; m = b.series; L = b.chart.defaultSeriesType; for (D = m.length; l < D; l++) n = c(m[l].type, L), "column" === n && (k += 1); 1 > k &&
(k = 1)
    } e *= k; q = a(r.numvisibleplot, ua(q / this.avgScrollPointWidth)); d && 2 <= q && q < e && (d.enabled = !0, d.vxLength = q / k, d.startPercent = V(1, ba(0, parseFloat(r.scrolltoend) || 0)), d.padding = a(r.scrollpadding, 0), d.height = a(r.scrollheight, 16), d.buttonWidth = a(r.scrollbtnwidth, r.scrollheight, 16), d.buttonPadding = a(r.scrollbtnpadding, 0), d.color = w(c(r.scrollcolor, h.getColor("altHGridColor"))), f.marginBottomExtraSpace += d.padding + d.height); if (U || a(r.enabletouchscroll, 0)) b.chart.zoomType = "x", b.chart.nativeZoom = !1, b.chart.selectionMarkerFill =
"rgba(255,255,255,0)", (b.callbacks || (b.callbacks = [])).push(function (a) { H(a, "selectionstart selectiondrag", X.scrollbase.performTouchScroll, {}) })
}, performTouchScroll: function (a) { var b = this.xAxis[0].scroller, c = b.config, c = c.trackLength / (c.width / c.scrollRatio) * (a.chartX || 1); !0 !== a.isOutsidePlot && T(b.elements.anchor.element, "selectionstart" === a.type ? "dragstart" : "drag", { pageX: -c, pageY: -a.chartY }) } 
}, X.multiseries); X("logbase", { isLog: !0, isValueAbs: !0, configureAxis: function (d, f) {
    var q = d[g], r = q.axisGridManager,
e = this.numberFormatter, h = d.series, D = d.xAxis, m = d.yAxis[0], n = q[0], s = f.chart, U = !a(s.showlimits, s.showyaxisvalues, 1), w = !a(s.showdivlinevalues, s.showyaxisvalues, 1), u = a(s.base, s.logbase, 10), z = a(s.yaxismaxvalue), T = a(s.yaxisminvalue), C = this.colorManager, B = 1 === a(s.showminordivlinevalues), pa = c(s.minordivlinecolor, m.gridLineColor, C.getColor("divLineColor")), ia = a(s.minordivlinealpha, s.divlinealpha, C.getColor("divLineAlpha")), C = [m, void 0, void 0, a(s.divlinethickness, 2), m.gridLineDashStyle, m.gridLineColor, 2], pa =
[m, void 0, void 0, a(s.minordivlinethickness, 1), m.gridLineDashStyle, G(c(s.minordivlinecolor, pa), a(s.minordivlinealpha, ia / 2)), 2], ia = B || ia && pa[3], ka; 0 >= u && (u = 10); 0 >= z && (z = void 0); 0 >= T && (T = void 0); z = this.getLogAxisLimits(n.max || u, n.min || 1, z, T, u, ia ? s.numminordivlines : 0); D.title.text = t(s.xaxisname); D.showLine = a(s.showxaxisline, s.showaxislines, 0); D.lineThickness = a(s.xaxislinethickness, s.axislinethickness, 1); D.lineAlpha = a(s.xaxislinealpha, s.axislinealpha, 100); D.lineColor = G(c(s.xaxislinecolor, s.axislinecolor,
"000")); k(m, { title: { text: t(s.yaxisname) }, labels: { enabled: !1 }, gridLineWidth: 0, alternateGridColor: la, reversed: "1" === s.invertyaxis, max: L(z.Max, u), min: L(z.Min, u), showLine: a(s.showyaxisline, s.showaxislines, 0), lineThickness: a(s.yaxislinethickness, s.axislinethickness, 1), lineAlpha: a(s.yaxislinealpha, s.axislinealpha, 100), lineColor: G(c(s.yaxislinecolor, s.axislinecolor, "000")) }); for (D = h.length; D--; ) if (s = h[D]) for (s.threshold = m.min, ka = (s = s.data) && s.length || 0; ka--; ) T = s[ka], T.y = L(T.y, u); delete n.max; delete n.min;
    n.isLog = !0; m.reversed && 0 <= m.min && (d.plotOptions.series.threshold = m.max); f.trendlines && b(f.trendlines, [{ max: z.Max, min: z.Min, plotLines: m.plotLines, plotBands: m.plotBands}], q); for (D = m.plotLines.length; D--; ) T = m.plotLines[D], T.value && (T.value = L(T.value, u)), T.from && (T.from = L(T.from, u)), T.to && (T.to = L(T.to, u)); for (D = m.plotBands.length; D--; ) T = m.plotBands[D], T.from && (T.from = L(T.from, u)), T.to && (T.to = L(T.to, u)); for (D = z.divArr.length; D--; ) {
        T = z.divArr[D]; if (T.ismajor) C[1] = L(T.value, u), C[2] = e.yAxis(T.value), r.addAxisGridLine.apply(r,
C); else if (ia || T.isextreme) pa[1] = L(T.value, u), pa[2] = B || T.isextreme ? e.yAxis(T.value) : l, r.addAxisGridLine.apply(r, pa); s = m.plotLines[m.plotLines.length - 1]; T.isextreme ? (s.width = 0.1, U && (s.label.text = l)) : w && s.label && (s.label.text = l)
    } 
}, getLogAxisLimits: function (a, b, c, d, e, f) {
    var g = function (a) { return null === a || void 0 === a || "" === a || isNaN(a) ? !1 : !0 }, q = 0, r = [], h, k, l, D, m, n, L, s; g(c) && Number(c) >= a ? a = Number(c) : (c = 1 < e ? xa(S(a) / S(e)) : ua(S(a) / S(e)), a = ca(e, c), k = c); k || (k = 1 < e ? xa(S(a) / S(e)) : ua(S(a) / S(e))); g(d) && Number(d) <=
b ? b = Number(d) : (c = 1 < e ? ua(S(b) / S(e)) : xa(S(b) / S(e)), b = ca(e, c), h = c); h || (h = 1 < e ? ua(S(b) / S(e)) : xa(S(b) / S(e))); d = Number(String(S(e) / S(10))); f = Number(f) || (ua(d) == d ? 8 : 4); 1 < e ? (l = k, D = h) : 0 < e && 1 > e && (l = h, D = k); d = k; for (h = l; h >= D; --h) if (l = ca(e, d), b <= l && a >= l && (r[q++] = { value: l, ismajor: !0 }), h != D) { k = 1 < e ? -1 : 1; l = ca(e, d) - ca(e, d + k); c = l / (f + 1); for (g = 1; g <= f; ++g) l = ca(e, d + k) + c * g, b <= l && a >= l && (r[q++] = { value: l, ismajor: !1 }); 1 < e ? d-- : d++ } for (L in r) for (s in r[L]) "value" == s && (m || (m = r[L][s] == b && (r[L].isextreme = !0)), n || (n = r[L][s] == a && (r[L].isextreme =
!0))); m || (r[q++] = { value: b, ismajor: !0, isextreme: !0 }); n || (r[q] = { value: a, ismajor: !0, isextreme: !0 }); return { Max: a, Min: b, divArr: r}
}, pointValueWatcher: function (b, c, d) { b = b[g]; d = a(d, 0); 0 < c && (b[d] || (b[d] = {}), d = b[d], d.max = d.max > c ? d.max : c, d.min = d.min < c ? d.min : c) } 
}, X.mslinebase); Ba = X.singleseries; W = X.multiseries; X("column2dbase", { point: function (b, d, q, r, e) {
    var h = q.length, D = e[g], m = D.axisGridManager, n = e.xAxis, D = D.x, L = this.colorManager, s = /3d$/.test(e.chart.defaultSeriesType), U = this.isBar, u = /^spark/i.test(b); b = c(r.showplotborder,
u || s ? qa : Ya) === Ya ? s ? 1 : a(r.plotborderthickness, 1) : 0; var w = e.chart.useRoundEdges, z = a(r.plotborderalpha, r.plotfillalpha, 100), T = c(r.plotbordercolor, L.getColor("plotBorderColor")).split(fa)[0], u = u ? "" : a(r.useplotgradientcolor, 1) ? N(r.plotgradientcolor, L.getColor("plotGradientColor")) : l, C = 0, pa = Boolean(a(r.use3dlighting, 1)), ia = e[g].numberFormatter, ka, E = a(r.plotborderdashed, 0), I = a(r.plotborderdashlen, 5), G = a(r.plotborderdashgap, 4), ra, J, va, H, P, K, M, Ka, na, Sa, Da, Ua, ta, ya; for (va = 0; va < h; va += 1) ta = q[va], ta.vline ? m.addVline(n,
ta, C, e) : (J = ia.getCleanValue(ta.value), ka = a(ta.showlabel, r.showlabels, 1), H = t(B(ta.label, ta.name)), m.addXaxisCat(n, C, C, ka ? H : l), C += 1, ra = c(ta.color, L.getPlotColor()), P = c(ta.alpha, r.plotfillalpha, Fa), K = c(ta.ratio, r.plotfillratio), M = c(360 - r.plotfillangle, U ? 180 : 90), Ka = c(ta.alpha, z), na = a(ta.dashed, E), Sa = c(ta.dashgap, G), Da = c(ta.dashlen, I), 0 > J && (M = U ? 180 - M : 360 - M), ya = { opacity: P / 100 }, Ua = ha(ra + fa + u.replace(/,+?$/, ""), P, K, M, w, T, Ka + l, U, s), ka = na ? f(Da, Sa, b) : "none", ra = this.pointHoverOptions(ta, d, { plotType: "column",
    is3d: s, isBar: U, use3DLighting: pa, isRoundEdged: w, color: ra, gradientColor: u, alpha: P, ratio: K, angle: M, borderWidth: b, borderColor: T, borderAlpha: Ka, borderDashed: na, borderDashGap: Sa, borderDashLen: Da, shadow: ya
}), d.data.push(k(this.getPointStub(ta, J, H, e), { y: J, shadow: ya, color: Ua[0], borderColor: Ua[1], borderWidth: b, use3DLighting: pa, dashStyle: ka, tooltipConstraint: this.tooltipConstraint, hoverEffects: ra.enabled && ra.options, rolloverProperties: ra.enabled && ra.rolloverOptions })), this.pointValueWatcher(e, J)); D.catCount =
C; return d
}, defaultSeriesType: "column"
}, Ba); X("linebase", { defaultSeriesType: "line", hasVDivLine: !0, defaultPlotShadow: 1, point: function (b, d, q, r, e) {
    var h, D, m, n, L, s, U, u, z, T, C, pa, ia, ka, E, I, ra, G, J, va, H, P, M, K, N, Ka; b = e.chart; var na = q.length, Sa = e.xAxis; h = e[g]; var ta = this.colorManager, Da, Ua = h.axisGridManager, ya = 0, ib = h.x, V = e[g].numberFormatter, kb, Va, cb; ka = w(c(r.linecolor, r.palettecolors, ta.getColor("plotFillColor"))); E = c(r.linealpha, Fa); C = a(r.linethickness, this.lineThickness, 4); pa = Boolean(a(r.linedashed, 0));
    U = a(r.linedashlen, 5); u = a(r.linedashgap, 4); N = a(r.anchorshadow, 0); d.color = { FCcolor: { color: ka, alpha: E} }; d.lineWidth = C; d.anchorShadow = N; d.step = c(this.stepLine, d.step); d.drawVerticalJoins = Boolean(a(d.drawVerticalJoins, r.drawverticaljoins, 1)); d.useForwardSteps = Boolean(a(d.useForwardSteps, r.useforwardsteps, 1)); ia = a(r.drawanchors, r.showanchors); for (D = 0; D < na; D += 1) n = q[D], n.vline ? Ua.addVline(Sa, n, ya, e) : (h = V.getCleanValue(n.value), L = a(n.showlabel, r.showlabels, 1), m = t(B(n.label, n.name)), Ua.addXaxisCat(Sa, ya, ya,
L ? m : l), ya += 1, z = w(c(n.color, ka)), T = a(n.alpha, E), L = a(n.dashed, pa) ? f(U, u, C) : "none", s = { opacity: T / 100 }, ra = a(n.anchorsides, r.anchorsides, 0), K = a(n.anchorstartangle, r.anchorstartangle, 90), va = a(n.anchorradius, r.anchorradius, this.anchorRadius, 3), J = w(c(n.anchorbordercolor, r.anchorbordercolor, ka)), G = a(n.anchorborderthickness, r.anchorborderthickness, this.anchorBorderThickness, 1), H = w(c(n.anchorbgcolor, r.anchorbgcolor, ta.getColor("anchorBgColor"))), P = c(n.anchoralpha, r.anchoralpha, Fa), M = c(n.anchorbgalpha, r.anchorbgalpha,
P), kb = c(n.anchorimageurl, r.anchorimageurl), Va = c(n.anchorimagescale, r.anchorimagescale, 100), cb = c(n.anchorimagealpha, r.anchorimagealpha, 100), I = void 0 === ia ? 0 !== T : !!ia, Ka = Boolean(a(n.anchorshadow, N, 0)), Da = this.pointHoverOptions(n, d, { plotType: "anchor", anchorBgColor: H, anchorAlpha: P, anchorBgAlpha: M, anchorAngle: K, anchorBorderThickness: G, anchorBorderColor: J, anchorBorderAlpha: P, anchorSides: ra, anchorRadius: va, imageUrl: kb, imageScale: Va, imageAlpha: cb, shadow: s }), d.data.push(k(this.getPointStub(n, h, m, e), { y: h, color: { FCcolor: { color: z,
    alpha: T
}
}, shadow: s, dashStyle: L, valuePosition: c(n.valueposition, b.valuePosition), marker: { enabled: !!I, shadow: Ka && { opacity: P / 100 }, fillColor: { FCcolor: { color: H, alpha: M * P / 100 + l} }, lineColor: { FCcolor: { color: J, alpha: P} }, lineWidth: G, radius: va, startAngle: K, symbol: ma(ra), imageUrl: kb, imageScale: Va, imageAlpha: cb }, tooltipConstraint: this.tooltipConstraint, hoverEffects: Da.enabled && Da.options, rolloverProperties: Da.enabled && Da.rolloverOptions
})), this.pointValueWatcher(e, h)); ib.catCount = ya; return d
}, defaultZeroPlaneHighlighted: !1
},
Ba); X("area2dbase", { defaultSeriesType: "area", hasVDivLine: !0, point: function (b, d, q, r, e) {
    b = e.chart; var h = q.length, D = e.xAxis, m = e[g], n = m.axisGridManager, m = m.x, L = e[g].numberFormatter, s = this.colorManager, U = 0, u, T, z, C, pa, ia, ka, E, I, ra, G, va, H, P, M, K, Ka, na, Sa, Da, ta, Ua, ya, ib, V, kb, Va, cb; pa = c(r.plotfillcolor, r.areabgcolor, J(r.palettecolors) ? s.getPlotColor(0) : s.getColor("plotFillColor")).split(fa)[0]; ta = fa + (a(r.useplotgradientcolor, 1) ? N(r.plotgradientcolor, s.getColor("plotGradientColor")) : l); ia = c(r.plotfillalpha,
r.areaalpha, this.isStacked ? Fa : "90"); ka = a(r.plotfillangle, 270); E = c(r.plotbordercolor, r.areabordercolor, J(r.palettecolors) ? s.getPlotColor(0) : s.getColor("plotBorderColor")).split(fa)[0]; I = r.showplotborder == qa ? qa : c(r.plotborderalpha, r.plotfillalpha, r.areaalpha, Fa); u = a(r.plotborderangle, 270); T = Boolean(a(r.plotborderdashed, 0)); z = a(r.plotborderdashlen, 5); H = a(r.plotborderdashgap, 4); Ka = a(r.plotborderthickness, r.areaborderthickness, 1); Ua = d.fillColor = { FCcolor: { color: pa + ta.replace(/,+?$/, ""), alpha: ia, ratio: bb,
    angle: ka
}
}; d.lineWidth = Ka; d.dashStyle = T ? f(z, H, Ka) : "none"; d.lineColor = { FCcolor: { color: E, alpha: I, ratio: Fa, angle: u} }; d.step = c(this.stepLine, d.step); d.drawVerticalJoins = Boolean(a(d.drawVerticalJoins, r.drawverticaljoins, 1)); d.useForwardSteps = Boolean(a(d.useForwardSteps, r.useforwardsteps, 1)); Ka = Boolean(a(r.drawanchors, r.showanchors, 1)); d.anchorShadow = ya = a(r.anchorshadow, 0); for (T = 0; T < h; T += 1) H = q[T], H.vline ? n.addVline(D, H, U, e) : (u = L.getCleanValue(H.value), C = a(H.showlabel, r.showlabels, 1), z = t(B(H.label, H.name)),
n.addXaxisCat(D, U, U, C ? z : l), U += 1, C = a(H.anchorsides, r.anchorsides, 0), va = a(H.anchorstartangle, r.anchorstartangle, 90), ra = a(H.anchorradius, r.anchorradius, 3), G = w(c(H.anchorbordercolor, r.anchorbordercolor, E)), na = a(H.anchorborderthickness, r.anchorborderthickness, 1), P = w(c(H.anchorbgcolor, r.anchorbgcolor, s.getColor("anchorBgColor"))), M = c(H.anchoralpha, r.anchoralpha, this.anchorAlpha, qa), K = c(H.anchorbgalpha, r.anchorbgalpha, M), ib = Boolean(a(H.anchorshadow, ya, 0)), Sa = J(H.color), Da = a(H.alpha), Sa = void 0 !== Sa || void 0 !==
Da ? { FCcolor: { color: Sa ? w(Sa) + ta : pa, alpha: void 0 === Da ? aa(Da) + l : ia, ratio: bb, angle: ka}} : Ua, V = c(H.anchorimageurl, r.anchorimageurl), kb = c(H.anchorimagescale, r.anchorimagescale, 100), Va = c(H.anchorimagealpha, r.anchorimagealpha, 100), Da = { opacity: ba(Da, I) / 100, inverted: !0 }, cb = this.pointHoverOptions(H, d, { plotType: "anchor", anchorBgColor: P, anchorAlpha: M, anchorBgAlpha: K, anchorAngle: va, anchorBorderThickness: na, anchorBorderColor: G, anchorBorderAlpha: M, anchorSides: C, anchorRadius: ra, imageUrl: V, imageScale: kb, imageAlpha: Va,
    shadow: Da
}), d.data.push(k(this.getPointStub(H, u, z, e), { y: u, shadow: Da, color: Sa, valuePosition: c(H.valueposition, b.valuePosition), marker: { enabled: Ka, shadow: ib && { opacity: M / 100 }, fillColor: { FCcolor: { color: P, alpha: K * M / 100 + l} }, lineColor: { FCcolor: { color: G, alpha: M} }, lineWidth: na, radius: ra, symbol: ma(C), startAngle: va, imageUrl: V, imageScale: kb, imageAlpha: Va }, tooltipConstraint: this.tooltipConstraint, previousY: this.pointValueWatcher(e, u), hoverEffects: cb.enabled && cb.options, rolloverProperties: cb.enabled && cb.rolloverOptions })));
    m.catCount = U; return d
} 
}, Ba); X("mscolumn2dbase", { point: function (b, d, f, q, e, r, h, k, D) {
    b = a(q.ignoreemptydatasets, 0); var m = !1, n = f.data || [], L = e[g], s = c(d.type, this.defaultSeriesType), t = c(d.isStacked, e.plotOptions[s] && e.plotOptions[s].stacking), U = c(this.isValueAbs, L.isValueAbs, !1), u = a(d.yAxis, 0), w = e[g].numberFormatter, T = this.colorManager, z = T.getPlotColor(), C, B = e._FCconf.isBar, pa = d.hoverEffects; t || (d.columnPosition = a(D, k, h)); d.name = J(f.seriesname); if (0 === a(f.includeinlegend) || void 0 === d.name) d.showInLegend =
!1; d.color = c(f.color, z).split(fa)[0].replace(/^#?/g, "#"); h = /3d$/.test(e.chart.defaultSeriesType); D = c(360 - q.plotfillangle, B ? 180 : 90); 0 > C && (D = 360 - D); f = d._dataParser = Za.column(e, { seriesname: d.name, plottooltext: f.plottooltext, color: c(f.color, z), alpha: c(f.alpha, q.plotfillalpha, Fa), plotgradientcolor: a(q.useplotgradientcolor, 1) ? N(q.plotgradientcolor, T.getColor("plotGradientColor")) : l, ratio: c(f.ratio, q.plotfillratio), fillAangle: D, isRoundEdges: e.chart.useRoundEdges, plotBorderColor: c(q.plotbordercolor, h ? hb :
T.getColor("plotBorderColor")).split(fa)[0], plotBorderAlpha: q.showplotborder == qa || h && q.showplotborder != Ya ? qa : c(q.plotborderalpha, Fa), isBar: this.isBar, is3d: h, dashed: a(f.dashed, q.plotborderdashed, 0), dashLen: a(f.dashlen, q.plotborderdashlen, 5), dashGap: a(f.dashgap, q.plotborderdashgap, 4), borderWidth: a(q.plotborderthickness, Ya), showValues: a(f.showvalues, L.showValues), yAxis: u, use3DLighting: a(q.use3dlighting, 1), _sourceDataset: f, hoverEffects: pa
}, this); for (q = 0; q < r; q += 1) (L = n[q]) ? (C = w.getCleanValue(L.value, U),
null === C ? d.data.push({ y: null }) : (m = !0, L = f(L, q, C), d.data.push(L), L.previousY = this.pointValueWatcher(e, C, u, t, q, k, s))) : d.data.push({ y: null }); !b || m || this.realtimeEnabled || (d.showInLegend = !1); return d
}, defaultSeriesType: "column"
}, W); X("mslinebase", { hasVDivLine: !0, point: function (b, d, f, q, e, r) {
    b = a(q.ignoreemptydatasets, 0); var h = !1, k = this.colorManager, D, m; D = e.chart; var n = f.data || []; m = e[g]; var L = c(d.type, this.defaultSeriesType), s = c(d.isStacked, e.plotOptions[L] && e.plotOptions[L].stacking), t = c(this.isValueAbs,
m.isValueAbs, !1), U = a(d.yAxis, 0), u = this.numberFormatter, T = w(c(f.color, q.linecolor, k.getPlotColor())), z = a(f.alpha, q.linealpha, Fa), C = a(q.showshadow, this.defaultPlotShadow, 1), B = a(f.drawanchors, f.showanchors, q.drawanchors, q.showanchors), pa = a(f.anchorsides, q.anchorsides, 0), ia = a(f.anchorstartangle, q.anchorstartangle, 90), ka = a(f.anchorradius, q.anchorradius, 3), E = w(c(f.anchorbordercolor, q.anchorbordercolor, T)), I = a(f.anchorborderthickness, q.anchorborderthickness, 1), k = w(c(f.anchorbgcolor, q.anchorbgcolor, k.getColor("anchorBgColor"))),
ra = c(f.anchoralpha, q.anchoralpha, Fa), G = c(f.anchorbgalpha, q.anchorbgalpha, ra), H = ra && c(f.anchorshadow, q.anchorshadow, 0), va = d.hoverEffects; d.name = J(f.seriesname); if (0 === a(f.includeinlegend) || void 0 === d.name || 0 === z && 1 !== B) d.showInLegend = !1; d.marker = { fillColor: { FCcolor: { color: k, alpha: G * ra / 100 + l} }, lineColor: { FCcolor: { color: E, alpha: ra + l} }, lineWidth: I, radius: ka, symbol: ma(pa), startAngle: ia }; d.color = { FCcolor: { color: T, alpha: z} }; d.shadow = C ? { opacity: C ? z / 100 : 0} : !1; d.anchorShadow = H; d.step = c(this.stepLine, d.step);
    d.drawVerticalJoins = Boolean(a(d.drawVerticalJoins, q.drawverticaljoins, 1)); d.useForwardSteps = Boolean(a(d.useForwardSteps, q.useforwardsteps, 1)); d.lineWidth = a(f.linethickness, q.linethickness, 2); D = d._dataParser = Za.line(e, { seriesname: d.name, plottooltext: f.plottooltext, lineAlpha: z, anchorAlpha: ra, showValues: a(f.showvalues, m.showValues), yAxis: U, lineDashed: Boolean(a(f.dashed, q.linedashed, 0)), lineDashLen: a(f.linedashlen, q.linedashlen, 5), lineDashGap: a(f.linedashgap, q.linedashgap, 4), lineThickness: d.lineWidth,
        lineColor: T, valuePosition: c(f.valueposition, D.valuePosition), drawAnchors: B, anchorBgColor: k, anchorBgAlpha: G, anchorBorderColor: E, anchorBorderThickness: I, anchorRadius: ka, anchorSides: pa, anchorAngle: ia, anchorShadow: d.anchorShadow, anchorStartAngle: a(f.anchorstartangle, q.anchorstartangle), _sourceDataset: f, hoverEffects: va, imageUrl: c(f.anchorimageurl, q.anchorimageurl), imageScale: c(f.anchorimagescale, q.anchorimagescale, 100), imageAlpha: c(f.anchorimagealpha, q.anchorimagealpha, 100)
    }, this); for (q = 0; q < r; q += 1) (m =
n[q]) ? (f = u.getCleanValue(m.value, t), null === f ? d.data.push({ y: null }) : (h = !0, m = D(m, q, f), d.data.push(m), m.previousY = this.pointValueWatcher(e, f, U, s, q, 0, L))) : d.data.push({ y: null }); !b || h || this.realtimeEnabled || (d.showInLegend = !1); return d
}, defaultSeriesType: "line", defaultPlotShadow: 1, defaultZeroPlaneHighlighted: !1
}, W); X("msareabase", { hasVDivLine: !0, point: function (b, d, q, r, e, h) {
    b = a(r.ignoreemptydatasets, 0); var k = !1, D = e.chart, m = q.data || [], n = e[g], L = c(d.type, this.defaultSeriesType), s = c(d.isStacked, e.plotOptions[L] &&
e.plotOptions[L].stacking), t = c(this.isValueAbs, n.isValueAbs, !1), U = a(d.yAxis, 0), u = e[g].numberFormatter, T = this.colorManager, z = T.getPlotColor(), C = c(q.color, r.plotfillcolor, z).split(fa)[0].replace(/^#?/g, "#").split(fa)[0], B = c(q.alpha, r.plotfillalpha, r.areaalpha, this.areaAlpha, 70), pa = a(r.plotfillangle, 270), z = c(q.plotbordercolor, r.plotbordercolor, r.areabordercolor, this.isRadar ? z : "666666").split(fa)[0], ia = c(q.showplotborder, r.showplotborder) == qa ? qa : c(q.plotborderalpha, r.plotborderalpha, q.alpha, r.plotfillalpha,
r.areaalpha, "95"), ka = a(r.plotborderangle, 270), E = a(q.anchorsides, r.anchorsides, 0), ra = a(q.anchorstartangle, r.anchorstartangle, 90), I = a(q.anchorradius, r.anchorradius, 3), G = w(c(q.anchorbordercolor, r.anchorbordercolor, C)), H = a(q.anchorborderthickness, r.anchorborderthickness, 1), va = w(c(q.anchorbgcolor, r.anchorbgcolor, T.getColor("anchorBgColor"))), J = a(q.anchoralpha, r.anchoralpha, this.anchorAlpha, 0), P = a(q.anchorbgalpha, r.anchorbgalpha, J), M = J && c(q.anchorshadow, r.anchorshadow, 0), K = d.hoverEffects; this.isRadar ||
(C += fa + (a(r.useplotgradientcolor, 1) ? N(r.plotgradientcolor, T.getColor("plotGradientColor")) : l), C = C.replace(/,+?$/, "")); d.step = c(this.stepLine, d.step); d.drawVerticalJoins = Boolean(a(d.drawVerticalJoins, r.drawverticaljoins, 1)); d.useForwardSteps = Boolean(a(d.useForwardSteps, r.useforwardsteps, 1)); d.name = c(q.seriesname); if (0 === a(q.includeinlegend) || void 0 === d.name) d.showInLegend = !1; d.fillColor = { FCcolor: { color: C, alpha: B, ratio: bb, angle: pa} }; d.color = C; d.shadow = { opacity: a(r.showshadow, 1) ? ia / 100 : 0 }; d.anchorShadow =
M; d.lineColor = { FCcolor: { color: z, alpha: ia, ratio: Fa, angle: ka} }; d.lineWidth = c(q.plotborderthickness, r.plotborderthickness, 1); d.dashStyle = Boolean(a(q.dashed, r.plotborderdashed, 0)) ? f(a(q.dashlen, r.plotborderdashlen, 5), a(q.dashgap, r.plotborderdashgap, 4), d.lineWidth) : void 0; d.marker = { fillColor: { FCcolor: { color: va, alpha: P * J / 100 + l} }, lineColor: { FCcolor: { color: G, alpha: J + l} }, lineWidth: H, radius: I, symbol: ma(E), startAngle: ra }; q = d._dataParser = Za.area(e, { seriesname: d.name, plottooltext: q.plottooltext, lineAlpha: ia, anchorAlpha: J,
    showValues: a(q.showvalues, n.showValues), yAxis: U, fillColor: C, fillAlpha: B, valuePosition: c(q.valueposition, D.valuePosition), drawAnchors: Boolean(a(r.drawanchors, r.showanchors, 1)), anchorBgColor: va, anchorBgAlpha: P, anchorBorderColor: G, anchorBorderThickness: H, anchorRadius: I, anchorSides: E, anchorAngle: ra, anchorShadow: d.anchorShadow, getLink: this.linkClickFN, anchorStartAngle: a(q.anchorstartangle, r.anchorstartangle), _sourceDataset: q, hoverEffects: K, imageUrl: c(q.anchorimageurl, r.anchorimageurl), imageScale: c(q.anchorimagescale,
r.anchorimagescale, 100), imageAlpha: c(q.anchorimagealpha, r.anchorimagealpha, 100)
}, this); for (D = 0; D < h; D += 1) (n = m[D]) ? (r = n ? u.getCleanValue(n.value, t) : null, null === r ? d.data.push({ y: null }) : (k = !0, n = q(n, D, r), d.data.push(n), n.previousY = this.pointValueWatcher(e, r, U, s, D, 0, L))) : d.data.push({ y: null }); !b || k || this.realtimeEnabled || (d.showInLegend = !1); return d
}, defaultSeriesType: "area", defaultPlotShadow: 0
}, W); X("scatterbase", { showValues: 0, defaultPlotShadow: 0, rendererId: "cartesian", defaultSeriesType: "scatter", canvasPaddingModifiers: ["anchorlabel"],
    point: function (b, d, q, r, e, h, k) {
        b = a(r.ignoreemptydatasets, 0); var D = this.colorManager, m = D.getPlotColor(), n, L, s, t, U, u, T, z, C, B, pa, ia, ka, E, ra, I, H, va, P; h = !1; var M, K; U = a(q.drawline, r.drawlines, 0); u = a(q.drawprogressioncurve, 0); t = q.data || []; var Ka, N, Sa, na, Da, ta = a(q.showvalues, e[g].showValues), Ua = this.numberFormatter, ya, ib = d._showRegression = a(q.showregressionline, r.showregressionline, 0); d.zIndex = 1; d.name = J(q.seriesname); if (0 === a(q.includeinlegend) || void 0 === d.name) d.showInLegend = !1; if (U || u) s = w(c(q.color, m)),
t = c(q.alpha, Fa), U = a(q.linethickness, r.linethickness, 2), u = Boolean(a(q.linedashed, q.dashed, r.linedashed, 0)), T = a(q.linedashlen, r.linedashlen, 5), z = a(q.linedashgap, r.linedashgap, 4), d.color = G(c(q.linecolor, r.linecolor, s), a(q.linealpha, r.linealpha, t)), d.lineWidth = U, d.dashStyle = u ? f(T, z, U) : "none"; U = Boolean(a(q.drawanchors, q.showanchors, r.drawanchors, r.showanchors, 1)); k = a(q.anchorsides, r.anchorsides, k + 3); u = a(q.anchorradius, r.anchorradius, 3); s = w(c(q.anchorbordercolor, q.color, r.anchorbordercolor, s, m)); m = a(q.anchorborderthickness,
r.anchorborderthickness, 1); T = w(c(q.anchorbgcolor, r.anchorbgcolor, D.getColor("anchorBgColor"))); z = c(q.anchoralpha, q.alpha, r.anchoralpha, Fa); pa = c(q.anchorbgalpha, q.alpha, r.anchorbgalpha, z); M = c(q.anchorstartangle, r.anchorstartangle, 90); d.anchorShadow = D = a(r.anchorshadow, 0); d.marker = { fillColor: this.getPointColor(T, Fa), lineColor: { FCcolor: { color: s, alpha: z + l} }, lineWidth: m, radius: u, symbol: ma(k) }; t = q.data || []; Da = t.length; ib && (d.events = { hide: this.hideRLine, show: this.showRLine }, Ka = { sumX: 0, sumY: 0, sumXY: 0, sumXsqure: 0,
    sumYsqure: 0, xValues: [], yValues: []
}, na = a(q.showyonx, r.showyonx, 1), N = w(c(q.regressionlinecolor, r.regressionlinecolor, s)), Sa = a(q.regressionlinethickness, r.regressionlinethickness, m), n = aa(a(q.regressionlinealpha, r.regressionlinealpha, z)), N = G(N, n)); for (L = 0; L < Da; L += 1) (C = t[L]) ? (n = Ua.getCleanValue(C.y), P = Ua.getCleanValue(C.x), null === n ? d.data.push({ y: null, x: P }) : (h = !0, K = this.getPointStub(C, n, Ua.xAxis(P), e, q, ta), ia = a(C.anchorsides, k), ka = a(C.anchorradius, u), E = w(c(C.anchorbordercolor, s)), ra = a(C.anchorborderthickness,
m), I = w(c(C.anchorbgcolor, T)), H = c(C.anchoralpha, C.alpha, z), va = c(C.anchorbgalpha, pa), B = Boolean(a(C.anchorshadow, D, 0)), ya = this.pointHoverOptions(C, d, { plotType: "anchor", anchorBgColor: I, anchorAlpha: H, anchorBgAlpha: va, anchorAngle: M, anchorBorderThickness: ra, anchorBorderColor: E, anchorBorderAlpha: H, anchorSides: ia, anchorRadius: ka, shadow: void 0 }), d.data.push({ y: n, x: P, displayValue: K.displayValue, toolText: K.toolText, link: K.link, marker: { enabled: U, shadow: B && { opacity: H / 100 }, fillColor: { FCcolor: { color: I, alpha: va * H /
100 + l
}
}, lineColor: { FCcolor: { color: E, alpha: H} }, lineWidth: ra, radius: ka, symbol: ma(ia), startAngle: c(C.anchorstartangle, q.anchorstartangle, r.anchorstartangle, 90)
}, hoverEffects: ya.enabled && ya.options, rolloverProperties: ya.enabled && ya.rolloverOptions
}), this.pointValueWatcher(e, n, P, ib && Ka))) : d.data.push({ y: null }); ib && (q = this.getRegressionLineSeries(Ka, na, Da), this.pointValueWatcher(e, q[0].y, q[0].x), this.pointValueWatcher(e, q[1].y, q[1].x), e = { type: "line", color: N, showInLegend: !1, lineWidth: Sa, enableMouseTracking: !1,
    marker: { enabled: !1 }, data: q, zIndex: 0
}, d = [d, e]); b && !h && (d.showInLegend = !1); return d
    }, postSeriesAddition: function (b, c) { for (var d = b.chart, f = c.chart, e = b.series, q = 0, g = e.length; q < g; q += 1) e[q]._showRegression && (e[q].relatedSeries = [q + 1]); d.clipBubbles = a(f.clipbubbles, 1) }, categoryAdder: function (b, d) {
        var q, r = 0, e, h = d[g].x, k, D = d.xAxis, m, n; n = b.chart; var L = parseInt(n.labelstep, 10), s = a(n.showlabels, 1), U = c(n.xaxislabelmode, "categories").toLowerCase(), u = this.colorManager, w = d[g].numberFormatter, T, z, C, pa, ia, ka; d._FCconf.isXYPlot =
!0; L = 1 < L ? L : 1; h.catOccupied = {}; if ("auto" !== U && b.categories && b.categories[0] && b.categories[0].category) {
            n = b.categories[0]; n.font && (d.xAxis.labels.style.fontFamily = n.font); void 0 !== (e = a(n.fontsize)) && (1 > e && (e = 1), d.xAxis.labels.style.fontSize = e + Pa, Q(d.xAxis.labels.style)); n.fontcolor && (d.xAxis.labels.style.color = n.fontcolor.split(fa)[0].replace(/^\#?/, "#")); q = c(n.verticallinecolor, u.getColor("divLineColor")); e = a(n.verticallinethickness, 1); k = a(n.verticallinealpha, u.getColor("divLineAlpha")); u = a(n.verticallinedashed,
0); T = a(n.verticallinedashlen, 4); z = a(n.verticallinedashgap, 2); C = G(q, k); for (q = 0; q < n.category.length; q += 1) m = n.category[q], k = w.getCleanValue(m.x), null === k || m.vline || (h.catOccupied[k] = !0, ka = a(m.showlabel, m.showname, s), pa = a(m.showverticalline, m.showline, m.sl, 0), ia = a(m.linedashed, u), m = 0 === ka || 0 !== r % L ? l : t(B(m.label, m.name)), D.plotLines.push({ isGrid: !0, isCat: !0, width: pa ? e : 0, color: C, dashStyle: f(T, z, e, ia), value: k, label: { text: m, style: D.labels.style, align: Xa, verticalAlign: Aa, textAlign: Xa, rotation: 0, x: 0, y: 0} }),
this.pointValueWatcher(d, null, k), r += 1); "mixed" === U && (h.requiredAutoNumericLabels = a(this.requiredAutoNumericLabels, 1))
        } else h.requiredAutoNumericLabels = a(this.requiredAutoNumericLabels, 1); h.adjustMinMax = !0
    }, getPointColor: function (a, b) { var c, d; a = w(a); b = aa(b); c = I(a, 70); d = ja(a, 50); return { FCcolor: { gradientUnits: "objectBoundingBox", cx: 0.4, cy: 0.4, r: "100%", color: c + fa + d, alpha: b + fa + b, ratio: bb, radialGradient: !0}} } 
}, X.xybase); X("mscombibase", { canvasPaddingModifiers: ["anchor", "anchorlabel"], series: function (d,
f, q) {
    var r, e, h, k, l = d.chart, D, n = [], m = [], L = [], s, t, U = f[g], u = this.isDual, w = 0, T; f.legend.enabled = Boolean(a(d.chart.showlegend, 1)); if (d.dataset && 0 < d.dataset.length) {
        this.categoryAdder(d, f); k = U.oriCatTmp.length; r = 0; for (e = d.dataset.length; r < e; r += 1) switch (h = d.dataset[r], s = u && "s" === c(h.parentyaxis, "p").toLowerCase() ? !0 : !1, D = { hoverEffects: this.parseSeriesHoverOptions(d, f, h, q), visible: !a(h.initiallyhidden, 0), legendIndex: r, data: [] }, s ? (D.yAxis = 1, t = B(h.renderas, this.secondarySeriesType), this.secondarySeriesFilter &&
(T = this.secondarySeriesFilter[t])) : (t = B(h.renderas, this.defaultSeriesType), this.defaultSeriesFilter && (T = this.defaultSeriesFilter[t])), t = t.toLowerCase(), t) {
            case "line": case "spline": D.type = !0 === T ? t : "line"; n.push(X.mslinebase.point.call(this, q, D, h, l, f, k, r)); break; case "area": case "splinearea": D.type = !0 === T ? t : "area"; f.chart.series2D3Dshift = !0; L.push(X.msareabase.point.call(this, q, D, h, l, f, k, r)); break; case "column": case "column3d": m.push(X.mscolumn2dbase.point.call(this, q, D, d.dataset[r], l, f, k, r, void 0,
w)); w += 1; break; default: s ? (D.type = "line", n.push(X.mslinebase.point.call(this, q, D, h, l, f, k, r))) : (m.push(X.mscolumn2dbase.point.call(this, q, D, d.dataset[r], l, f, k, r, void 0, w)), w += 1)
        } "0" !== l.areaovercolumns ? (f.chart.areaOverColumns = !0, f.series = f.series.concat(m, L, n)) : (f.chart.areaOverColumns = !1, f.series = f.series.concat(L, m, n)); if (0 === m.length) U.hasNoColumn = !0; else if (!this.isStacked) for (q = 0, r = m.length; q < r; q += 1) m[q].numColumns = r; this.configureAxis(f, d); d.trendlines && b(d.trendlines, f.yAxis, f[g], u, this.isBar)
    } 
} 
},
X.mscolumn2dbase)
} ]);
FusionCharts.register("module", ["private", "modules.renderer.js-renderer", function () {
    function d(a, b, c, d) {
        var f = b.paper, g = b.layers, h = c ? "y-axis" : "x-axis", k = this.layerAboveDataset = g.layerAboveDataset, l = this.layerBelowDataset = g.layerBelowDataset, g = k.bands || (k.bands = []), m = g.length, n = l.bands || (l.bands = []), s = n.length, t = k.lines || (k.lines = []), u = t.length, w = l.lines || (l.lines = []), z = w.length, k = k.labels || (k.labels = []), C = k.length, l = l.labels || (l.labels = []), B = l.length; this.renderer = b; this.axisData = a || {}; this.globalOptions =
b.options; this.isVertical = c; this.topBandGroup = this.topBandGroup || f.group(h + "-bands", this.layerAboveDataset); this.belowBandGroup = this.belowBandGroup || f.group(h + "-bands", this.layerBelowDataset); g.push(this.topBandGroup); m && g[m].insertAfter(g[m - 1]); n.push(this.belowBandGroup); s && n[s].insertAfter(n[s - 1]); this.topLineGroup = this.topLineGroup || f.group(h + "-lines", this.layerAboveDataset); this.belowLineGroup = this.belowLineGroup || f.group(h + "-lines", this.layerBelowDataset); this.topLabelGroup = this.topLabelGroup ||
f.group(h + "-labels", this.layerAboveDataset); this.belowLabelGroup = this.belowLabelGroup || f.group(h + "-labels", this.layerBelowDataset); t.push(this.topLineGroup); u && t[u].insertAfter(t[u - 1]); w.push(this.belowLineGroup); z && w[z].insertAfter(w[z - 1]); k.push(this.topLabelGroup); C && k[C].insertAfter(k[C - 1]); l.push(this.belowLabelGroup); B && l[B].insertAfter(l[B - 1]); this.isReverse = d; this.configure()
    } function n(a, b, c, d) { return W(b - c[1] - d.top, a - c[0] - d.left) } function E(a, b) {
        var c = b ? 360 : yb; a = (a || 0) % c; return 0 > a ? c + a :
a
    } var u = this, l = u.window, b = u.hcLib, P = b.Raphael, c = b.chartAPI, J = /msie/i.test(l.navigator.userAgent) && !l.opera, a = l.document, B = l.Image, N = "VML" === P.type, t = b.BLANKSTRING, g = "rgba(192,192,192," + (J ? 0.002 : 1E-6) + ")", J = b.TOUCH_THRESHOLD_PIXELS, k = b.CLICK_THRESHOLD_PIXELS, f = b.stubFN, h = { pageX: 0, pageY: 0 }, s = parseFloat, sa = parseInt, m = b.extend2, z = b.addEvent, H = b.getMouseCoordinate, M = b.removeEvent, $ = b.pluck, C = b.pluckNumber, V = b.toRaphaelColor, ba = b.setImageDisplayMode, da = b.FC_CONFIG_STRING, xa = /\s\bx\b=['"][^'"]+?['"]/ig,
ua = /\s\by\b=['"][^'"]+?['"]/ig, S = b.plotEventHandler, ca = b.isArray, ha = b.each = function (a, b, c, d) { var f; c || (c = a); d || (d = {}); if (ca(a)) for (f = 0; f < a.length; f += 1) { if (!1 === b.call(c, a[f], f, a, d)) return f } else if (null !== a && void 0 !== a) for (f in a) if (!1 === b.call(c, a[f], f, a, d)) return f }, w = b.createElement, Q = b.createContextMenu, K = b.hasTouch, aa = K ? J : k, ja = b.getSentenceCase, I = b.getCrispValues, G = b.getValidValue, la = b.getFirstValue, Xa = b.regex.dropHash, ga = b.HASHSTRING, Aa = function (a) { return a !== za && null !== a }, za, Ga = 8 === a.documentMode ?
"visible" : "", X = l.Math, ma = X.sin, Ba = X.cos, W = X.atan2, fa = X.round, Ca = X.min, qa = X.max, Ya = X.abs, Fa = X.ceil, Pa = X.floor, Kb = 180 / X.PI, Na = X.PI, qb = Na / 2, yb = 2 * Na, bb = Na + qb, hb = b.getFirstColor, db = b.graphics.getLightColor, wb = b.POSITION_TOP, tb = b.POSITION_BOTTOM, mb = b.POSITION_RIGHT, Fb = b.POSITION_LEFT; P.ca.ishot = function (a) {
    if (this.removed) return !1; var b = this.node; a = a || ""; b.ishot = a; switch (this.type) {
        case "group": for (b = this.bottom; b; ) b.attr("ishot", a), b = b.next; break; case "text": if (P.svg) for (b = b.getElementsByTagName("tspan")[0]; b; ) b.ishot =
a, b = b.nextSibling
    } return !1
}; P.addSymbol({ printIcon: function (a, b, c) { var d = 0.75 * c, f = 0.5 * c, g = 0.33 * c, h = fa(a - c) + 0.5, k = fa(b - c) + 0.5, l = fa(a + c) + 0.5; c = fa(b + c) + 0.5; var m = fa(a - d) + 0.5, n = fa(b - d) + 0.5, d = fa(a + d) + 0.5, s = fa(b + f) + 0.5, t = fa(a + f) + 0.5, u = fa(b + g) + 0.5; a = fa(a - f) + 0.5; g = fa(b + g + g) + 0.5; return ["M", m, k, "L", d, k, d, n, m, n, "Z", "M", h, n, "L", h, s, m, s, m, b, d, b, d, s, l, s, l, n, "Z", "M", m, b, "L", m, c, d, c, d, b, "Z", "M", t, u, "L", a, u, "M", t, g, "L", a, g] }, exportIcon: function (a, b, c) {
    var d = 0.66 * c, f = 0.5 * d, g = fa(a - c) + 0.5, h = fa(b - c) + 0.5, k = fa(a + c) + 0.5;
    c = fa(b + c) - 0.5; var l = fa(a - f) + 0.5, m = b < c - 3 ? c - 3 : fa(b) + 0.5, f = fa(a + f) - 0.5, n = fa(a + d) - 0.5, d = fa(a - d) + 0.5; return ["M", g, m, "L", g, c, k, c, k, m, k, c, g, c, "Z", "M", a, c - 1, "L", d, b, l, b, l, h, f, h, f, b, n, b, "Z"]
} 
}); b.rendererRoot = c("renderer.root", { standaloneInit: !1, isRenderer: !0, inited: !1, callbacks: [], init: function (a, b, c) {
    var d = this, f = d.container = b.chart.renderTo, g = b.tooltip, h = d.layer, k, l; d.options = b; d.logic = a; d.definition = a.dataObj; d.smartLabel = a.smartLabel; d.numberFormatter = a.numberFormatter; d.fusionCharts = a.chartInstance;
    d.linkClickFN = a.linkClickFN; l = (k = b.chart) && k.animation && k.animation.duration; d.animationCompleteQueue = []; f.innerHTML = t; f = d.paper = d.fusionCharts.jsVars.paper = new P(f, f.offsetWidth || a.width, f.offsetHeight || a.height); !1 !== u.core.options._useSVGDescTag && f._desc && (k = a.friendlyName || "Vector image", d.definition && d.definition.chart && d.definition.chart.caption && (k += ' with caption "' + d.definition.chart.caption + '"'), f._desc(k)); d.chartWidth = f.width; d.chartHeight = f.height; d.elements || (d.elements = {}); h || (h = d.layers =
{}, h.background = h.background || f.group("background"), h.dataset = h.dataset || f.group("dataset").insertAfter(h.background), h.tracker = h.tracker || f.group("hot").insertAfter(h.dataset)); g && !1 !== g.enabled && (f.tooltip(g.style, g.shadow, g.constrain), h.tracker.trackTooltip(!0), h.dataset.trackTooltip(!0)); d.disposeChartStyleSheet(); d.setMargins(); d.drawBackground(); d.drawButtons(); d.drawGraph(); b.legend && b.legend.enabled && d.drawLegend(); d.drawCaption(); d.drawLogo(); d.setChartEvents(); d.drawLabels && d.drawLabels();
    ha(b.callbacks, function (a) { a.apply(d, this) }, [a]); ha(d.callbacks, function (a) { a.apply(d, this) }, [a]); d.fusionCharts.annotations && d.fusionCharts.annotations.draw(d); d.createChartStyleSheet(); d.options.nativeMessage || l || u.raiseEvent("internal.animationComplete", {}, d.fusionCharts); d.hasRendered = !0; c && c(d)
}, disposeChartStyleSheet: function () { this.paper.cssClear() }, createChartStyleSheet: function () { this.paper.cssRender() }, addCSSDefinition: function (a, b) {
    var c = this.paper; b.color && (b.fill = b.color); c.cssAddRule(a,
b)
}, animationCompleteQueue: [], animationComplete: function () { var a, b, c, d; this.animatedElements = this.animatedElements ? ++this.animatedElements : 1; if (this.animatedElements === this.animatingElementsCount) { c = this.animationCompleteQueue; a = 0; for (b = c.length; a < b; a++) d = c[a], d.fn && d.fn.call(d.scope); this.animationCompleteQueue = []; u.raiseEvent("internal.animationComplete", {}, this.fusionCharts) } }, getAnimationCompleteFn: function () {
    var a = this; a.animatingElementsCount = a.animatingElementsCount ? ++a.animatingElementsCount :
1; return function () { a.animationComplete() } 
}, reinit: function (a, b, c) { this.hasRendered || this.init(b, c) }, dispose: function () {
    var a = this.eventListeners, b = a && a.length; this.disposing = !0; if (b) for (; b--; ) a[b].unlisten(); if (this.toolbar && this.toolbar.length) { for (; this.toolbar.length; ) a = this.toolbar.pop(), a.remove(); this.toolbar.add = null } if (this.menus && this.menus.length) for (; this.menus.length; ) a = this.menus.pop(), a.destroy(); this.paper && (this.paper.clear(), this.paper.remove(), delete this.paper); this.exportIframe &&
(this.exportIframe.parentNode.removeChild(this.exportIframe), delete this.exportIframe); delete this.disposing; this.disposed = !0
}, onContainerClick: function (a) {
    var c = a.target || a.originalTarget || a.srcElement || a.relatedTarget || a.fromElement, d = a.data, f = d.fusionCharts; a = b.getMouseCoordinate(d.container, a.originalEvent); f.ref && (f = m({ height: f.args.height, width: f.args.width, pixelHeight: f.ref.offsetHeight, pixelWidth: f.ref.offsetWidth, id: f.args.id, renderer: f.args.renderer, container: f.options.containerElement },
a), u.raiseEvent("chartclick", f, d.logic.chartInstance), c && c.ishot && d || d.options.chart.link && d.linkClickFN.call(d, d))
}, onContainerMouseMove: function (a) { var c = a.data, d = c.fusionCharts; a = b.getMouseCoordinate(c.container, a.originalEvent); d.ref && (d = m({ height: d.args.height, width: d.args.width, pixelHeight: d.ref.offsetHeight, pixelWidth: d.ref.offsetWidth, id: d.args.id, renderer: d.args.renderer, container: d.options.containerElement }, a), u.raiseEvent("chartMouseMove", d, c.logic.chartInstance)) }, onContainerRollOver: function (a) {
    var c =
a.data, d = c.fusionCharts; a = b.getMouseCoordinate(c.container, a.originalEvent); d.ref && (d = m({ height: d.args.height, width: d.args.width, pixelHeight: d.ref.offsetHeight, pixelWidth: d.ref.offsetWidth, id: d.args.id, renderer: d.args.renderer, container: d.options.containerElement }, a), u.raiseEvent("chartRollOver", d, c.logic.chartInstance))
}, onContainerRollOut: function (a) {
    var c = a.chart, d = c.fusionCharts; a = b.getMouseCoordinate(c.container, a.event.originalEvent); d.ref && (d = m({ height: d.args.height, width: d.args.width, pixelHeight: d.ref.offsetHeight,
        pixelWidth: d.ref.offsetWidth, id: d.args.id, renderer: d.args.renderer, container: d.options.containerElement
    }, a), u.raiseEvent("chartRollOut", d, c.logic.chartInstance))
}, chartHoverManager: function () {
    var b = !1, c = function (c) {
        var d = function (f) {
            var g = f.target || f.originalTarget || f.srcElement || f.relatedTarget || f.fromElement, h = c.paper; f = { chart: c, event: f }; N ? h.getById(g.parentNode.raphaelid) || (c.onContainerRollOut(f), b = !1, a.detachEvent("onmouseover", d)) : g.viewportElement || (b = !1, c.onContainerRollOut(f), l.removeEventListener("mouseover",
d))
        }; return d
    }; return function (d) { var f = d.type, g = d.data; "mouseover" !== f && "touchstart" !== f || !1 !== b || (b = !0, g.onContainerRollOver(d), N ? a.attachEvent("onmouseover", c(g)) : l.addEventListener("mouseover", c(g))) } 
} (), setChartEvents: function () {
    var a = this.options, b = this.eventListeners || (this.eventListeners = []), a = this.link = a.chart.link, c = this.container, d = C(this.definition && this.definition.chart.enablechartmousemoveevent, 0); M(c, "click", this.onContainerClick); b.push(z(c, "click", this.onContainerClick, this)); M(this.paper.canvas,
"mouseover", this.chartHoverManager, this); M(this.paper.canvas, "touchstart", this.chartHoverManager, this); M(this.paper.canvas, "mouseout", this.chartHoverManager, this); M(this.paper.canvas, "touchend", this.chartHoverManager, this); b.push(z(this.paper.canvas, "mouseover touchstart mouseout touchend", this.chartHoverManager, this)); M(c, "mousemove", this.onContainerMouseMove, this); M(c, "touchmove", this.onContainerMouseMove, this); d && b.push(z(c, "mousemove touchmove", this.onContainerMouseMove, this)); this.paper.canvas.style.cursor =
P.svg ? a && "pointer" || "default" : a && "hand" || "default"
}, onOverlayMessageClick: function () { var a = this.elements; P.animation({ opacity: 0 }, 1E3); a.messageText && a.messageText.hide(); a.messageVeil && a.messageVeil.hide() }, showMessage: function (a, b) {
    var c = this.paper, d = this.options.chart, f = this.elements, g = f.messageText, h = f.messageVeil, k = c.width, l = c.height; h || (h = f.messageVeil = c.rect(0, 0, k, l).attr({ fill: "rgba(0,0,0,0.2)", stroke: "none" })); h.show().toFront().attr("cursor", b ? "pointer" : "default")[b ? "click" : "unclick"](this.onOverlayMessageClick,
this); g || (g = f.messageText = c.text(k / 2, l / 2, t).attr({ fill: "rgba(255,255,255,1)", "font-family": "Verdana,sans", "font-size": 10, "line-height": 14, ishot: !0 })); a = a || t; this.smartLabel.setStyle({ "line-height": "14px", "font-family": "Verdana,sans", "font-size": "10px" }); c = this.smartLabel.getSmartText(a, k - (d.spacingRight || 0) - (d.spacingLeft || 0), l - (d.spacingTop || 0) - (d.spacingBotton || 0)); g.attr({ text: c.text, ishot: !0, cursor: b ? "pointer" : "default" })[b ? "click" : "unclick"](this.onOverlayMessageClick, this).show().toFront()
},
    drawButtons: function () {
        var a = this, b = a.logic, c = "zoomline" === b.rendererId, d = a.paper, f = a.elements, g = a.toolbar || (a.toolbar = []), h = a.menus || (a.menus = []), k = a.layers, l = a.options, m = l[da], b = m && m.outCanvasStyle || b.outCanvasStyle || {}, m = l.chart.toolbar || {}, n = m.hDirection, s = c ? 1 : m.vDirection, t = m.button || {}, u = t.scale, w = t.width * t.scale, z = t.height * t.scale, C = n * (t.spacing * t.scale + w), B = t.radius, E = (l = l.exporting) && l.buttons || {}, I = E.exportButton && !1 !== E.exportButton.enabled, E = E.printButton && !1 !== E.printButton.enabled, G,
H = k.buttons || (k.buttons = d.group("buttons").trackTooltip(!0)); g.y || (g.y = (c ? 0 : m.y) + m.vMargin * s + Ca(0, z * s)); g.x || (g.x = m.x + m.hMargin * n - qa(0, w * n)); g.count = 0; g.add = function (a, b, c) {
    c = "string" === typeof c ? { tooltip: c} : c || {}; var f = 0 === g.count ? C - n * t.spacing * t.scale : C, f = c.x || (g.x += f), q = c.tooltip || ""; g.push(a = d.button(f, c.y || g.y, za, a, { width: w, height: z, r: B, id: g.count++, verticalPadding: t.symbolHPadding * u, horizontalPadding: t.symbolHPadding }, H).attr({ ishot: !0, fill: [t.fill, t.labelFill, t.symbolFill, t.hoverFill], stroke: [t.stroke,
t.symbolStroke], "stroke-width": [t.strokeWidth, t.symbolStrokeWidth]
    }).tooltip(q).buttonclick(b)); return a
}; I && (h.push(G = f.exportMenu = Q({ chart: a, basicStyle: b, items: function (b) { var c = [], d = function (b) { return function () { a.logic.chartInstance.exportChart({ exportFormat: b }) } }, f; for (f in b) c.push({ text: b[f], onclick: d(f) }); return c } (l.exportformats) })), f.exportButton = g.add("exportIcon", function (a, b) { return function () { G.visible ? G.hide() : G.show({ x: a, y: b + 1 }) } } (g.x + w, g.y + z), { tooltip: "Export chart" })); E && (f.printButton =
g.add("printIcon", function () { a.print() }, { tooltip: "Print chart" }))
    }, setMargins: function () { var a = this.paper, b = this.options.chart || {}; this.canvasBorderWidth = b.plotBorderWidth || 0; this.canvasTop = fa(b.marginTop) || 0; this.canvasLeft = fa(b.marginLeft) || 0; this.canvasWidth = fa(a.width - (b.marginLeft || 0) - (b.marginRight || 0)); this.canvasHeight = fa(a.height - (b.marginTop || 0) - (b.marginBottom || 0)); this.canvasRight = this.canvasLeft + this.canvasWidth; this.canvasBottom = this.canvasTop + this.canvasHeight }, drawBackground: function () {
        var a =
this, b = a.paper, c = a.layers, d = a.elements, f = c.background, g = d.background, h = a.options.chart || {}, k = s(h.borderWidth) || 0, l = 0.5 * k, m = h.borderWidth || 0, n = a.chartHeight, t = a.chartWidth, w = d.backgroundImage, z = h.bgSWF, C = h.bgSWFAlpha / 100, E = h.bgImageDisplayMode, I = h.bgImageVAlign, G = h.bgImageHAlign, H = h.bgImageScale, J = m + "," + m + "," + (t - 2 * m) + "," + (n - 2 * m), P, M, K, N, Q, S, p; b.canvas.style.backgroundColor = h.containerBackgroundColor; h = { left: l, top: l, width: b.width - k, height: b.height - k, stroke: h.borderColor, "stroke-width": k, fill: V(h.backgroundColor) };
        f || (f = c.background = b.group("background")); g ? g.attr(h) : g = d.background = b.rect(h, f); z && (P = new B, Q = K = 1, w = [], P.onload = function () {
            M = ba(E, I, G, H, m, t, n, P); M["clip-rect"] = J; if (M.tileInfo) for (K = M.tileInfo.xCount, Q = S = M.tileInfo.yCount, p = M.y, delete M.tileInfo; K && M.width && M.height; ) S -= 1, N ? (w[void 0] = N.clone().attr({ x: M.x, y: M.y }), f.appendChild(w[void 0])) : w[void 0] = N = b.image(z, f).attr(M).css({ opacity: C }), M.y += M.height, 0 === S && (S = Q, K -= 1, M.x += M.width, M.y = p); else w[0] = b.image(z, f), w[0].attr(M).css({ opacity: C }).attr({ visibility: Ga,
                "clip-rect": J
            }); u.raiseEvent("BackgroundLoaded", { url: z, bgImageAlpha: 100 * C, bgImageDisplayMode: E, bgImageVAlign: I, bgImageHAlign: G, bgImageScale: H, imageWidth: P.width, imageHeight: P.height }, a.logic.chartInstance)
        }, P.onerror = function (b) { u.raiseEvent("BackgroundLoadError", { url: z, bgImageAlpha: 100 * C, error: b, bgImageDisplayMode: E, bgImageVAlign: I, bgImageHAlign: G, bgImageScale: H }, a.logic.chartInstance) }, P.src = z, d.backgroundImage = w)
    }, drawGraph: function () {
        var a = this, b = a.paper, c = a.plots = a.elements.plots, d = a.logic, f =
a.layers, g = a.options, h = a.elements, k = g.chart, g = a.datasets = g.series, l = la(k.rendererId, k.defaultSeriesType), n = f.background, s = f.dataset = f.dataset || b.group("dataset").insertAfter(n), t, u, n = function (a, b) {
    return function (f) {
        var g = c[a], q, h = { hcJSON: { series: []} }, k = h.hcJSON.series[a] || (h.hcJSON.series[a] = {}), l = d.chartInstance.jsVars._reflowData; q = (f = la(f, !g.visible)) ? "visible" : "hidden"; ha(g.graphics, function (a) { !0 !== a.data("alwaysInvisible") && a.attr("visibility", q) }); g.visible = f; b.visible = f; k.visible = f; m(l, h,
!0)
    } 
}, w = function (b) { return function (d, f) { a["legendClick" + l] && a["legendClick" + l](c[b], d, f) || a.legendClick && a.legendClick(c[b], d, f) } }, z = function (b) { return function () { return a.getEventArgs && a.getEventArgs(c[b]) } }, C = function (b, d, f) { return function (g, h) { d.call(a, c[b], f, { numUpdate: g, hasAxisChanged: h }) } }; f.tracker = f.tracker || b.group("hot").insertAfter(s); a.drawCanvas(); a.drawAxes(); c || (c = a.plots = a.plots || [], h.plots = c); f = 0; for (h = g.length; f < h; f++) b = g[f] || {}, s = b.updatePlot = "updatePlot" + ja($(b.type, b.plotType,
l)), s = a[s], t = b.drawPlot = "drawPlot" + ja($(b.type, b.plotType, l)), t = a[t] || a.drawPlot, (u = c[f]) || (c.push(u = { index: f, items: [], data: b.data || [], name: b.name, userID: b.userID, setVisible: n(f, b), legendClick: w(f), getEventArgs: z(f), realtimeUpdate: C(f, s || t, b) }), b.plot = u, b.legendClick = u.legendClick, b.getEventArgs = u.getEventArgs, b.setVisible = u.setVisible), t.call(a, u, b); k.hasScroll && (a.drawScroller(), a.finalizeScrollPlots())
    }, drawPlot: f, drawCanvas: f, drawAxes: f, drawScroller: function () { }, drawLegend: function () {
        var a = this,
b = a.options, c = a.paper, d = b.chart || {}, f = b.legend, g = f.scroll, b = { elements: {} }, h = b.elements, k = a.layers.legend, l = h.box, n = h.caption, s = h.elementGroup, u = "vertical" === f.layout, w = d.marginBottom, z = d.spacingBottom, B = d.spacingLeft, E = d.spacingRight, I = c.width, G = c.height, H = a.canvasTop, J = f.width, M = f.height, K = f.borderRadius, N = f.backgroundColor, V = f.borderColor, S = f.borderWidth || 0, Q = 0.5 * S, p = 0.5 * S + 2, d = C(f.padding, 4), v = 0.5 * d, A, F, e, Z, O, R, $, ba = g && g.enabled; u ? (u = I - E - J, w = H + 0.5 * (G - w - H - M) + (f.y || 0)) : (u = B + 0.5 * (I - B - E - J) + (f.x || 0),
w = G - z - M); z = P.crispBound(u, w, J, M, S); u = z.x; w = z.y; J = z.width; M = z.height; k || (k = a.layers.legend = c.group("legend").insertBefore(a.layers.tracker).translate(u, w).attr("class", "fusioncharts-legend")); a.addCSSDefinition(".fusioncharts-legend .fusioncharts-caption", m({ "text-anchor": f.title.align }, f.title.style)); f.legendAllowDrag && (a.addCSSDefinition(".fusioncharts-legend", { cursor: "move" }), F = u, e = w, k.drag(function (a, b) {
    Z = R + a; O = $ + b; Z + J + p > I && (Z = I - J - p); O + M + p > G && (O = G - M - p); Z < p && (Z = p); O < p && (O = p); k.translate(Z - F, O -
e); F = Z; e = O
}, function () { R = F; $ = e })); K = { x: 0, y: 0, width: J, height: M, r: K, stroke: V, "stroke-width": S, fill: N || "none", ishot: f.legendAllowDrag }; l ? l.attr(K) : l = h.box = c.rect(K, k); l.shadow(f && f.shadow); ba ? (A = M - d, l = "," + J + "," + A, s = h.elementGroup = c.group("legenditems", k).attr({ "clip-rect": "0," + v + l }), g = h.scroller || (h.scroller = c.scroller(J - 10 + v - S, Q, 10, M - S, !1, { scrollPosition: g.scrollPosition || 0, scrollRatio: (A + d) / f.totalHeight, showButtons: !1, displayStyleFlat: g.flatScrollBars }, k)), g.attr("fill", f.legendScrollBgColor).scroll(function (b) {
    s.transform(["T",
0, (A - f.totalHeight) * b]); m(a.fusionCharts.jsVars._reflowData, { hcJSON: { legend: { scroll: { position: b}}} }, !0)
})) : s = h.elementGroup = k; if (f.title && f.title.text !== t) { switch (f.title.align) { case "start": g = d; break; case "end": g = J - d - (ba ? 10 : 0); break; default: g = 0.5 * J } K = { "class": "fusioncharts-caption", "text-anchor": f.title.align, text: f.title.text, title: f.title.originalText || "", x: g, y: d, fill: f.title.style.color, "vertical-align": "top" }; n ? n.attr(K) : n = h.caption = c.text(K, s).attr("class", "fusioncharts-caption") } this["draw" +
ja(f.type || "point") + "LegendItem"](b)
    }, drawPointLegendItem: function (a) {
        var b = this, c = b.paper, d = b.options, f = d.series, h = d.chart.defaultSeriesType, d = d.legend, k = d.legendHeight, l = d.symbolPadding, n = d.textPadding || 2, s = C(d.padding, 4), t = d.itemHoverStyle, w = d.itemHiddenStyle, z = d.itemStyle, B = z.color, w = w && w.color || "#CCCCCC", E = t && t.color || B, t = d.symbol3DLighting, I = d.symbolWidth, G = d.itemWidth, J = !1 !== d.interactiveLegend, M = a.elements, P = M.elementGroup; a = a.item = []; var M = M.item = [], K = [], N = { line: !0, spline: !0, scatter: !0, bubble: !0,
            dragnode: !0, zoomline: !0
        }, S, Q, ba, Za, p, v, A, F, e, Z, O, R, aa, X, Sb, da, fa, Ea, ca, fb, W; R = 0; for (aa = f.length; R < aa; R += 1) if ((S = f[R]) && !1 !== S.showInLegend) if (F = S.type || h, "point" === S.legendType) for (S = S.data || [], p = 0, v = S.length; p < v; p += 1) ba = S[p] || {}, !1 !== ba.showInLegend && (ba._legendType = F, K.push(ba)); else switch (S._legendType = F, F) { case "pie": case "pie3d": case "funnel": case "pyramid": K = S.data; break; default: K.push(S) } K.sort(function (a, b) { return (a.legendIndex || 0) - (b.legendIndex || 0) || a.__i - b.__i }); d.reversed && K.reverse();
        f = d.initialItemX || 0; h = d.initialItemY || 0; p = function (a) { var c = this.data("legendItem"), d = c.getEventArgs ? c.getEventArgs() : {}, e; a = H(b.logic.chartInstance.ref, a); d.chartX = a.chartX; d.chartY = a.chartY; d.pageX = a.pageX; d.pageY = a.pageY; d.preventDefaults = function () { e = !0 }; u.raiseEvent("LegendItemClicked", d, b.logic.chartInstance); J && !e && c.legendClick() }; v = function (a) {
            var c = this.data("legendItem"), d = c.getEventArgs ? c.getEventArgs() : {}; a = H(b.logic.chartInstance.ref, a); var e = !1 !== c.visible, c = c.plot.legend.elements.legendItemText;
            d.chartX = a.chartX; d.chartY = a.chartY; d.pageX = a.pageX; d.pageY = a.pageY; e && c && c.attr({ fill: E }); u.raiseEvent("LegendItemRollover", d, b.logic.chartInstance)
        }; A = function (a) { var c = this.data("legendItem"), d = c.getEventArgs ? c.getEventArgs() : {}; a = H(b.logic.chartInstance.ref, a); var e = !1 !== c.visible, c = c.plot.legend.elements.legendItemText; d.chartX = a.chartX; d.chartY = a.chartY; d.pageX = a.pageX; d.pageY = a.pageY; e && c && c.attr({ fill: B }); u.raiseEvent("LegendItemRollout", d, b.logic.chartInstance) }; b.addCSSDefinition(".fusioncharts-legend .fusioncharts-legenditem",
d.itemStyle); R = 0; for (aa = K.length; R < aa; R += 1) !1 !== K[R].showInLegend && (W = { elements: {}, hiddenColor: w, itemTextColor: B, hoverColor: E }, a.push(W), M.push(W.elements), S = K[R], e = f + S._legendX + s, Z = h + S._legendY - s, O = S._legendH, Q = S._legendType || F, ba = !1 !== S.visible, Za = W.itemLineColor = V(S.color || {}), S.plot.legend = W, W.elements.legendItemText = c.text({ "class": "fusioncharts-legenditem", x: e + k + n - 2, y: Z + (S._legendTestY || 0), text: S.name, fill: ba ? B : w, "vertical-align": "top", "text-anchor": "start", cursor: z.cursor || "pointer", ishot: J,
    "line-height": z.lineHeight
}, P).data("legendItem", S), N[Q] ? (Q = Z + l + 0.5 * I, S.lineWidth && (fb = W.elements.legendItemLine = c.path({ "stroke-width": S.lineWidth, stroke: ba ? Za : w, cursor: z.cursor || "pointer", ishot: J, path: ["M", e + l, Q, "L", e + l + I, Q] }, P).data("legendItem", S)), S && (fa = S.marker) && !1 !== fa.enabled && (W.symbolStroke = V($((Ea = fa.lineColor) && (Ea.FCcolor && Ea.FCcolor.color.split(",")[0] || Ea), Za)), t ? fa.fillColor && fa.fillColor.FCcolor ? (Q = m({}, fa.fillColor), Q.FCcolor.alpha = "100") : Q = $(fa.fillColor, Za) : Q = { FCcolor: { color: $((ca =
fa.fillColor) && (ca.FCcolor && ca.FCcolor.color.split(",")[0] || ca), Za), angle: 0, ratio: "0", alpha: "100"
}
}, W.symbolColor = V(Q), X = 0.5 * I, Za = e + l + X, Q = Z + l + X, fb && (X *= 0.6), Sb = fa.symbol.split("_"), da = "spoke" === Sb[0] ? 1 : 0, Q = Sb[1] ? W.elements.legendItemSymbol = c.polypath(Sb[1], Za, Q, X, fa.startAngle, da, P) : W.elements.legendItemSymbol = c.circle(Za, Q, X, P), Q.data("legendItem", S).attr({ cursor: z.cursor || "pointer", stroke: ba ? W.symbolStroke : w, fill: ba ? W.symbolColor : w, "stroke-width": 1, ishot: J }))) : (Q = b.getSymbolPath(e + l, Z + l, I, I, Q, S,
!t), W.symbolColor = V(Q.color), W.symbolStroke = V(Q.strokeColor), Q = W.elements.legendItemSymbol = c.path({ path: Q.path, "stroke-width": Q.strokeWidth, stroke: ba ? W.symbolStroke : w, fill: ba ? W.symbolColor : w, cursor: z.cursor || "pointer", ishot: J }, P).data("legendItem", S)), W.elements.legendItemBackground = c.rect({ x: e, y: Z, width: G, height: O, r: 0, fill: V(S.legendFillColor || g), "stroke-width": 1, stroke: V(S.legendBorderColor || "none"), cursor: z.cursor || "pointer", ishot: J }, P).click(p).mouseover(v).mouseout(A).data("legendItem", S)); d.reversed &&
K.reverse()
    }, drawCaption: function () {
        var a = this.options.chart, b = this.options.title, c = this.options.subtitle, d = this.paper, f = this.smartLabel, g = this.elements, h = this.layers, k = h.caption, l = g.caption, m = g.subcaption, n = b.text, s = c && c.text, t = (this.canvasLeft || 0) + C(this.canvasWidth, d.width) / 2, u = b.x, w = b.horizontalPadding, z = b.align, B = b.alignWithCanvas, E = a.spacingLeft, I = a.spacingRight, G; !n && !s || k || (k = h.caption = d.group("caption"), h.tracker ? k.insertBefore(h.tracker) : k.insertAfter(h.dataset)); if (void 0 === u) switch (z) {
            case mb: u =
B ? d.width - a.marginRight - w : d.width - w; b.align = "end"; break; case Fb: u = B ? a.marginLeft + w : w; b.align = "start"; break; default: u = B ? t : E + 0.5 * (d.width - E - I) || d.width / 2, b.align = "middle"
        } n ? (this.addCSSDefinition(".fusioncharts-caption", b.style), t = { "class": "fusioncharts-caption", text: b.text, fill: b.style.color, x: u, y: b.y || a.spacingTop || 0, "text-anchor": b.align || "middle", "vertical-align": "top", visibility: "visible", title: b.originalText || "" }, l ? l.attr(t) : l = g.caption = d.text(t, k).attr("class", "fusioncharts-caption"), l.css(b.style),
f ? (f.setStyle(b.style), G = f.getOriSize(b.text).height) : G = 10) : l && (l = g.caption = l.remove()); s ? (this.addCSSDefinition(".fusioncharts-subcaption", c.style), t = { "class": "fusioncharts-subcaption", text: c.text, title: c.originalText || "", fill: c.style.color, x: u, y: n ? l.attrs.y + G + 2 : b.y || a.spacingTop || 0, "text-anchor": b.align || "middle", "vertical-align": "top", visibility: "visible" }, m ? m.attr(t) : m = g.subcaption = d.text(t, k).attr("class", "fusioncharts-subcaption"), m.css(c.style)) : m && (g.subcaption = m.remove()); n || s || !k || (h.caption =
k.remove())
    }, drawLogo: function () {
        var a = this, b = a.paper, c = a.elements, d = a.options, f = d.credits, g = d.chart || {}, h = g.borderWidth || 0, k = a.chartHeight, l = a.chartWidth, m = c.logoImage, n = g.logoURL, s = g.logoAlpha / 100, t = g.logoPosition, w = g.logoLink, z = g.logoScale, C = g.logoLeftMargin, E = g.logoTopMargin, d = { tr: { vAlign: wb, hAlign: mb }, bl: { vAlign: tb, hAlign: Fb }, br: { vAlign: tb, hAlign: mb }, cc: { vAlign: "middle", hAlign: "middle"} }, I, G, J; a.logic && f.enabled && b.text().attr({ text: f.text, x: 6, y: k - 4, "vertical-align": tb, "text-anchor": "start",
            fill: "rgba(0,0,0,0.5)", title: f.title || ""
        }).css({ fontSize: 9, fontFamily: "Verdana,sans", cursor: "pointer", _cursor: "hand" }).click(function () { g.events.click.call({ link: f.href }) }); n && (I = new B, (J = d[t]) || (J = { vAlign: wb, hAlign: Fb }), I.onload = function () {
            G = ba("none", J.vAlign, J.hAlign, z, h, l, k, I); m = b.image(n); m.attr(G).translate(C, E).css({ opacity: s }); w && m.css({ cursor: "pointer", _cursor: "hand" }); m.mouseover(function (b) {
                b = H(a.logic.chartInstance.ref, b); u.raiseEvent("LogoRollover", { logoURL: n, logoAlpha: 100 * s, logoPosition: t ||
"tl", logoScale: z, logoLink: w, chartX: b.chartX, chartY: b.chartY, pageX: b.pageX, pageY: b.pageY
                }, a.logic.chartInstance)
            }); m.mouseout(function (b) { b = H(a.logic.chartInstance.ref, b); u.raiseEvent("LogoRollout", { logoURL: n, logoAlpha: 100 * s, logoPosition: t || "tl", logoScale: z, logoLink: w, chartX: b.chartX, chartY: b.chartY, pageX: b.pageX, pageY: b.pageY }, a.logic.chartInstance) }); m.click(function (b) {
                b = H(a.logic.chartInstance.ref, b); u.raiseEvent("LogoClick", { logoURL: n, logoAlpha: 100 * s, logoPosition: t || "tl", logoScale: z, logoLink: w,
                    chartX: b.chartX, chartY: b.chartY, pageX: b.pageX, pageY: b.pageY
                }, a.logic.chartInstance, void 0, function () { w && g.events.click.call({ link: w }) })
            }); u.raiseEvent("LogoLoaded", { logoURL: n, logoAlpha: 100 * s, logoPosition: t || "tl", logoScale: z, logoLink: w }, a.logic.chartInstance)
        }, I.onerror = function (b) { u.raiseEvent("LogoLoadError", { logoURL: n, logoAlpha: 100 * s, logoPosition: t || "tl", logoScale: z, logoLink: w, error: b }, a.logic.chartInstance) }, I.src = n, c.logoImage = m)
    }, getEventArgs: function (a) {
        a = a || {}; return { datasetName: a.name, datasetIndex: a.index,
            id: a.userID, visible: a.visible
        }
    }, legendClick: function (a, b) {
        var c = a.legend, d = c && c.elements, f = d && d.legendItemText, g = d && d.legendItemSymbol, d = d && d.legendItemLine, h = c && c.hiddenColor, k = c && c.itemLineColor, l = c && c.itemTextColor, m = c && c.symbolColor, n = c && c.symbolStroke, c = $(b, !a.visible); a.setVisible(b); c ? (g && g.attr({ fill: m || k, stroke: n }), f && f.attr({ fill: l }), d && d.attr({ stroke: k })) : (g && g.attr({ fill: h, stroke: h }), f && f.attr({ fill: h }), d && d.attr({ stroke: h })); if ((f = this.datasets && this.datasets[a.index] && this.datasets[a.index].relatedSeries) &&
f instanceof Array && 0 < f.length) for (g = f.length; g--; ) d = parseFloat(f[g]), d = this.plots[d], d.legendClick.call(d, c, !1)
    }, exportChart: function (c) {
        var d = this, f = d.fusionCharts, g = d.options; c = "object" === typeof c && function (a) { var b = {}, c; for (c in a) b[c.toLowerCase()] = a[c]; return b } (c) || {}; var h = m(m({}, g.exporting), c), k = (h.exportformat || "png").toLowerCase(), n = h.exporthandler, s = (h.exportaction || t).toLowerCase(), z = h.exporttargetwindow || t, C = h.exportfilename, B = h.exportparameters; if (!g.exporting || !g.exporting.enabled ||
!n) return !1; u.raiseEvent("beforeExport", h, f, void 0, function () {
    var c = d.elements, g = c.printButton, c = c.exportButton, q = f.id, m = d.paper, L, E; g && "hidden" != g.attrs.visibility && g.attr({ visibility: "hidden" }); c && "hidden" != c.attrs.visibility && c.attr({ visibility: "hidden" }); L = m.toSVG(); g && g.attr({ visibility: "visible" }); c && c.attr({ visibility: "visible" }); L = L.replace(/(\sd\s*=\s*["'])[M\s\d\.]*(["'])/ig, "$1M 0 0 L 0 0$2"); "pdf" === k && (L = L.replace(/<(\b[^<>s\s]+\b)[^\>]+?opacity\s*=\s*['"][^1][^\>]+?(\/>|>[\s\r\n]*?<\/\1>)/ig,
function (a, b) { var c = xa.exec(a) || t, d = ua.exec(a) || t; return a + "<" + b + c + d + ' opacity="1" stroke-opacity="1" fill="#cccccc" stroke-width="0" r="0" height="0.5" width="0.5" d="M 0 0 L 1 1" />' })); g = { charttype: f.chartType(), stream: L, stream_type: "svg", meta_bgColor: h.bgcolor || "", meta_DOMId: f.id, meta_width: m.width, meta_height: m.height, parameters: ["exportfilename=" + C, "exportformat=" + k, "exportaction=" + s, "exportparameters=" + B].join("|") }; u.raiseEvent("exportDataReady", g, f); if ("download" === s) {
        /webkit/ig.test(l.navigator.userAgent) &&
"_self" === z && (z = c = q + "export_iframe", d.exportIframe || (d.exportIframe = c = w("IFRAME", { name: c, width: "1px", height: "1px" }, a.body), c.style.cssText = "position:absolute;left:-10px;top:-10px;")); c = w("form", { method: "POST", action: n, target: z, style: "display:none;" }, a.body); for (E in g) w("input", { type: "hidden", name: E, value: g[E] }, c); c.submit(); a.body.removeChild(c); c = void 0; return !0
    } (new u.ajax(function (a) { var c = {}; a.replace(RegExp("([^?=&]+)(=([^&]*))?", "g"), function (a, b, d, f) { c[b] = f }); b.raiseEvent("exported", c, f) },
function (a) { a = { statusCode: 0, statusMessage: "failure", error: a, DOMId: q, width: m.width, height: m.height }; b.raiseEvent("exported", a, f, [a]) })).post(n, g)
}, function () { u.raiseEvent("exportCancelled", h, f) })
    }, print: function (b) {
        var c = this, d = m({}, b); if (c.isPrinting) return !1; u.raiseEvent("BeforePrint", d, c.logic.chartInstance, void 0, function () {
            var b = c.container, f = c.elements, g = f.printButton, h = f.exportButton, q = [], k = b.parentNode, f = a.body || a.getElementsByTagName("body")[0], m = f.childNodes; c.isPrinting = !0; ha(m, function (a,
b) { 1 == a.nodeType && (q[b] = a.style.display, a.style.display = "none") }); !1 !== d.hideButtons && (g && "hidden" != g.attrs.visibility && g.attr({ visibility: "hidden" }), h && "hidden" != h.attrs.visibility && h.attr({ visibility: "hidden" })); f.appendChild(b); l.print(); setTimeout(function () { g && g.attr({ visibility: "visible" }); h && h.attr({ visibility: "visible" }); k.appendChild(b); ha(m, function (a, b) { 1 == a.nodeType && (a.style.display = q[b]) }); c.isPrinting = !1; u.raiseEvent("PrintComplete", d, c.logic.chartInstance) }, 1E3)
        }, function () {
            u.raiseEvent("PrintCancelled",
d, c.logic.chartInstance)
        })
    }, getSymbolPath: function (a, b, c, d, f, g, h) {
        var k = ["M"], l, m, n; l = (g.color && hb("string" === typeof g.color ? g.color : g.color.FCcolor.color) || t).replace(Xa, ""); n = db(l, 60).replace(Xa, ga); h ? l = { FCcolor: { color: l, angle: 0, ratio: "0", alpha: "100"}} : (h = db(l, 40), l = { FCcolor: { color: l + "," + l + "," + h + "," + l + "," + l, ratio: "0,30,30,30,10", angle: 0, alpha: "100,100,100,100,100"} }); switch (f) {
            case "column": case "dragcolumn": case "column3d": g = 0.25 * c; f = 0.5 * g; h = 0.7 * d; m = 0.4 * d; k = k.concat([a, b + d, "l", 0, -h, g, 0, 0, h, "z",
"m", g + f, 0, "l", 0, -d, g, 0, 0, d, "z", "m", g + f, 0, "l", 0, -m, g, 0, 0, m, "z"]); l.FCcolor.angle = 270; break; case "bar": case "bar3d": g = 0.3 * c; f = 0.6 * c; h = d / 4; m = h / 2; k = k.concat([a, b, "L", a + f, b, a + f, b + h, a, b + h, "Z", "M", a, b + h + m, "L", a + c, b + h + m, a + c, b + h + m + h, a, b + 2 * h + m, "Z", "M", a, b + 2 * (h + m), "L", a + g, b + 2 * (h + m), a + g, b + d, a, b + d, "Z"]); break; case "area": case "area3d": case "areaspline": case "dragarea": h = 0.6 * d; m = 0.2 * d; d *= 0.8; k = k.concat([a, b + d, "L", a, b + h, a + 0.3 * c, b + m, a + 0.6 * c, b + h, a + c, b + m, a + c, b + d, "Z"]); l.FCcolor.angle = 270; break; case "pie": case "pie3d": g =
0.5 * c; f = 0.9 * g; c = a + g + 1; d = b + g - 1; a = a + g - 1; b = b + g + 1; k = k.concat(["M", c, d, "L", c, d - f + 1, "A", f - 1, f - 1, 0, 0, 1, c + f - 1, d, "Z", "M", a, b, "L", a, b - f, "A", f, f, 0, 1, 0, a + f, b, "Z"]); l.FCcolor.radialGradient = "1"; l.FCcolor.ratio = "0,0,0,100,0"; break; case "boxandwhisker2d": k = k.concat([a, b, "L", a + c, b, a + c, b + d, a, b + d, "Z"]); l = g.color; n = "#000000"; break; default: k = k.concat([a, b, "L", a + c, b, a + c, b + d, a, b + d, "Z"]), l.FCcolor.angle = 270, l.FCcolor.ratio = "0,70,30"
        } return { path: k, color: l, strokeWidth: 0.5, strokeColor: n}
    } 
}); d.prototype = { configure: function () {
    var a =
this.axisData, b = this.renderer, c = this.isVertical, d = this.isReverse, f = b.options, g = f.chart, h = g.marginBottom, g = g.marginRight, k = b.canvasTop, l = b.canvasLeft, m = this.min = a.min, m = this.span = (this.max = a.max) - m, l = this.startX = C(a.startX, l), k = this.startY = C(a.startY, k), n = this.endX = C(a.endX, b.canvasRight), a = this.endY = C(a.endY, b.canvasBottom), m = this.pixelRatio = c ? (a - k) / m : (n - l) / m, s = this.relatedObj = {}; s.marginObj = { top: k, right: g, bottom: h, left: l }; s.canvasObj = { x: l, y: k, w: n - l, h: a - k, toX: n, toY: a }; this.startPixel = d ? c ? a : n : c ? k :
l; this.pixelValueRatio = d ? -m : m; this.primaryOffset = this.secondaryOffset = 0; this.cache = { lowestVal: 0, highestVal: 0, indexArr: [], hashTable: {} }; this.elements = this.elements || {}; this.belowBandGroup && (b.elements.axes = b.elements.axes || {}, b.elements.axes.belowBandGroup = this.belowBandGroup, f && f.chart && f.chart.hasScroll && this.belowBandGroup.attr({ "clip-rect": b.elements["clip-canvas"] })); this.poi = {}
}, draw: function () {
    var a = this.axisData, b = a && a.plotLines || [], c = a && a.plotBands || [], d = a && a.showLine, f = a && a.tickLength, g =
a && a.tickWidth; a && a.title && this.drawAxisName(); a && a.labels && (this.renderer.addCSSDefinition("." + a.labels.className + " .fusioncharts-label", a.labels.style), this.belowLabelGroup && this.belowLabelGroup.attr("class", a.labels.className), this.aboveLabelGroup && this.aboveLabelGroup.attr("class", a.labels.className)); b && 0 < b.length && this.drawPlotLine(); c && 0 < c.length && this.drawPlotBands(); isNaN(f) || 0 === f || isNaN(g) || 0 === g || this.drawTicks(); d && this.drawLine()
}, scroll: function () { }, setOffset: function (a, b) {
    var c = this.primaryOffset =
a, d = this.secondaryOffset = b || this.secondaryOffset, f = this.isVertical, g, h, k, l = [this.topLabelGroup, this.belowLabelGroup, this.topLineGroup, this.belowLineGroup, this.topBandGroup, this.belowBandGroup], m, n; m = 0; for (n = l.length; m < n; m += 1) if (k = l[m]) g = f ? d : c, h = f ? c : d, k.attr({ transform: "t" + g + "," + h }); f || this.drawPlotLine && this.drawPlotLine()
}, update: function () { }, drawTicks: function () {
    var a = this.axisData, b = this.renderer.paper, c = this.min, d = this.max, f = this.isVertical, g = this.layerBelowDataset, g = this.tickGroup = this.tickGroup ||
b.group("axis-ticks", g), h = this.relatedObj.canvasObj, k = a.offset, l = a.opposite, m = a.showAxis, n = a.tickInterval, s = a.tickLength, t = a.tickWidth, a = a.tickColor, u = c; if (f && m) for (c = this.getAxisPosition(c), f = this.getAxisPosition(d), h = l ? h.toX + k : h.x - k, b.path(["M", h, c, "L", h, f], g).attr({ stroke: a, "stroke-width": t }); Pa(u) <= d; ) k = this.getAxisPosition(u), c = l ? h + s : h - s, b.path(["M", h, k, "L", c, k], g).attr({ stroke: a, "stroke-width": t }), u += n
}, getAxisPosition: function (a, b) {
    var c; b ? c = (a - this.startPixel) / this.pixelValueRatio + this.min :
(a = this.axisData.reversed ? this.min + (this.max - a) : a, c = this.startPixel + (a - this.min) * this.pixelValueRatio); return c
}, drawPlotLine: function () {
    var a = this.renderer, b = a.paper, c = this.isVertical, d = +!c, f = this.lines = this.lines || [], h = this.labels = this.labels || [], k = this.relatedObj.canvasObj, l = this.globalOptions || {}, m = this.elements || {}, n = this.axisData.plotLines || [], s = this.primaryOffset, u = c ? this.startY : this.startX, w = c ? this.endY : this.endX, z = parseFloat(a.canvasBorderWidth) || 0, B = qa(n.length, qa(f.length, h.length)), E =
a.layers.datalabels, I, G, J = this.belowLineGroup, H = this.topLineGroup, M = this.belowLabelGroup, P = this.topLabelGroup, K, N, S = !1 !== (a.tooltip || {}).enabled, Q, p, v, A, F, e, Z, O, R, ba, $, X, W, da, Ea, ca, fb, la, sa, ma, Zb, ha, ja, Y, Ba, ea, Ca, Aa, za = l.chart.xDepth || 0, ga, ua, xa, Ra, gb, Ga, Fa, ob, Ma, Qa, Pa = []; for (Qa = 0; Qa < B; Qa += 1) {
        N = null; l = f[Qa]; K = h[Qa]; if (Q = n[Qa]) if (p = Q.width, v = Q.isVline, A = Q.isTrend, F = Q.isGrid, e = Q.tooltext, Z = Q.value, O = Q.color, R = Q.dashStyle, ba = A ? Q.to : null, $ = Q._isStackSum, I = 3 < Q.zIndex ? H : J, X = Q.label) {
            W = X.style; da = X.text;
            Ea = W && W.color; ca = X.offsetScaleIndex || 0; fb = X.offsetScale; if (la = W && W.fontSize) sa = la, -1 !== sa.indexOf("px") && (sa = sa.replace("px", ""), sa = parseFloat(sa)); G = W && W.lineHeight; la = W ? { fontFamily: W.fontFamily, fontSize: W.fontSize, lineHeight: W.lineHeight, fontWeight: W.fontWeight, fontStyle: W.fontStyle} : null; G && (ma = G, -1 !== ma.indexOf("px") && (ma = ma.replace("px", ""), ma = parseFloat(ma))); Zb = X.rotation; ha = X.x || 0; ja = X.y || 0; Y = X.align; Ba = X.verticalAlign; ea = X.textAlign; Ca = (Ca = X.borderWidth) ? -1 !== Ca.indexOf("px") ? Ca.replace("px",
"") : 1 : 1; G = $ ? E : 3 <= Q.zIndex ? P : M; X.backgroundColor && (X.labelBgClr = V({ color: X.backgroundColor, alpha: 100 * X.backgroundOpacity })); X.borderColor && (X.labelBorderClr = V({ color: X.borderColor, alpha: "100" })); Aa = sa ? 0.2 * sa : 2; ea = "left" === ea ? "start" : "right" === ea ? "end" : "middle"
        } ob = Fa = "visible"; Ma = 0 > C(fb, Z, 0); c ? (ga = this.getAxisPosition(Z), xa = A ? this.getAxisPosition(ba) || ga : ga, Ga = ga !== xa ? !0 : !1, Ra = ["M", k.x, ga, "L", k.toX, xa], v ? a.logic.isBar && (gb = a.yAxis[ca], !$ && !isNaN(fb) && 0 <= fb && 1 >= fb && (fb = gb.min + (gb.max - gb.min) * fb), ua =
gb.getAxisPosition(C(fb, Z)) + ha + Aa * (Ma ? -1 : 1)) : ua = X ? this.axisData.isOpposite || "right" === Y ? k.toX + ha : k.x + ha : this.axisData.isOpposite ? k.toX : k.x) : (ga = this.getAxisPosition(Z) || 0, ua = A ? this.getAxisPosition(ba) || ga : ga, !A && !v && 0 < za && (ga += za, ua += za, w += za), Ga = ga !== ua ? !0 : !1, Ra = ["M" + ga, k.y, "L", ua, k.toY], Fa = ga + s < u || ga + s > w ? "hidden" : Fa, v ? (gb = a.yAxis[ca], !$ && !isNaN(fb) && 0 <= fb && 1 >= fb && (fb = gb.min + (gb.max - gb.min) * (1 - fb)), ga = gb.getAxisPosition(C(fb, Z)) + ja, ga -= (z + parseFloat(Ca)) * (ja && (0 < ja ? -1 : 1))) : ga = this.axisData.opposite ||
"top" === Ba && !F ? k.y + ja : k.toY + ja, xa = ga); ob = c ? ob : ua + s < u || ua + s > w ? "hidden" : ob; if (Q && "visible" === Fa && 0.1 < p) {
            gb = Ra; var Ya = p; gb[1] === gb[4] && (gb[1] = gb[4] = fa(gb[1]) + Ya % 2 / 2); gb[2] === gb[5] && (gb[2] = gb[5] = fa(gb[2]) + Ya % 2 / 2); Ga = { path: gb, stroke: O, "stroke-width": p, "shape-rendering": !Ga && 1 <= p ? "crisp" : void 0, "stroke-dasharray": R ? R : void 0, visibility: Fa }; l ? l.attr(Ga) : (l = f[Qa] = b.path(Ga, I).css(Q.style), m.lines = m.lines || [], m.lines.push(l)); S && e && p < aa && Fa && (N = b.path({ stroke: g, "stroke-width": aa, ishot: !0, path: Ra })); N = N || l;
            S && N.tooltip(e)
        } else if (l || K) l && l.remove(), l = null, f && (f[Qa] = null), m && m.lines && (m.lines[Qa] = null); X && Q && !Q.stepped && "visible" === ob && X.text != t && " " != X.text ? (Ra = A ? "left" === Y ? ga : xa : xa, N = ua - +!v * d * za + d * (ha || 0), $ ? (Fa = c || Zb ? "middle" : "bottom", Ra += c ? 0 : sa * (Ma ? -0.4 : 0.4), Zb && (Ra += Ma ? 4 : -2, ea = Ma ? "end" : "start")) : d && this.axisData.opposite ? (Fa = tb, ea = Zb ? "start" : "middle") : Fa = Ba, /\n|<br\s*?\/?>/ig.test(da) && F && (Zb ? (Fa = "middle", N -= d * (ha || 0)) : (Fa = d && this.axisData.opposite && !Zb ? "middle" : wb, Ra -= ma)), Ga = { "class": "fusioncharts-label",
            text: da, fill: la ? Ea || O : null, title: X && (X.originalText || ""), x: N, y: Ra, "text-anchor": ea, "vertical-align": Fa, transform: " ", "text-bound": $ ? [W.backgroundColor, W.borderColor, W.borderThickness, W.borderPadding, W.borderRadius, W.borderDash] : X && [X.labelBgClr, X.labelBorderClr, Ca, Aa], visibility: ob, "line-height": W.lineHeight
        }, K ? K.attr(Ga) : (K = h[Qa] = b.text(Ga, G).attr("class", "fusioncharts-label"), l && (l.label = K), m.labels = m.labels || [], m.labels.push(K)), !F && la && K.css(la), Zb && K.attr("transform", ["r", Zb, N, Ra]), $ && K && Pa.push(K)) :
K && (K.isRotationSet = !1, K.remove(), h && (h[Qa] = null), m && m.labels && (m.labels[Qa] = null)); !l && !K || Q && null === Q.value || (Q && Q.isMinLabel ? this.poi.min = { label: K, index: Qa, line: l} : Q && Q.isMaxLabel ? this.poi.max = { label: K, index: Qa, line: l} : Q && Q.isZeroPlane && (this.poi.zero = { label: K, index: Qa, line: l }))
    } C(a.options.plotOptions.series.animation.duration, 0)
}, drawPlotBands: function () {
    var a = this.renderer, b = a.paper, c = this.isVertical, d = this.axisData.plotBands || [], f = this.bands = this.bands || [], g = this.bandLabels = this.bandLabels ||
[], h = this.relatedObj.canvasObj, k = this.primaryOffset, l = c ? this.startY : this.startX, m = c ? this.endY : this.endX, n = a.options.chart.hasScroll, s = this.belowBandGroup, t = this.topBandGroup, u = this.belowLabelGroup, w = this.topLabelGroup, z = this.elements || {}, a = !1 !== (a.tooltip || {}).enabled, B, E, I, G, J, H, K, M, P, N, p, v, A, F, e, Q, O, R, S, X, ba, W, $, aa, fa, da, ca, la, sa, ma, ga, ha, Y, ja, ea, Ca = qa(d.length, f.length); for (ea = 0; ea < Ca; ea += 1) {
        ja = "visible"; ha = f[ea]; Y = g[ea]; if (B = d[ea]) if (E = B.tooltext, I = B.to, G = B.from, J = B.value, H = B.width, K = B.color,
ma = 3 < B.zIndex ? t : s, M = B.label) {
            if (P = M.style) { if (F = P.fontSize) N = F, -1 !== N.indexOf("px") && (N = N.replace("px", ""), parseFloat(N)); (N = P.lineHeight) && -1 !== N.indexOf("px") && (N = N.replace("px", ""), parseFloat(N)); S = P.color } (N = M.borderWidth) && -1 !== N.indexOf("px") && N.replace("px", ""); p = M.align; v = M.x; A = M.y; O = M.text; R = M.originalText; e = M.backgroundColor; Q = M.backgroundOpacity; e && (ba = M.labelBgClr = V({ color: e, alpha: 100 * Q })); if (e = M.borderColor) W = M.labelBorderClr = V({ color: e, alpha: "100" }); e = M.textAlign; e = "left" === e ? "start" :
"right" === e ? "end" : "middle"; Q = M.verticalAlign; X = M.borderType; ga = 3 < B.zIndex ? w : u
        } $ = this.getAxisPosition(C(I, J)); aa = this.getAxisPosition(C(G, J)); fa = c ? h.x : aa; da = c ? $ : h.y; ca = c ? h.w : (this.axisData.reversed ? aa - $ : $ - aa) || H || 1; aa = c ? aa - $ || 1 : h.h; $ = fa + ca; ca = Ya(ca); 0 > aa && (aa = Ya(aa), da -= aa); c || (ja = n ? "hidden" : fa + k > m || $ + k < l ? "hidden" : ja); M && (la = c ? "right" === p ? h.toX + v : h.x + v : fa + ca / 2, sa = c ? da + aa / 2 : h.toY + A); if (!ha && B && "visible" === ja) B = { x: fa, y: da, width: ca, height: aa, fill: V(K), "stroke-width": 0 }, ha ? ha.attr(B) : (ha = f[ea] = b.rect(B,
ma), z.bands = z.bands || [], z.bands[ea] = ha), a && E && ha.tooltip(E); else if (ha && (!B || "hidden" === ja)) { z.labels && (g[ea] = z.labels[ea] = null); ha.label && ha.label.remove(); f[ea] = z.bands[ea] = null; ha.remove(); continue } ha && M && M.text && (B = { "class": "fusioncharts-label", text: O, title: R || "", fill: S, "text-bound": [ba, W, N, 0.2 * F, "solid" === X ? !1 : !0], x: la, y: sa, "text-anchor": e, "vertical-align": Q, "line-height": P.lineHeight }, Y ? Y.attr(B) : (Y = g[ea] = ha.label = b.text(B, ga).attr("class", "fusioncharts-label"), P && Y.css(P), z.labels = z.labels ||
[], z.labels[ea] = Y))
    } 
}, drawAxisName: function () {
    var a = this.axisData, b = a.title || {}, c = b && b.style, d = b && b.className, f = b.align, g = b.centerYAxisName || !1, h = this.renderer.paper, k = this.isVertical, l = this.relatedObj.canvasObj, m = C(a.offset, 0) + C(b.margin, 0), n = b.text || "", s = this.name || void 0, a = a.opposite, t = this.layerBelowDataset, t = t.nameGroup = t.nameGroup || h.group("axis-name", t), b = C(b.rotation, a ? 90 : 270), u = k ? a ? l.toX + m : l.x - m : (l.x + l.toX) / 2, w = { fontFamily: c.fontFamily, fontSize: c.fontSize, lineHeight: c.lineHeight, fontWeight: c.fontWeight,
        fontStyle: c.fontStyle
    }, z, g = k ? "low" === f ? l.toY : g ? (l.y + l.toY) / 2 : this.renderer.chartHeight / 2 : l.toY + m; n ? (!isNaN(b) && b && k && (z = c.fontSize, z = -1 != z.indexOf("px") ? z.replace("px", "") : z, a ? (u += parseFloat(z), z = 270 === b ? "bottom" : "top") : (u -= parseFloat(z), z = 270 === b ? "top" : "bottom")), this.renderer.addCSSDefinition("." + d, w), c = { "class": d, x: 0, y: 0, text: n, fill: c.color, "text-bound": [c.backgroundColor, c.borderColor, c.borderThickness, c.borderPadding, c.borderRadius, c.borderDash], "text-anchor": "low" === f ? a ? "end" : "start" : "middle",
        "vertical-align": k ? b ? z : "middle" : a ? tb : "top", transform: k ? "t" + u + "," + g + "r" + b : "t" + u + "," + g
    }, s ? s.attr(c) : s = this.name = h.text(c, t).attr("class", d)) : s && s.remove(); this.elements.name = s
}, drawLine: function () {
    var a = this.axisData, b = this.renderer.paper, c = this.min, d = this.max, f = this.isVertical, g = a.opposite, h = this.layerBelowDataset, h = this.lineGroup = this.lineGroup || b.group("axis-lines", h), k = a.lineColor, l = a.lineThickness, m = a.lineEndExtension || 0, n = a.lineStartExtension || 0, a = this.relatedObj.canvasObj; f ? (c = this.getAxisPosition(c) -
n, m = this.getAxisPosition(d) + m, d = f = g ? a.toX + l / 2 : a.x - l / 2) : (d = a.x - n, f = a.toX + m, c = m = g ? a.y - l / 2 : a.toY + l / 2); b = b.path({ path: ["M", d, c, "L", f, m], stroke: k, "stroke-width": l }, h); this.elements.axisLine = b
}, realtimeUpdateX: function (a) { if (0 < a) { for (var b = this.axisData.plotBands, c = this.min + a, d, f = b.length; f--; ) (d = b[f]) && !d.isNumVDIV && (d.value < c || d.from < c || d.to < c ? b.splice(f, 1) : (void 0 !== d.value && (d.value -= a), void 0 !== d.from && (d.from -= a), void 0 !== d.to && (d.to -= a))); this.drawPlotLine(); this.drawPlotBands() } }, realtimeUpdateY: function (a,
b) { var c = this.axisData, d = this.min = c.min = a, c = this.span = (this.max = c.max = b) - d, c = this.pixelRatio = this.isVertical ? this.relatedObj.canvasObj.h / c : this.relatedObj.canvasObj.w / c; this.pixelValueRatio = this.isReverse ? -c : c; this.drawPlotLine(); this.drawPlotBands() } 
}; d.prototype.constructor = d; c("renderer.cartesian", { drawCanvas: function () {
    var a = this.options.chart || {}, b = a.plotBackgroundColor, c = this.paper, d = this.elements, f = d.canvas, g = d.canvas3DBase, h = d.canvas3dbaseline, g = d.canvasBorder, k = d.canvasBg, l = this.canvasTop,
m = this.canvasLeft, n = this.canvasWidth, s = this.canvasHeight, t = C(a.plotBorderRadius, 0), k = a.plotBorderWidth, u = 0.5 * k, w = a.plotBorderColor, z = a.isBar, B = a.is3D, E = a.use3DLighting, I = a.showCanvasBg, G = a.canvasBgDepth, J = a.showCanvasBase, H = a.canvasBaseColor3D, M = a.canvasBaseDepth, K = a.plotShadow, Q = N && 0 === k && K && K.enabled, S = a.xDepth || 0, a = a.yDepth || 0, p = this.layers, v = p.background, A = p.dataset; p.tracker = p.tracker || c.group("hot").insertAfter(A); p.datalabels = p.datalabels || c.group("datalabels").insertAfter(A); p = p.canvas = p.canvas ||
c.group("canvas").insertAfter(v); g || (d.canvasBorder = c.rect({ x: m - u, y: l - u, width: n + k, height: s + k, r: t, "stroke-width": k, stroke: w, "stroke-linejoin": 2 < k ? "round" : "miter" }, p).shadow(K)); d["clip-canvas"] = [qa(0, m - S), qa(0, l - a), qa(1, n + 2 * S), qa(1, s + 2 * a)]; d["clip-canvas-init"] = [qa(0, m - S), qa(0, l - a), 1, qa(1, s + 2 * a)]; B && (I && (k = z ? d.canvasBg = c.path(["M", m, ",", l, "L", m + 1.2 * G, ",", l - G, ",", m + n - G, ",", l - G, ",", m + n, ",", l, "Z"], p) : d.canvasBg = c.path(["M", m + n, ",", l, "L", m + n + G, ",", l + 1.2 * G, ",", m + n + G, ",", l + s - G, ",", m + n, ",", l + s, "Z"], p), k.attr({ "stroke-width": 0,
    stroke: "none", fill: V(b)
})), J && (g = z ? d.canvas3DBase = c.cubepath(m - S - M - 1, l + a + 1, M, s, S + 1, a + 1, p) : d.canvas3DBase = c.cubepath(m - S - 1, l + s + a + 1, n, M, S + 1, a + 1, p), g.attr({ stroke: "none", "stroke-width": 0, fill: [H.replace(Xa, ga), !E] }), h || (h = d.canvas3dbaseline = c.path(void 0, p)), h.attr({ path: z ? ["M", m, l, "V", s + l] : ["M", m, l + s, "H", n + m], stroke: P.tintshade(H.replace(Xa, ga), 0.05).rgba }))); !f && b && (d.canvas = c.rect({ x: m, y: l, width: n, height: s, r: t, "stroke-width": 0, stroke: "none", fill: V(b) }, p).shadow(Q))
}, drawAxes: function () {
    var a = this.logic,
b = this.options, c = this.paper, f = this.layers, g = f.dataset, h = f.layerBelowDataset = f.layerBelowDataset || c.group("axisbottom").trackTooltip(!0), k = f.layerAboveDataset = f.layerAboveDataset || c.group("axistop").trackTooltip(!0), c = this.xAxis = [], f = this.yAxis = []; h.insertBefore(g); k.insertAfter(g); if (b.xAxis && b.xAxis.length) for (g = 0, h = b.xAxis.length; g < h; g += 1) c[g] = this.xAxis[g] = new d(b.xAxis[g], this, a.isBar); else c[0] = this.xAxis[0] = new d(b.xAxis, this, a.isBar); if (b.yAxis) for (g = 0, h = b.yAxis.length; g < h; g += 1) f[g] = this.yAxis[g] =
new d(b.yAxis[g], this, !a.isBar, !a.isBar); g = 0; for (h = f.length; g < h; g += 1) f[g].axisData && (f[g].axisData.title && (f[g].axisData.title.className = "fusioncharts-yaxis-" + g + "-title"), f[g].axisData.labels && (f[g].axisData.labels.className = "fusioncharts-yaxis-" + g + "-gridlabels")), f[g].draw(); g = 0; for (h = c.length; g < h; g += 1) c[g].axisData && (c[g].axisData.title && (c[g].axisData.title.className = "fusioncharts-xaxis-" + g + "-title"), c[g].axisData.labels && (c[g].axisData.labels.className = "fusioncharts-xaxis-" + g + "-gridlabels")),
c[g].draw()
}, drawScroller: function () {
    var a = this, b = a.options, c = a.paper, d = a.layers, f = a.xAxis["0"] || {}, g = f.axisData || {}, h = g.scroll || {}, k = a.canvasTop, l = a.canvasLeft, n = a.canvasWidth, s = a.canvasHeight, t = a.canvasBorderWidth, w = t || (g.showLine ? g.lineThickness : 0), z = t || g.lineStartExtension, g = t || g.lineEndExtension, t = b.chart.useRoundEdges, B, E, I, G, J, H, M, K, N, Q, S, V, p, v, A, F = d.dataset, e = d.datalabels, Z = d.tracker; G = d.layerAboveDataset; var O, R; h.enabled && (O = d.scroll = d.scroll || c.group("scroll").insertAfter(G), G = h.scrollRatio,
b = C(b[da].xAxisScrollPos, h.startPercent), J = h.viewPortMax, H = h.viewPortMin, E = h.vxLength, M = Fa(E), K = h.buttonWidth, N = h.height, Q = h.padding, S = h.color, V = h.flatScrollBars, E = h.windowedCanvasWidth = f.getAxisPosition(E), B = h.fullCanvasWidth = f.getAxisPosition(J - H) - E, I = fa(b * B), p = a.fusionCharts.jsVars._reflowData, v = { hcJSON: { _FCconf: { xAxisScrollPos: 0}} }, A = v.hcJSON._FCconf, d.scroller = c.scroller(l - z, k + s + w + Q - !!w, n + z + g, N, !0, { showButtons: !0, displayStyleFlat: V, buttonWidth: K, scrollRatio: G, scrollPosition: b }, O).data("fullCanvasWidth",
B).data("windowedCanvasWidth", E).attr({ "scroll-display-style": V, fill: S, r: t && 2 || 0 }).scroll(function (b) { var c; I = -fa(b * B); F && F.transform(["T", I, 0]); e && e.transform(["T", I, 0]); Z && Z.transform(["T", I, 0]); f.setOffset && f.setOffset(I); c = { position: b, direction: b - h.lastPos || 0, vxLength: M }; A.xAxisScrollPos = h.lastPos = b; m(p, v, !0); if (0 !== c.direction) for (R = 0; R < a.datasets.length; R++) a[a.datasets[R].drawPlot + "Scroll"] && a[a.datasets[R].drawPlot + "Scroll"].call(a, a.plots[R], a.datasets[R], c) }), function () {
    var b; P.eve.on("raphael.scroll.start." +
d.scroller.id, function (c) { b = c; u.raiseEvent("scrollstart", { scrollPosition: c }, a.logic.chartInstance) }); P.eve.on("raphael.scroll.end." + d.scroller.id, function (c) { u.raiseEvent("scrollend", { prevScrollPosition: b, scrollPosition: c }, a.logic.chartInstance) })
} ()); return h.enabled
}, finalizeScrollPlots: function () {
    var a = this, c = a.container, d = a.elements, f = a.layers, g = f.scroller, k = f.dataset, l = f.datalabels, f = f.tracker, m, n = {}, s, t = a.xAxis["0"] || {}, w = (t.axisData || {}).scroll || {}, B = C(a.options[da].xAxisScrollPos, w.startPercent),
E = w.fullCanvasWidth; w.enabled && (k.attr({ "clip-rect": d["clip-canvas"] }), l.attr({ "clip-rect": d["clip-canvas"] }), f.attr({ "clip-rect": d["clip-canvas"] }), d = function (c) {
    var d = a.elements.canvas, f = m.left, k = m.top, r = c.state, l = K && b.getTouchEvent(c) || h; c = c.originalEvent; f = (c.clientX || c.pageX || l.pageX) - f; k = (c.clientY || c.pageY || l.pageY) - k; switch (r) {
        case "start": s = d.isPointInside(f, k); n.ox = s && f || null; if (!s) return !1; n.prevScrollPosition = g.attrs["scroll-position"]; u.raiseEvent("scrollstart", { scrollPosition: n.prevScrollPosition },
a.logic.chartInstance); break; case "end": u.raiseEvent("scrollend", { prevScrollPosition: n.prevScrollPosition, scrollPosition: n.scrollPosition }, a.logic.chartInstance); s = !1; n = {}; break; default: if (!s) break; d = f - n.ox; n.ox = f; n.scrollPosition = g.attrs["scroll-position"] - d / E; g.attr({ "scroll-position": n.scrollPosition })
    } 
}, K && (m = b.getPosition(c), c && (M(c, "pointerdrag", d), z(c, "pointerdrag", d))), 0 < B && (c = -fa(B * E), k && k.transform(["T", c, 0]), l && l.transform(["T", c, 0]), f && f.transform(["T", c, 0]), t.setOffset && t.setOffset(c)))
},
    drawPlotColumn: function (a, b, c) {
        var d = this, f = a.data, h = f.length, k = a.items, l = a.graphics || (a.graphics = []), m = d.paper, n = d.smartLabel, t = d.logic, u = d.layers, w = d.options, z = d.elements, B = w.chart, E = !1 !== (w.tooltip || {}).enabled, I, G = d.definition.chart, J = w.plotOptions.series, H = J.dataLabels.style, M = d.xAxis[b.xAxis || 0], K = d.yAxis[b.yAxis || 0], N = d.chartWidth, Q = d.chartHeight, X = K.axisData.reversed, ba = t.isLog, p = t.is3D, v = t.isStacked, A = t.isWaterfall, F = t.isCandleStick, e = $(M.axisData.scroll, {}), Z = c || {}, O = e.enabled, R = C(Z.position,
w[da].xAxisScrollPos, e.startPercent), W = Z.vxLength || Fa(e.vxLength), ca = Z.scrollStart || qa(0, fa((h - W) * R) - 1) || 0, la = Z.scrollEnd || Ca(h, ca + W + 2) || h, ha = B.canvasBorderOpacity = P.color(B.plotBorderColor).opacity, ma = d.canvasBorderWidth, Ea = B.isCanvasBorder = 0 !== ha && 0 < ma, ga, fb = c !== za ? 0 : isNaN(+J.animation) && J.animation.duration || 1E3 * J.animation, ja = b.numColumns || 1, Ba = b.columnPosition || 0, ua = B.use3DLighting, Zb = !1 === b.visible ? "hidden" : "visible", xa = B.overlapColumns, Ga = M.getAxisPosition(0), Y = M.getAxisPosition(1) - Ga, Pa = G &&
G.plotspacepercent, ea = C(G && G.plotpaddingpercent), Xa = J.groupPadding, db = J.maxColWidth, Jc = (1 - 0.01 * Pa) * Y || Ca(Y * (1 - 2 * Xa), db * ja), bb = Jc / 2, jc = Jc / ja, Cc = Ca(jc - 1, 1 < ja ? xa || ea !== za ? 0 < ea ? jc * ea / 100 : 0 : 4 : 0), Ra = Ba * jc - bb + Cc / 2, gb = K.max, Na = K.min, tb = 0 < gb && 0 <= Na, ob = 0 >= gb && 0 > Na, Ma = 0 < gb && 0 > Na, Qa = ob || X && tb ? gb : ba || tb ? Na : 0, pc = K.yBasePos = K.getAxisPosition(Qa), mb, rc = C(B.useRoundEdges, 0), sb = u.dataset = u.dataset || m.group("dataset-orphan"), Wa = u.datalabels = u.datalabels || m.group("datalabels").insertAfter(sb), Kc = u.tracker, Lb = d.canvasTop,
qb = d.canvasLeft, Fb = d.canvasWidth, wb = d.canvasBottom, yc = d.canvasRight, qc, yb, dc, hb, Kb, ec, Ob, Ta, lb, ic, zb, kc, xb, Ub, rb, Ja, lc, zc, oa, Oa, Db, Rb, eb, Gc, La, ub, vb, tc, nb, Vb, Ib, Ia, Xb, uc, Mb, Nb, Yb, Jb = function (a) { S.call(this, d, a) }, Wb = function (a, b) { return function (c) { a.attr(b); S.call(this, d, c, "DataPlotRollOver") } }, Gb = function (a, b) { return function (c) { a.attr(b); S.call(this, d, c, "DataPlotRollOut") } }; d.addCSSDefinition(".fusioncharts-datalabels .fusioncharts-label", { fontFamily: H.fontFamily, fontSize: H.fontSize, lineHeight: H.lineHeight,
    fontWeight: H.fontWeight, fontStyle: H.fontStyle, color: H.color
}); Wa.attr("class", "fusioncharts-datalabels"); fb && (!c && Wa.attr({ transform: "...t" + N + "," + Q }), d.animationCompleteQueue.push({ fn: function () { Wa.attr({ transform: "...t" + -N + "," + -Q }) }, scope: d })); jc -= Cc; O && ca > la - W - 2 && (ca = qa(0, la - W - 2)); v && (uc = sb.shadows || (sb.shadows = m.group("shadows", sb).toBack())); vb = sb.column || (sb.column = m.group("columns", sb)); F || p || O || vb.attrs["clip-rect"] || vb.attr({ "clip-rect": z["clip-canvas"] }); A && vb.toBack(); if (p) for (dc = B.xDepth ||
0, hb = B.yDepth || 0, tc = vb.negative = vb.negative || m.group("negative-values", vb), Ib = vb.column = vb.column || m.group("positive-values", vb), Vb = vb.zeroPlane, !Vb && 0 > Na && 0 <= gb && (Vb = vb.zeroPlane = m.group("zero-plane", vb).insertBefore(Ib), yb = B.zeroPlaneColor, z.zeroplane = m.cubepath(qb - dc, pc + hb, Fb, 1, dc, hb, Vb).attr({ fill: [yb, !ua], stroke: "none", "stroke-width": 1 })), (nb = tc.data("categoryplots")) || (tc.data("categoryplots", Array(h)), nb = tc.data("categoryplots")), (Ia = Ib.data("categoryplots")) || (Ib.data("categoryplots", Array(h)),
Ia = Ib.data("categoryplots")), Ta = 0; Ta < h; Ta += 1) nb[Ta] = nb[Ta] || m.group(tc), Ia[Ta] = Ia[Ta] || m.group(Ib); else Xb = vb; n.setStyle({ fontFamily: H.fontFamily, fontSize: H.fontSize, lineHeight: H.lineHeight, fontWeight: H.fontWeight, fontStyle: H.fontStyle }); for (Ta = ca; Ta < la; Ta += 1) {
            lb = f[Ta]; xb = lb.y; I = lb.toolText; qc = a.index + "_" + Ta; La = ub = null; if (null === xb) { if (Ob = k[Ta]) La = Ob.graphic, p || La.attr({ height: 0 }) } else {
                Kb = !1; kc = C(lb.x, Ta); ic = lb.link; zb = s(lb.borderWidth) || 0; Gc = lb._FCW * Y; rb = M.getAxisPosition(lb._FCX) || M.getAxisPosition(kc) +
Ra; Ub = lb.previousY; lc = K.getAxisPosition(Ub || Qa); Ja = K.getAxisPosition(xb + (Ub || 0)); oa = Ya(Ja - lc); Oa = Gc || jc; Yb = { index: Ta, link: ic, value: lb.y, displayValue: lb.displayValue, categoryLabel: lb.categoryLabel, toolText: lb.toolText, id: a.userID, datasetIndex: a.index, datasetName: a.name, visible: a.visible }; if (p) {
                    0 > xb && (Ja = lc, Kb = !0); Xb = 0 > xb ? nb : Ia; (Ob = k[Ta]) || (Ob = k[Ta] = { index: Ta, value: xb, graphic: m.cubepath(Xb[Ta]), dataLabel: null, tracker: null, hot: null }); La = Ob.graphic; Rb = eb = {}; lb.hoverEffects && (Rb = { fill: [V(lb.color), !ua],
                        stroke: zb && V(lb.borderColor) || "NONE", "stroke-width": zb
                    }, Db = lb.rolloverProperties, eb = { fill: [V(Db.color), !ua], stroke: Db.borderWidth && V(Db.borderColor) || "NONE", "stroke-width": Db.borderWidth }); La.attr({ cubepath: [rb - dc, fb ? pc + hb : Ja + hb, Oa, fb ? 0 : oa, dc, hb], fill: [V(lb.color), !ua], stroke: zb && V(lb.borderColor) || "NONE", "stroke-width": zb, visibility: Zb }).shadow(J.shadow && lb.shadow, uc).data("BBox", { height: oa, width: Oa, x: rb, y: Ja }); fb && La.animate({ cubepath: [rb - dc, Ja + hb, Oa, oa, dc, hb] }, fb, "normal", d.getAnimationCompleteFn());
                    if (ic || E) !v && oa < aa && (Ja -= (aa - oa) / 2, oa = aa), Ob.tracker || (Ob.tracker = m.cubepath(Kc)), ub = Ob.tracker, ub.attr({ cubepath: [rb - dc, Ja + hb, Oa, oa, dc, hb], cursor: ic ? "pointer" : "", stroke: zb && g || "NONE", "stroke-width": zb, fill: g, ishot: !0, visibility: Zb }); (ub || La).data("eventArgs", Yb).data("groupId", qc).click(Jb).hover(Wb(La, eb), Gb(La, Rb)).tooltip(I); (ub || La)._.cubetop.data("eventArgs", Yb).data("groupId", qc).click(Jb).hover(Wb(La, eb), Gb(La, Rb)).tooltip(I); (ub || La)._.cubeside.data("eventArgs", Yb).data("groupId", qc).click(Jb).hover(Wb(La,
eb), Gb(La, Rb)).tooltip(I); v && Kb && (La.toBack(), ub && ub.toBack())
                } else {
                    ec = !1; if (!ba && !X && 0 > xb || !ba && X && 0 < xb) Ja = lc, ec = !0; X && !Ma && 0 < xb && (Ja = lc - oa, ec = !1); A && 0 > xb && Aa(Ub) && (Ja -= oa, ec = !0); F || O || (sa(Ja) <= Lb && (oa -= Lb - Ja - +Ea, Ja = Lb - +Ea), fa(Ja + oa) >= wb && (oa -= fa(Ja + oa) - wb + +!!zb + +Ea, B.xAxisLineVisible && !Ea && (oa += 1)), 1 >= zb && (fa(rb) <= qb && (Oa += rb, rb = qb - zb / 2 + +!!zb - +Ea, Oa -= rb), fa(rb + Oa) >= yc && (Oa = yc - rb + zb / 2 - +!!zb + +Ea))); Mb = P.crispBound(rb, Ja, Oa, oa, zb); rb = Mb.x; Ja = Mb.y; Oa = Mb.width; oa = Mb.height; if (!F && Ea && (!Aa(Ub) || A &&
Ub === xb && xb === lb._FCY)) if (ob && !X) ga = Ja - (Lb - zb / 2), oa += ga, pc = Ja -= ga; else if (ba || tb || X && ob) oa = wb - Ja + zb / 2, pc = Ja + oa; A && Ub && 0 < zb && 0 !== J.connectorOpacity && 1 === J.connectorWidth && J.connectorDashStyle && (oa -= 1, 0 > xb && (Ja += 1)); 1 >= oa && (oa = 1, Ja += 0 > xb ? 0 : -oa); b._columnWidth = Oa; if (!(Ob = k[Ta])) {
                        Ob = k[Ta] = { index: Ta, value: xb, width: Oa, graphic: null, valueBelowPlot: ec, dataLabel: null, tracker: null }; mb = 0; fb || (pc = Ja, mb = oa || 1); Rb = eb = {}; lb.hoverEffects && (Rb = { fill: V(lb.color), stroke: V(lb.borderColor), "stroke-width": zb, "stroke-dasharray": lb.dashStyle },
Db = lb.rolloverProperties, eb = { fill: V(Db.color), stroke: V(Db.borderColor), "stroke-width": Db.borderWidth, "stroke-dasharray": Db.dashStyle }); Nb = { x: rb, y: pc, width: Oa, height: mb, r: rc, fill: V(lb.color), stroke: V(lb.borderColor), "stroke-width": zb, "stroke-dasharray": lb.dashStyle, "stroke-linejoin": "miter", visibility: Zb }; La ? La.attr(Nb) : La = Ob.graphic = m.rect(Nb, Xb); La.shadow(J.shadow && lb.shadow, uc).data("BBox", Mb); fb && La.animate({ y: Ja, height: oa || 1 }, fb, "normal", d.getAnimationCompleteFn()); if (ic || E) !v && oa < aa && (Ja -= (aa -
oa) / 2, oa = aa), Nb = { x: rb, y: Ja, width: Oa, height: oa, r: rc, cursor: ic ? "pointer" : "", stroke: g, "stroke-width": zb, fill: g, ishot: !0, visibility: Zb }, (ub = Ob.tracker) ? ub.attr(Nb) : ub = Ob.tracker = m.rect(Nb, Kc); ub = Ob.tracker; (ub || La).data("eventArgs", Yb).data("groupId", qc).click(Jb).hover(Wb(La, eb), Gb(La, Rb)).tooltip(I)
                    } 
                } zc = d.drawPlotColumnLabel(a, b, Ta, rb, Ja)
            } zc && l.push(zc); La && l.push(La); ub && l.push(ub); d.drawTracker && d.drawTracker.call(d, a, b, Ta)
        } a.visible = !1 !== b.visible; return a
    }, drawPlotColumnScroll: function (a, b, c) {
        var d =
a.data.length, f = a.items, g; g = c.vxLength; var h = qa(0, fa((d - g) * c.position) - 1) || 0, d = Ca(d, h + g + 2) || d; h > d - g - 2 && (h = qa(0, d - g - 2)); c.scrollEnd = d; for (g = h; g < d; g++) if (!f[g]) { c.scrollStart = g; this.drawPlotColumn(a, b, c); break } 
    }, drawPlotColumnLabel: function (a, b, c, d, f, g) {
        var h = this.options, k = this.logic, l = h.chart; d = this.paper; var m = this.smartLabel, n = this.layers, h = h.plotOptions.series.dataLabels.style, s = 1 === l.rotateValues ? 270 : 0, u = this.canvasHeight, w = this.canvasTop, z = a.data[c]; a = a.items[c]; var C = l.valuePadding + 2, B = a.graphic;
        c = a.dataLabel; var E = $(a.valueBelowPlot, 0 > z.y), I = k.isStacked, k = k.is3D, G = l.xDepth || 0, J = l.yDepth || 0, H = z.displayValue; b = !1 === b.visible ? "hidden" : "visible"; var l = l.placeValuesInside, M; g = g || n.datalabels; Aa(H) && H !== t && null !== z.y ? (a._state && a._state.labelWidth || (m = m.getOriSize(H), a._state = s ? { labelWidth: m.height, labelHeight: m.width} : { labelWidth: m.width, labelHeight: m.height }), B = B.data("BBox"), m = B.height, n = M = a._state.labelHeight + C, C = 0.5 * M + C, B = B.x + 0.5 * B.width, u = E ? w + u - (f + m) : f - w, I ? (f = f + 0.5 * m + (J || 0), B -= G) : l ? m >= n ?
(f += E ? m - C : C, z._valueBelowPoint = 1, k && (B -= G, f += J)) : u >= n ? (f += E ? m + C : -C, k && E && (B -= G, f += J)) : (f += E ? m - C : C, z._valueBelowPoint = 1, k && (B -= G, f += J)) : u >= n ? (f += E ? m + C : -C, k && (E ? (B -= G, f += J) : B -= G / 2)) : (f += E ? m - C : C, z._valueBelowPoint = 1, k && (B -= G, f += J)), c ? c.attr({ x: B, y: f, visibility: b }) : c = a.dataLabel = d.text({ text: H, "class": "fusioncharts-label", x: B, y: f, fill: h.color, "font-size": h.fontSize, visibility: b, "line-height": h.lineHeight }, g).attr("text-bound", [h.backgroundColor, h.borderColor, h.borderThickness, h.borderPadding, h.borderRadius,
h.borderDash]), s && c.attr("transform", "T0,0,R" + s)) : c && c.attr({ text: t }); return c
    }, drawPlotFloatedcolumn: function (a, b) { this.drawPlotColumn.call(this, a, b) }, drawPlotColumn3d: function (a, b) { this.drawPlotColumn.call(this, a, b) }, drawPlotBar: function (a, b) {
        var c = this, d = a.data, f = d.length, h = a.items, k = a.graphics = [], l = c.paper, m = c.logic, n = c.layers, t = c.options, u = c.elements, w = t.chart, z = !1 !== (t.tooltip || {}).enabled, B, E = c.definition.chart, t = t.plotOptions.series, G = t.dataLabels.style, I = { fontFamily: G.fontFamily, fontSize: G.fontSize,
            lineHeight: G.lineHeight, fontWeight: G.fontWeight, fontStyle: G.fontStyle
        }, G = c.xAxis[b.xAxis || 0], J = c.yAxis[b.yAxis || 0], H = m.is3D, m = m.isStacked, M = w.canvasBorderOpacity = P.color(w.plotBorderColor).opacity, K = c.canvasBorderWidth, M = w.isCanvasBorder = 0 !== M && 0 < K, K = isNaN(+t.animation) && t.animation.duration || 1E3 * t.animation, N = b.numColumns || 1, Q = b.columnPosition || 0, X = w.use3DLighting, ba = !1 === b.visible ? "hidden" : "visible", p = w.overlapColumns, v = G.getAxisPosition(0), v = G.getAxisPosition(1) - v, A = E && E.plotspacepercent, E = C(E &&
E.plotpaddingpercent), F = t.groupPadding, e = t.maxColWidth, A = (1 - 0.01 * A) * v || Ca(v * (1 - 2 * F), e * N), v = A / 2, A = A / N, p = Ca(A - 1, 1 < N ? p || E !== za ? 0 < E ? A * E / 100 : 0 : 4 : 0), N = A - p, Q = Q * A - v + p / 2, Z = J.max, O = J.min, p = J.getAxisPosition(0 > Z && 0 > O ? Z : 0 < Z && 0 < O ? O : 0), E = C(w.useRoundEdges, 0), R = c.canvasTop, v = c.canvasLeft, W = c.canvasHeight, A = c.canvasRight, $ = c.chartWidth, ca = c.chartHeight, da, la, Ea, ha, fb, ma, ga, ja, qa, ua, F = J.axisData.effectiveZeroPlaneThickness; ja = n.dataset = n.dataset || l.group("dataset-orphan"); var Ba = n.datalabels = n.datalabels || l.group("datalabels").insertAfter(ja),
n = n.tracker, Y, Aa, ea, xa, Ga, Fa, e = function (a) { S.call(this, c, a) }, Pa = function (a, b) { return function (d) { a.attr(b); S.call(this, c, d, "DataPlotRollOver") } }, Xa = function (a, b) { return function (d) { a.attr(b); S.call(this, c, d, "DataPlotRollOut") } }; c.addCSSDefinition(".fusioncharts-datalabels .fusioncharts-label", I); Ba.attr("class", "fusioncharts-datalabels"); K && (c.animationCompleteQueue.push({ fn: function () { Ba.attr({ transform: "...t" + -$ + "," + -ca }) }, scope: c }), Ba.attr({ transform: "...t" + $ + "," + ca })); m && (Ga = ja.shadows || (ja.shadows =
l.group("shadows", ja).toBack())); ga = ja.column = ja.column || l.group("bars", ja); if (H) for (da = w.xDepth || 0, la = w.yDepth || 0, I = ga.negative = ga.negative || l.group("negative-values", ga), ja = ga.column = ga.column || l.group("positive-values", ga), ea = ga.zeroPlane, !ea && 0 > O && 0 <= Z && (ea = ga.zeroPlane = l.group("zero-plane", ga).insertBefore(ja), ua = w.zeroPlaneColor, u.zeroplane = l.cubepath(p - da, R + la, 1, W, da, la, ea).attr({ fill: [ua, !X], stroke: "none", "stroke-width": 0 })), (ea = I.data("categoryplots")) || (I.data("categoryplots", Array(f)),
ea = I.data("categoryplots")), (ua = ja.data("categoryplots")) || (ja.data("categoryplots", Array(f)), ua = ja.data("categoryplots")), u = 0; u < f; u += 1) ea[u] = ea[u] || l.group(I), ua[u] = ua[u] || l.group(ja); else ga.attrs["clip-rect"] || ga.attr({ "clip-rect": u["clip-canvas"] }), xa = ga; u = 0; for (I = f - 1; u < f; u += 1, I -= 1) {
            R = d[u]; ja = R.y; Y = W = null; if (null === ja) { if (ma = h[u]) Y = ma.graphic, H || Y.attr({ width: 0 }) } else {
                ga = C(R.x, u); Z = R.link; B = R.toolText; O = s(R.borderWidth) || 0; ga = G.getAxisPosition(ga) + Q; ma = (Ea = R.previousY) ? J.getAxisPosition(Ea) : p;
                qa = J.getAxisPosition(ja + (Ea || 0)); Ea = Ya(qa - ma); 0 < ja && (qa = ma); Aa = { index: u, link: Z, value: R.y, displayValue: R.displayValue, categoryLabel: R.categoryLabel, toolText: R.toolText, id: a.userID, datasetIndex: a.index, datasetName: a.name, visible: a.visible }; if (H) {
                    xa = 0 > ja ? ea : ua; (ma = h[u]) || (ma = h[u] = { index: u, value: ja, graphic: l.cubepath(xa[I]), dataLabel: null, tracker: null }); Y = ma.graphic; fb = ha = {}; R.hoverEffects && (fb = { fill: [V(R.color), !X], stroke: O && V(R.borderColor) || "NONE", "stroke-width": O }, ha = R.rolloverProperties, ha = { fill: [V(ha.color),
!X], stroke: ha.borderWidth && V(ha.borderColor) || "NONE", "stroke-width": ha.borderWidth
                    }); Y.attr({ cubepath: [K ? p - da : qa - da, ga + la, K ? 0 : Ea, N, da, la], fill: [V(R.color), !X], stroke: O && V(R.borderColor) || "NONE", "stroke-width": O, "stroke-dasharray": R.dashStyle, cursor: Z ? "pointer" : "", visibility: ba }).shadow(t.shadow && R.shadow, Ga).data("BBox", { height: N, width: Ea, x: qa, y: ga }); K && Y.animate({ cubepath: [qa - da, ga + la, Ea, N, da, la] }, K, "normal", c.getAnimationCompleteFn()); if (Z || z) !m && Ea < aa && (qa -= (aa - Ea) / 2, Ea = aa), ma.tracker || (ma.tracker =
l.cubepath(n)), W = ma.tracker, W.attr({ cubepath: [qa - da, ga + la, Ea, N, da, la], cursor: Z ? "pointer" : "", stroke: O && g || "NONE", "stroke-width": O, fill: g, ishot: !0 }); (W || Y).data("eventArgs", Aa).click(e).hover(Pa(Y, ha), Xa(Y, fb)).tooltip(B); (W || Y)._.cubetop.data("eventArgs", Aa).click(e).hover(Pa(Y, ha), Xa(Y, fb)); (W || Y)._.cubeside.data("eventArgs", Aa).click(e).hover(Pa(Y, ha), Xa(Y, fb)); if (!m || m && 0 > ja) Y.toBack(), W && W.toBack()
                } else {
                    sa(qa) <= v && (Ea += qa, qa = v + O / 2 + 0.2, w.xAxisLineVisible && !M && (qa -= 1), Ea -= qa); fa(qa + Ea) >= A && (Ea = A -
qa - O / 2 - 0.2); Fa = P.crispBound(qa, ga, Ea, N, O); qa = Fa.x; ga = Fa.y; Ea = Fa.width; N = Fa.height; 1 >= Ea && (Ea = 1, qa += 0 > ja ? -Ea : 1 < F ? Ea : 0); (ma = h[u]) || (ma = h[u] = { index: u, value: ja, height: N, graphic: null, dataLabel: null, tracker: null }); Y = ma.graphic; fb = ha = {}; R.hoverEffects && (fb = { fill: V(R.color), stroke: V(R.borderColor), "stroke-width": O, "stroke-dasharray": R.dashStyle }, ha = R.rolloverProperties, ha = { fill: V(ha.color), stroke: V(ha.borderColor), "stroke-width": ha.borderWidth, "stroke-dasharray": ha.dashStyle }); ja = { x: K ? p : qa, y: ga, width: K ? 0 :
Ea || 1, height: N, r: E, fill: V(R.color), stroke: V(R.borderColor), "stroke-width": O, "stroke-dasharray": R.dashStyle, "stroke-linejoin": "miter", cursor: Z ? "pointer" : "", visibility: ba
}; Y ? Y.attr(ja) : Y = ma.graphic = l.rect(ja, xa); Y.shadow(t.shadow && R.shadow, Ga).data("BBox", Fa); K && Y.animate({ x: qa, width: Ea || 1 }, K, "normal", c.getAnimationCompleteFn()); if (Z || z) !m && Ea < aa && (qa -= (aa - Ea) / 2, Ea = aa), W = ma.tracker, ja = { x: qa, y: ga, width: Ea, height: N, r: E, cursor: Z ? "pointer" : "", stroke: g, "stroke-width": O, fill: g, ishot: !0 }, W ? W.attr(ja) : W = ma.tracker =
l.rect(ja, n), W.data("eventArgs", Aa); (W || Y).data("eventArgs", Aa).click(e).hover(Pa(Y, ha), Xa(Y, fb)).tooltip(B)
                } B = c.drawPlotBarLabel(a, b, u, qa, ga)
            } B && k.push(B); Y && k.push(Y); W && k.push(W); c.drawTracker && c.drawTracker.call(c, a, b, u)
        } a.visible = !1 !== b.visible; return a
    }, drawPlotBarLabel: function (a, b, c, d, f, g) {
        var h = this.options, k = this.logic, l = h.chart, m = this.paper, n = this.layers, s = h.plotOptions.series.dataLabels.style, h = this.canvasLeft, u = this.canvasWidth, w = a.data[c], z = a.items[c]; a = l.valuePadding + 2; var B = z.graphic;
        c = z.dataLabel; var C = 0 > w.y, E = k.isStacked, k = k.is3D, G = l.xDepth || 0, I = l.yDepth || 0, J = w.displayValue; b = !1 === b.visible ? "hidden" : "visible"; l = l.placeValuesInside; g = g || n.datalabels; Aa(J) && J !== t && null !== w.y ? (c || (c = z.dataLabel = m.text({ "class": "fusioncharts-label", text: J, "font-size": s.fontSize, "text-anchor": E ? "middle" : C ? l ? "start" : "end" : l ? "end" : "start", title: w.originalText || "", fill: s.color, x: 0, y: 0, "line-height": s.lineHeight }, g).attr("text-bound", [s.backgroundColor, s.borderColor, s.borderThickness, s.borderPadding,
s.borderRadius, s.borderDash])), g = c.getBBox(), m = B.data("BBox"), s = m.height, n = m.width, m = g.width, m += a, f += 0.5 * s, s = d + (C ? 0 : n), d = C ? d - h : h + u - (d + n), E ? (s = s + 0.5 * (C ? n : -n) - (k ? G : 0), f += k ? I : 0) : (l ? n >= m ? (s += C ? a : -a, k && (s -= G, f += I)) : (s += C ? -a : a, k && C && (s -= G)) : d >= m ? (s += C ? -a : a, k && C && (s -= G, f += G)) : (s += C ? a : -a, k && (s -= G, f += I)), s > h + u && (s = h + u - 0.5 * g.width - 4), s < h && (s = h + 0.5 * g.width + 4)), c.attr({ x: s, y: f, visibility: b })) : c && c.attr({ text: t }); return c
    }, drawPlotBar3d: function (a, b) { this.drawPlotBar.call(this, a, b) }, drawPlotLine: function (a, b) {
        var c =
this, d = c.paper, f = c.elements, h = c.options, k = h.chart, l = c.logic, m = h.plotOptions.series, n = a.items, t = a.graphics = a.graphics || [], u, w = c.xAxis[b.xAxis || 0], z = c.yAxis[b.yAxis || 0], E = l.multisetRealtime || l.dragExtended, G = l.isWaterfall, J, H, M, K, N, Q = 0, X = !1 !== (h.tooltip || {}).enabled, W, ba = isNaN(+m.animation) && m.animation.duration || 1E3 * m.animation, $, p = m.dataLabels.style, v = { fontFamily: p.fontFamily, fontSize: p.fontSize, lineHeight: p.lineHeight, fontWeight: p.fontWeight, fontStyle: p.fontStyle }, A = k.xDepth || 0, F = k.yDepth || 0, e = k.series2D3Dshift,
Z = b.step, O = b.drawVerticalJoins, R = b.useForwardSteps, aa = a.data, da = !1 === b.visible ? "hidden" : "visible", ca, ja = aa.length, fa = w.getAxisPosition(0), ga = w.getAxisPosition(1) - fa, ha = ga * ja, la = w.axisData.scroll || {}, ma = k.hasScroll || !1, sa, ua = m.connectNullData, Ba = c.chartWidth, Aa = c.chartHeight, xa = function () { Ja.attr({ "clip-rect": null }); rb.show(); Ub.show(); lc.show(); yc.attr({ transform: "...t" + -Ba + "," + -Aa }) }, Y, za, ea, Fa, Ga, Pa, Xa, Ya = null, Na, Ra, gb = m.connectorWidth = s(b.lineWidth), hb = b.color, db, ob, Ma = m.connectorDashStyle = b.dashStyle,
Qa, bb, tb, mb, sb, Wa, qb, Lb, wb, yb = c.layers, Fb = yb.dataset = yb.dataset || d.group("dataset-orphan"), yc = yb.datalabels = yb.datalabels || d.group("datalabels").insertAfter(Fb), qc = yb.tracker, Kb = f["clip-canvas-init"].slice(0), dc = f["clip-canvas"].slice(0), Nc = z.axisData.reversed, Fc = z.max, ec = z.min, Ob = z.getAxisPosition(0 < Fc && 0 < ec ? Nc ? Fc : ec : 0 > Fc && 0 > ec ? Nc ? ec : Fc : Nc ? Fc : 0) + (e ? F : 0), Ta = [], lb = k.anchorTrackingRadius, ic = /drag/ig.test(c.logic.rendererId), zb, kc, xb, Ub, rb, Ja, lc, zc, oa, Oa, Db, Rb, eb = [], Gc = function (a) { S.call(this, c, a) },
La = function (a) { return function (b) { c.hoverPlotAnchor(this, b, "DataPlotRollOver", a, c) } }, ub = function (a) { return function (b) { c.hoverPlotAnchor(this, b, "DataPlotRollOut", a, c) } }, vb = function (e, f, h, k, l, m, n, p) {
    return function () {
        var s = h.imageUrl, v = h.imageScale, u = h.imageAlpha, w = n.imageHoverAlpha, z = n.imageHoverScale, A = this.height * v * 0.01, C = this.width * v * 0.01, B = this.width * z * 0.01; qb = { x: e - this.width * v * 0.005, y: f - this.height * v * 0.005, width: C, height: A, alpha: u }; Lb = { x: e - this.width * z * 0.005, y: f - this.height * z * 0.005, width: B, height: this.height *
z * 0.01, alpha: w
        }; w = B > C ? Lb : qb; ic && (w = { cx: e, cy: f, r: 0.5 * qa(A, C) }); (k.graphic = mb = d.image(s, lc).attr(qb).css({ opacity: 0.01 * u }).data("alwaysInvisible", !v).data("setRolloverProperties", n).data("setRolloverAttr", Lb).data("setRolloutAttr", qb).data("anchorRadius", v).data("anchorHoverRadius", z)) && t.push(mb); if (za || X || n) sb = k.tracker = (ic ? d.circle(qc) : d.rect(qc)).attr(w).attr({ cursor: za ? "pointer" : "", stroke: g, "stroke-width": h.lineWidth, fill: g, ishot: !0, visibility: da }).data("eventArgs", l).data("groupId", zb).click(Gc).hover(La(k),
ub(k)).tooltip(m); c.drawTracker && c.drawTracker.call(c, a, b, p); (Db = k.dataLabel = c.drawPlotLineLabel(a, b, p, e, f)) && t.push(Db)
    } 
}, tc = function (d, e, f, g, h, k, l, m) { return function () { (Db = g.dataLabel = c.drawPlotLineLabel(a, b, m, d, e)) && t.push(Db) } }; c.addCSSDefinition(".fusioncharts-datalabels .fusioncharts-label", v); yc.attr("class", "fusioncharts-datalabels"); m.connectorOpacity = P.color(hb).opacity; z.yBasePos = Ob; G && (J = (H = c.definition.chart) && H.plotspacepercent, M = m.groupPadding, K = m.maxColWidth, N = (1 - 0.01 * J) * ga || Ca(ga *
(1 - 2 * M), 1 * K), Q = N / 2); yc.attr({ transform: "...t" + Ba + "," + Aa }); ba && c.animationCompleteQueue.push({ fn: xa, scope: c }); xb = Fb.line || (Fb.line = d.group("line-connector", Fb)); Ub = a.lineShadowLayer || (a.lineShadowLayer = d.group("connector-shadow", xb)); rb = a.anchorShadowLayer || (a.anchorShadowLayer = d.group("anchor-shadow", xb)); Ja = a.lineLayer || (a.lineLayer = d.group("connector", xb)); lc = a.anchorLayer || (a.anchorLayer = d.group("anchors", xb)); lc.hide(); Ub.hide(); rb.hide(); for (ca = 0; ca < ja; ca += 1) {
            Y = aa[ca]; Ga = Y.y; Pa = Y.previousY ||
0; W = Y.toolText; zb = a.index + "_" + ca; wb = Db = mb = sb = null; u = n[ca] = { index: ca, value: null, graphic: null, connector: null, dataLabel: null, shadowGroup: rb, tracker: null }; if (null === Ga) eb.length = 0, 0 === ua && (Ya = null); else {
                Fa = C(Y.x, ca); za = Y.link; "boxandwhisker" === b.relatedSeries && b.pointStart && (Fa += b.pointStart); Ra = z.getAxisPosition(Ga + Pa) + (e ? F : 0); Na = w.getAxisPosition(Fa) - A; Na = I(Na, gb, gb).position; Ra = I(Ra, gb, gb).position; if ((Qa = Y.marker) && Qa.enabled) if (bb = Qa.symbol.split("_"), tb = "spoke" === bb[0] ? 1 : 0, ea = Qa.radius, zc = Qa.shadow,
kc = { index: ca, link: za, value: Y.y, displayValue: Y.displayValue, categoryLabel: Y.categoryLabel, toolText: Y.toolText, id: a.userID, datasetIndex: a.index, datasetName: a.name, visible: a.visible }, qb = Lb = {}, Wa = Y.rolloverProperties, Qa.imageUrl) Rb = new B, Rb.onload = vb(Na, Ra, Qa, u, kc, W, Wa, ca), Rb.onerror = tc(Na, Ra, Qa, u, kc, W, Wa, ca), Rb.src = Qa.imageUrl; else {
                    Wa && (qb = { polypath: [bb[1] || 2, Na, Ra, ea, Qa.startAngle, tb], fill: V(Qa.fillColor), "stroke-width": Qa.lineWidth, stroke: V(Qa.lineColor) }, Lb = { polypath: [Wa.sides || 2, Na, Ra, Wa.radius,
Wa.startAngle, Wa.dip], fill: V(Wa.fillColor), "stroke-width": Wa.lineWidth, stroke: V(Wa.lineColor)
                    }); mb = u.graphic = d.polypath(bb[1] || 2, Na, Ra, ea, Qa.startAngle, tb, lc).attr({ fill: V(Qa.fillColor), "stroke-width": Qa.lineWidth, stroke: V(Qa.lineColor), cursor: za ? "pointer" : "", visibility: ea ? da : "hidden" }).data("alwaysInvisible", !ea).data("setRolloverProperties", Wa).data("setRolloverAttr", Lb).data("setRolloutAttr", qb).data("anchorRadius", ea).data("anchorHoverRadius", Wa && Wa.radius).shadow(zc || !1, rb); if (za || X || Wa) ea = qa(ea,
Wa && Wa.radius || 0, lb), sb = u.tracker = d.circle({ cx: Na, cy: Ra, r: ea, cursor: za ? "pointer" : "", stroke: g, "stroke-width": Qa.lineWidth, fill: g, ishot: !0, visibility: da }, qc); (sb || mb).data("eventArgs", kc).data("groupId", zb).click(Gc).hover(La(u), ub(u)).tooltip(W); c.drawTracker && c.drawTracker.call(c, a, b, ca)
                } oa = Oa !== [V(Y.color || hb), Y.dashStyle || Ma].join(":"); if (null !== Ya) {
                    if (eb.length && (Ta = Ta.concat(eb), eb.length = 0), (E || G || !Ta.join("")) && Ta.push("M", Xa, Ya), G && Ta.push("m", -Q, 0), Z ? R ? (Ta.push("H", Na), G && Ta.push("h", Q), O ?
Ta.push("V", Ra) : Ta.push("m", 0, Ra - Ya)) : (O && Ta.push("V", Ra), Ta.push("M", Xa, Ra, "H", Na)) : Ta.push("L", Na, Ra), E || oa) wb = u.connector = d.path(Ta, Ja).attr({ "stroke-dasharray": ob, "stroke-width": gb, stroke: db, "stroke-linecap": "round", "stroke-linejoin": 2 < gb ? "round" : "miter", visibility: da }).shadow(m.shadow && Y.shadow, Ub), Ta = []
                } else !E && eb.push("M", Na, Ra); Qa && Qa.imageUrl || (Db = u.dataLabel = c.drawPlotLineLabel(a, b, ca, Na, Ra)); Xa = Na; Ya = Ra; db = V(Y.color || hb); ob = Y.dashStyle || Ma; Oa = [db, ob].join(":")
            } Db && t.push(Db); mb && t.push(mb);
            wb && t.push(wb); sb && t.push(sb)
        } !E && Ta.join("") && (wb = d.path(Ta, Ja).attr({ "stroke-dasharray": ob, "stroke-width": gb, stroke: db, "stroke-linecap": "round", "stroke-linejoin": 2 < gb ? "round" : "miter", visibility: da }).shadow(m.shadow && Y.shadow, Ub)) && t.push(wb); ma && (sa = la.startPercent, dc[2] = ha + Kb[0], 1 === sa && (Kb[0] = dc[2], dc[0] = 0)); ba ? ($ = P.animation({ "clip-rect": dc }, ba, ma ? "easeIn" : "normal", c.getAnimationCompleteFn()), Ja.attr({ "clip-rect": Kb }).animate(G ? $.delay(ba) : $)) : (xa && xa(), xa = void 0); a.visible = !1 !== b.visible; return a
    },
    hoverPlotAnchor: function (a, b, c, d, f) {
        var g = d.graphic; d = d.dataLabel; var h = f.options.chart, k = 1 === h.rotateValues ? 270 : 0, l = g.data("setRolloverProperties"), m = g.data("isRealtime"), n = m && g.attr("polypath"), s = g.data("setRolloverAttr"), t = "image" === g.type, u = g.data("setRolloutAttr"), w = d && (d.data("isBelow") ? 1 : -1) * (t ? 0.5 * (s.height - u.height) : g.data("anchorHoverRadius") - g.data("anchorRadius")), z = "DataPlotRollOver" == c ? s : u, C = { transform: "T0," + ("DataPlotRollOver" === c ? w : 0) + "R" + k }, B = { fill: z.fill, "stroke-width": z["stroke-width"],
            stroke: z.stroke
        }, z = t ? z : { polypath: z.polypath }, h = h.syncLabelWithAnchor, E = g.data("anchorRadius"), G = g.data("anchorHoverRadius"), s = !(/,0\)$/.test(s.fill) && /,0\)$/.test(u.fill)) && g.data("anchorHoverRadius") - g.data("anchorRadius") && l.animation && 50; d && d.data("isMiddle") && (C = { transform: "T," + ("DataPlotRollOver" === c ? w : 0) + ",0R" + k }); l && (("DataPlotRollOver" == c && 0 !== G || "DataPlotRollOut" == c && 0 !== E) && g.attr({ visibility: "visible" }), t ? g.css({ opacity: 0.01 * z.alpha }) : g.attr(B), m && !t && (z.polypath[1] = n[1], z.polypath[2] =
n[2]), g.stop(), g.animate(z, s, "easeOut", function () { ("DataPlotRollOver" == c && !G || "DataPlotRollOut" == c && !E) && g.attr({ visibility: "hidden" }) }), d && d.stop(), s && h && d && d.animate(C, s, "easeOut")); S.call(a, f, b, c)
    }, drawPlotArea: function (a, b) {
        var c = this, d = c.paper, f = c.options, h = f.chart, k = c.logic, l = f.plotOptions.series, n = c.elements, s = a.items, t = a.graphics = a.graphics || [], u, w = c.xAxis[b.xAxis || 0], z = c.yAxis[b.yAxis || 0], E = z.axisData.reversed, G = h.xDepth || 0, I = h.yDepth || 0, k = k.isStacked, J = !1 !== (f.tooltip || {}).enabled, H, M, f =
l.dataLabels.style, K = { fontFamily: f.fontFamily, fontSize: f.fontSize, lineHeight: f.lineHeight, fontWeight: f.fontWeight, fontStyle: f.fontStyle, color: f.color }, f = isNaN(+l.animation) && l.animation.duration || 1E3 * l.animation, N = h.series2D3Dshift, P = "0" === c.definition.chart.drawfullareaborder, Q = a.data, X = !1 === b.visible ? "hidden" : "visible", W = Q.length, p = w.getAxisPosition(0), v = (w.getAxisPosition(1) - p) * W, A = w.axisData.scroll || {}, p = h.hasScroll || !1, F = l.connectNullData, e, Z, O, R, ba, $ = z.max, aa = z.min, ca = z.getAxisPosition(0 < $ &&
0 > aa ? 0 : !E && 0 < $ && 0 <= aa ? aa : $) + (N ? I : 0), da = c.chartWidth, ja = c.chartHeight, E = function () { db.attr({ "clip-rect": null }); Qa.show(); ob.show(); Pa.attr({ transform: "...t" + -da + "," + -ja }) }, ga = null, fa, ha, $ = b.lineWidth, aa = b.dashStyle, ma = V(b.fillColor), la = V(b.lineColor), sa = 0, ua = /drag/ig.test(c.logic.rendererId), Ba, Y, Aa, ea, za, Ca, xa = [], Fa = [], Ga = null, Na = [], Ra = c.layers; R = Ra.dataset = Ra.dataset || d.group("dataset-orphan"); var Pa = Ra.datalabels = Ra.datalabels || d.group("datalabels").insertAfter(R), Xa = Ra.tracker, Ra = n["clip-canvas-init"].slice(0),
n = n["clip-canvas"].slice(0), h = h.anchorTrackingRadius, Ya, ob, Ma, Qa, db, hb, mb, sb, Wa, bb, qb = function (a) { S.call(this, c, a) }, tb = function (a) { return function (b) { c.hoverPlotAnchor(this, b, "DataPlotRollOver", a, c) } }, wb = function (a) { return function (b) { c.hoverPlotAnchor(this, b, "DataPlotRollOut", a, c) } }, Ga = function (e, f, h, k, l, n, p, s) {
    return function () {
        var u = h.imageUrl, v = h.imageScale, w = h.imageAlpha, z = p.imageHoverAlpha, A = p.imageHoverScale, C = this.width * v * 0.01, B = this.width * A * 0.01; za = { x: e - this.width * v * 0.005, y: f - this.height *
v * 0.005, width: C, height: this.height * v * 0.01, alpha: w
        }; Ca = { x: e - this.width * A * 0.005, y: f - this.height * A * 0.005, width: B, height: this.height * A * 0.01, alpha: z }; z = B > C ? Ca : za; ua && (z = { cx: e, cy: f, r: 0.5 * qa(B, C) }); (k.graphic = Y = d.image(u, Qa).attr(za).css({ opacity: 0.01 * w }).data("alwaysInvisible", !v).data("setRolloverProperties", p).data("setRolloverAttr", Ca).data("setRolloutAttr", za).data("anchorRadius", v).data("anchorHoverRadius", A)) && t.push(Y); if (Z || J || p) Ya = m({ cursor: Z ? "pointer" : "", stroke: g, "stroke-width": h.lineWidth, fill: g,
            ishot: !0, visibility: X
        }, z), Aa = k.tracker = (ua ? d.circle(Ya, Xa) : d.rect(Ya, Xa)).data("eventArgs", l).click(qb).hover(tb(k), wb(k)).tooltip(n), c.drawTracker && c.drawTracker.call(c, a, b, s); (bb = k.dataLabel = c.drawPlotLineLabel(a, b, s, e, f)) && t.push(bb)
    } 
}, yb = function (d, e, f, g, h, k, l, m) { return function () { (bb = g.dataLabel = c.drawPlotLineLabel(a, b, m, d, e)) && t.push(bb) } }; c.addCSSDefinition(".fusioncharts-datalabels .fusioncharts-label", K); Pa.attr("class", "fusioncharts-datalabels"); z.yBasePos = ca; Pa.attr({ transform: "...t" + da +
"," + ja
}); f && c.animationCompleteQueue.push({ fn: E, scope: c }); K = R; k && (hb = K.shadows || (K.shadows = d.group("shadows", K).toBack())); db = K.area = K.area || d.group("area", K); K = K.line || (K.line = d.group("line-connector", K)); a.lineShadowLayer || (a.lineShadowLayer = d.group("connector-shadow", K)); ob = a.anchorShadowLayer || (a.anchorShadowLayer = d.group("anchor-shadow", K)); Ma = a.lineLayer || (a.lineLayer = d.group("connector", K)); Qa = a.anchorLayer || (a.anchorLayer = d.group("anchors", K)); Qa.hide(); ob.hide(); K = R; for (K = 0; K < W; K += 1) {
            e = Q[K];
            R = e.y; u = C(e.x, K); fa = w.getAxisPosition(u) - G; Y = bb = Aa = null; u = s[K] = {}; if (null === R) 0 === F && (ga = null, 0 < sa && (1 === sa ? xa.splice(-8, 8) : (xa = xa.concat(Fa), xa.push("Z")), Fa = [])), u.chart = c, u.index = K, u.value = R; else {
                Z = e.link; H = e.toolText; M = e.previousY; ba = (ba = z.getAxisPosition(M) || null) || ca; ha = z.getAxisPosition(R + (M || 0)) + (N ? I : 0); if ((Wa = e.marker) && Wa.enabled) if (M = { index: K, link: Z, value: e.y, displayValue: e.displayValue, categoryLabel: e.categoryLabel, toolText: e.toolText, id: a.userID, datasetIndex: a.index, datasetName: a.name,
                    visible: a.visible
                }, za = Ca = {}, ea = e.rolloverProperties, Wa.imageUrl) O = new B, O.onload = Ga(fa, ha, Wa, u, M, H, ea, K), O.onerror = yb(fa, ha, Wa, u, M, H, ea, K), O.src = Wa.imageUrl; else {
                    Ba = Wa.symbol.split("_"); O = Wa.radius; sb = Wa.shadow; ea && (za = { polypath: [Ba[1] || 2, fa, ha, O, Wa.startAngle, 0], fill: V(Wa.fillColor), "stroke-width": Wa.lineWidth, stroke: V(Wa.lineColor) }, ea = e.rolloverProperties, Ca = { polypath: [ea.sides || 2, fa, ha, ea.radius, ea.startAngle, ea.dip], fill: V(ea.fillColor), "stroke-width": ea.lineWidth, stroke: V(ea.lineColor) }); Y =
u.graphic = d.polypath(Ba[1] || 2, fa, ha, O, Wa.startAngle, 0, Qa).attr({ fill: V(Wa.fillColor), "stroke-width": Wa.lineWidth, stroke: V(Wa.lineColor), cursor: Z ? "pointer" : "", visibility: O ? X : "hidden" }).data("alwaysInvisible", !O).data("setRolloverProperties", ea).data("setRolloverAttr", Ca).data("setRolloutAttr", za).data("anchorRadius", O).data("anchorHoverRadius", ea && ea.radius).shadow(sb || !1, ob); if (Z || J || ea) k || (O = qa(O, ea && ea.radius || 0, h)), Aa = u.tracker = d.circle({ cx: fa, cy: ha, r: O, cursor: Z ? "pointer" : "", stroke: g, "stroke-width": Wa.lineWidth,
    fill: g, ishot: !0, visibility: X
}, Xa); (Aa || Y).data("eventArgs", M).click(qb).hover(tb(u), wb(u)).tooltip(H); c.drawTracker && c.drawTracker.call(c, a, b, K)
                } null === ga ? (Na.push("M", fa, ",", ha), xa.push("M", fa, ",", ba), sa = 0) : Na.push("L", fa, ",", ha); xa.push("L", fa, ",", ha); Fa.unshift("L", fa, ",", ba); sa++; ga = ha; Wa && Wa.imageUrl || (bb = u.dataLabel = c.drawPlotLineLabel(a, b, K, fa, ha)); u.chart = c; u.index = K; u.value = R; u.dataLabel = bb
            } bb && t.push(bb); Y && t.push(Y); Aa && t.push(Aa)
        } 0 < sa && (1 === sa ? xa.splice(-8, 8) : (xa = xa.concat(Fa), xa.push("Z")));
        (Ga = a.graphic = d.path(xa, db).attr({ fill: ma, "stroke-dasharray": aa, "stroke-width": P ? 0 : $, stroke: la, "stroke-linecap": "round", "stroke-linejoin": 2 < $ ? "round" : "miter", visibility: X }).shadow(l.shadow && e.shadow, hb)) && t.push(Ga); p && (l = A.startPercent, n[2] = v + Ra[0], 1 === l && (Ra[0] = n[2], n[0] = 0)); f ? mb = db.attr({ "clip-rect": Ra }).animate({ "clip-rect": n }, f, p ? "easeIn" : "normal", c.getAnimationCompleteFn()) : (E && E(), E = void 0); hb && (f ? hb.attr({ "clip-rect": Ra }).animateWith(db, mb, { "clip-rect": n }, f, p ? "easeIn" : "normal", function () { hb.attr({ "clip-rect": null }) }) :
hb.attr({ "clip-rect": null })); P && (l = a.connector = d.path(Na, Ma).attr({ "stroke-dasharray": aa, "stroke-width": $, stroke: la, "stroke-linecap": "round", "stroke-linejoin": 2 < $ ? "round" : "miter", visibility: X }), f ? Ma.attr({ "clip-rect": Ra }).animateWith(db, mb, { "clip-rect": n }, f, p ? "easeIn" : "normal", function () { Ma.attr({ "clip-rect": null }) }) : Ma.attr({ "clip-rect": null }), l && t.push(l)); a.visible = !1 !== b.visible; return a
    }, drawPlotScatter: function (a, b) {
        var c = this, d = c.options, f = d.chart, h = d.plotOptions.series, k = c.paper, l = c.elements,
m = a.items, n, s = a.graphics = a.graphics || [], t = c.xAxis[b.xAxis || 0], u = c.yAxis[b.yAxis || 0], w = a.data, z = !1 === b.visible ? "hidden" : "visible", d = !1 !== (d.tooltip || {}).enabled, C, B = h.dataLabels.style, E = { fontFamily: B.fontFamily, fontSize: B.fontSize, lineHeight: B.lineHeight, fontWeight: B.fontWeight, fontStyle: B.fontStyle, color: B.color }, B = isNaN(+h.animation) && h.animation.duration || 1E3 * h.animation, G = c.chartWidth, I = c.chartHeight, J, K, H, M, N, P, p, v, A, F = b.lineWidth, e = 0 < F, Q = b.color, O = b.dashStyle, R = h.connectNullData, X = [], W, ba, $,
aa, ca, da, fa = c.layers, ha = fa.dataset || (fa.dataset = k.group("dataset-orphan")), ja = fa.datalabels || (fa.datalabels = k.group("datalabels").insertAfter(ha)), fa = fa.tracker, f = f.anchorTrackingRadius, ga, la, ma, sa = function (a) { S.call(this, c, a) }, Y = function (a) { return function (b) { c.hoverPlotAnchor(this, b, "DataPlotRollOver", a, c) } }, ua = function (a) { return function (b) { c.hoverPlotAnchor(this, b, "DataPlotRollOut", a, c) } }; c.addCSSDefinition(".fusioncharts-datalabels .fusioncharts-label", E); ja.attr("class", "fusioncharts-datalabels");
        B && (c.animationCompleteQueue.push({ fn: function () { ja.attr({ transform: "...t" + -G + "," + -I }) }, scope: c }), ja.attr({ transform: "...t" + G + "," + I })); ga = ha.line || (ha.line = k.group("line-connector", ha)); a.lineShadowLayer = k.group("connector-shadow", ga); ha = a.anchorShadowLayer = k.group("anchor-shadow", ga); E = a.lineLayer = k.group("connector", ga); ga = a.anchorLayer = k.group("anchors", ga); J = 0; for (K = w.length; J < K; J += 1) {
            H = w[J]; W = H.marker; v = A = aa = C = ca = null; ma = a.index + "_" + J; P = H.y; N = H.x; if (null !== P && null !== N) {
                if (W && W.enabled) {
                    M = H.link;
                    C = H.toolText; $ = W.radius; la = W.shadow; A = u.getAxisPosition(P); v = t.getAxisPosition(N); ba = { index: J, link: M, y: H.y, x: H.x, displayValue: H.displayValue, categoryLabel: H.categoryLabel, toolText: H.toolText, id: a.userID, datasetIndex: a.index, datasetName: a.name, visible: a.visible }; aa = W.symbol.split("_"); n = m[J] = { index: J, x: N, y: P, value: P }; N = P = {}; H.hoverEffects && (N = { polypath: [aa[1] || 2, v, A, $, W.startAngle, 0], fill: V(W.fillColor), "stroke-width": W.lineWidth, stroke: V(W.lineColor) }, da = H.rolloverProperties, P = { polypath: [da.sides ||
2, v, A, da.radius, da.startAngle, da.dip], fill: V(da.fillColor), "stroke-width": da.lineWidth, stroke: V(da.lineColor)
                    }); aa = n.graphic = k.polypath(aa[1] || 2, v, A, $, W.startAngle, 0, ga).attr({ fill: V(W.fillColor), "stroke-width": W.lineWidth, stroke: V(W.lineColor), cursor: M ? "pointer" : "", visibility: $ ? z : "hidden" }).data("alwaysInvisible", !$).data("setRolloverProperties", da).data("setRolloverAttr", P).data("setRolloutAttr", N).data("anchorRadius", $).data("anchorHoverRadius", da && da.radius).shadow(la || !1, ha); if (M || d || da) $ = qa($,
da && da.radius || 0, f), ca = n.tracker = k.circle({ cx: v, cy: A, r: $, cursor: M ? "pointer" : "", stroke: g, "stroke-width": W.lineWidth, fill: g, ishot: !0, visibility: z }, fa); (ca || aa).data("eventArgs", ba).data("groupId", ma).click(sa).hover(Y(n), ua(n)).tooltip(C)
                } e && ((void 0 === p || null === p && 0 === R) && v && A && X.push("M", v, ",", A), v && A && X.push("L", v, ",", A), p = A); C = n.dataLabel = c.drawPlotLineLabel(a, b, J, v, A)
            } else e && 0 === R && (p = null), m[J] = { chart: c, index: J, x: N, y: P }; C && s.push(C); aa && s.push(aa); ca && s.push(ca); c.drawTracker && c.drawTracker.call(c,
a, b, J)
        } X.length && (h = a.graphic = k.path(X, E).attr({ "stroke-dasharray": O, "stroke-width": F, stroke: Q, "stroke-linecap": "round", "stroke-linejoin": 2 < F ? "round" : "miter", visibility: z }).shadow(h.shadow && H.shadow), E.attr({ "clip-rect": l[B ? "clip-canvas-init" : "clip-canvas"] }), B && E.animate({ "clip-rect": l["clip-canvas"] }, B, "normal"), s.push(h)); B && ga.attr({ opacity: 0 }).animate({ opacity: 1 }, B, "normal", c.getAnimationCompleteFn()); a.visible = !1 !== b.visible; return a
    }, drawPlotLineLabel: function (a, b, c, d, f, g) {
        var h = this.options,
k = h.chart, l = this.paper, m = this.layers, n = h.plotOptions.series.dataLabels.style, h = 1 === k.rotateValues ? 270 : 0, s = this.canvasHeight, u = this.canvasTop, w = a.data, z = w[c], C = a.items[c], B = G(z.valuePosition, "auto").toLowerCase(); a = this.logic.defaultSeriesType; var E = C.graphic, E = E && "image" == E.type && 0.5 * E.attr("height") || z.marker && z.marker.radius - 3, k = k.valuePadding + 2 + E; b = !1 === b.visible ? "hidden" : "visible"; E = C.dataLabel; g = g || m.datalabels; switch (B) {
            case "above": c = 0; break; case "below": c = 1; break; default: m = w[c - 1] || {}, w = w[c +
1] || {}, c = c ? m.y > z.y ? 1 : (null == m.y && w.y) > z.y ? 1 : 0 : 0
        } m = z.displayValue; Aa(m) && m !== t ? (E ? h && E.attr("transform", ["r", 360 - h]) : E = C.dataLabel = l.text(g).attr({ "class": "fusioncharts-label", text: m, fill: n.color, "text-bound": [n.backgroundColor, n.borderColor, n.borderThickness, n.borderPadding, n.borderRadius, n.borderDash], "line-height": n.lineHeight }), E.attr({ title: z.originalText || "", fill: n.color }), C._state && C._state.labelWidth || (g = E.getBBox(), C._state = { labelWidth: g.width, labelHeight: g.height }), l = n = h ? C._state.labelWidth :
C._state.labelHeight, g = f - u, s = u + s - f, l = l + k + 4, u = 0.5 * n + k, /bubble/i.test(a) || (c ? s > l ? (f += u, z._valueBelowPoint = 1) : g > l && (f -= u, z._valueBelowPoint = 0) : g > l ? (f -= u, z._valueBelowPoint = 0) : s > l && (f += u, z._valueBelowPoint = 1)), E.attr({ x: d, y: f, visibility: b }).data("isBelow", z._valueBelowPoint), h && E.attr("transform", "T0,0,R" + h)) : E && E.attr({ text: t }); return E
    }, drawLabels: function () {
        for (var a = this.paper, b = this.options, c = (b = b.labels && b.labels.items && b.labels.items) && b.length, d = this.layers.layerAboveDataset, f = this.elements.quadran ||
(this.elements.quadran = []), g = this.canvasTop, h = this.canvasLeft, k = { right: "end", left: "start", undefined: "start" }, l, m, n; c--; ) n = b[c], l = n.style, m = { fontFamily: l.fontFamily, fontSize: l.fontSize, lineHeight: l.lineHeight, fontWeight: l.fontWeight, fontStyle: l.fontStyle, fill: l.color }, Aa(n.html) && n.html !== t && (f[c] = a.text(d).attr({ text: n.html, x: parseInt(l.left, 10) + h, y: parseInt(l.top, 10) + g, "text-anchor": k[n.textAlign], "vertical-align": n.vAlign }).css(m))
    } 
}, c["renderer.root"]); c("renderer.piebase", { isHovered: !1, getPlotData: function (a,
b) { var c = this.datasets[0], d = c.data[a], c = c.userData || (c.userData = []), f, g; if (c[a]) c = c[a]; else { c = c[a] = {}; for (g in d) "object" !== typeof (f = d[g]) && "function" !== typeof f && 0 !== g.indexOf("_") && (c[g] = f); c.value = c.y; c.label = c.name; delete c.y; delete c.total; delete c.doNotSlice; delete c.name; delete c.centerAngle; delete c.showInLegend } c.sliced = b; return c }, redrawDataLabels: function (a) { var b = a.elements.plots[0]; a.placeDataLabels(!0, b.items, b); return {} }, sliceInOtherPies: function (a) {
    var b = this.options.series[0], c = b.plot.items,
d = c.length, f = 0, g; for (b.enableMultiSlicing = !0; d--; ) d !== a && (g = c[d]).sliced && ++f && this.plotGraphicClick.call(g); b.enableMultiSlicing = !1; return !!f
}, plotGraphicClick: function (a) {
    var b = this.graphic || this, c = b.plotItem || b.data("plotItem"), d = c.seriesData, f = c.chart, g = f.logic.chartInstance, h = c.index, k = f.options.series[0].enableMultiSlicing, l = c.slicedTranslation, n, s, t; !d.isRotating && S.call(b, f, a); if (!(d.isRotating || d.singletonCase || (b = !k && f.sliceInOtherPies(h), (a = c.sliced) && b))) return b = c.graphic, d = c.connector,
k = c.dataLabel, l = "object" === typeof l ? "t" + l : l, n = c.connectorPath, s = (a ? -1 : 1) * c.transX, t = (a ? -1 : 1) * c.transY, u.raiseEvent("slicingStart", { slicedState: a, data: f.getPlotData(h, a) }, g), b.animate({ transform: a ? "t0,0" : l }, 200, "easeIn", function () { u.raiseEvent("slicingEnd", { slicedState: c.sliced, data: f.getPlotData(h, c.sliced) }, g) }), k && k.x && k.animate({ x: k.x + (a ? 0 : s) }, 200, "easeIn"), n && (n[1] += s, n[2] += t, n[4] += s, n[6] += s, d.animate({ path: n }, 200, "easeIn")), a = c.sliced = !a, b = { hcJSON: { series: []} }, b.hcJSON.series[0] = { data: l = [] },
l[h] = { sliced: a }, m(g.jsVars._reflowData, b, !0), a
}, plotDragStart: function (a, b, c) { var d = this.data("plotItem"), f = d.chart, d = d.seriesData, g = -f.datasets[0].startAngle * Kb; f.options.series[0].enableRotation && (a = n.call(c, a, b, d.pieCenter, d.chartPosition), d.dragStartAngle = a, d.startingAngleOnDragStart = g) }, plotDragEnd: function () {
    var a = this.data("plotItem"), b = a.chart, c = a.seriesData, a = -b.datasets[0].startAngle * Kb, d = { hcJSON: { series: [{ startAngle: a}]} }; b.disposed || (m(b.logic.chartInstance.jsVars._reflowData, d, !0), b.rotate(c,
b.options.series[0])); c.isRotating && (setTimeout(function () { c.isRotating = !1 }, 0), u.raiseEvent("RotationEnd", { startingAngle: E(a, !0), changeInAngle: a - c.startingAngleOnDragStart }, b.logic.chartInstance)); !b.isHovered && b.onPlotHover(this, !1)
}, plotDragMove: function (a, b, c, d, f) {
    a = this.data("plotItem"); var g = a.chart, h = a.seriesData, k = g.options.series; k[0].enableRotation && !h.singletonCase && (h.isRotating || (h.isRotating = !0, u.raiseEvent("RotationStart", { startingAngle: E(h.startingAngleOnDragStart, !0) }, g.logic.chartInstance)),
c = n.call(f, c, d, h.pieCenter, h.chartPosition), k[0].startAngle += c - h.dragStartAngle, h.dragStartAngle = c, h.moveDuration = 0, c = (new Date).getTime(), !h._lastTime || h._lastTime + h.timerThreshold < c) && (setTimeout(function () { g.rotate(h, k[0]) }, 0), h._lastTime = c)
}, plotMouseDown: function () { (this.plotItem || this.data("plotItem")).seriesData.isRotating = !1 }, plotMouseUp: function () { var a = this.plotItem || this.data("plotItem"), b = a.chart, c = a.seriesData; P.supportsTouch && !c.isRotating && b.plotGraphicClick.call(a) }, plotRollOver: function (a) {
    var b =
this.plotItem || this.data("plotItem"), c = b.chart, d, f; b.seriesData.isRotating || (S.call(this, c, a, "DataPlotRollOver"), c.onPlotHover(this, !0)); c.isHovered = !0; (a = b.innerDiameter) && (d = b.centerLabelConfig) && (f = d.label) && c.drawDoughnutCenterLabel(f, b.center[0], b.center[1], a, a, d, !1)
}, plotRollOut: function (a) {
    var b = this.plotItem || this.data("plotItem"), c = b.chart, d = c.options.series[0], f, g; b.seriesData.isRotating || (S.call(this, c, a, "DataPlotRollOut"), c.onPlotHover(this, !1)); c.isHovered = !1; (a = b.innerDiameter) && (f =
d.centerLabelConfig) && ((g = f.label) || !g) && c.drawDoughnutCenterLabel(g, b.center[0], b.center[1], a, a, f, !1)
}, onPlotHover: function (a, b) { var c = a.data("plotItem"), d = c.rolloverProperties, f = b ? d.color : c.color, g = b ? d.borderWidth : c.borderWidth, h = b ? d.borderColor : c.borderColor; d && c.graphic.attr({ fill: V(f), "stroke-width": g, stroke: h }) }, getEventArgs: function (a) {
    a = a || {}; return { datasetName: a.label, datasetIndex: a.originalIndex, id: a.userID, visible: !0, label: a.label, value: a.value, percentValue: a.percentage, tooltext: a.toolText,
        link: a.link, sliced: a.sliced
    }
}, legendClick: function (a) { var b = a.chart; b.elements.plots[0].isRotating = !1; b.plotGraphicClick.call(a) }, placeDataLabels: function () {
    var a = function (a, b) { return a.point.value - b.point.value }, b = function (a, b) { return a.angle - b.angle }, c = ["start", "start", "end", "end"], d = [-1, 1, 1, -1], f = [1, 1, -1, -1]; return function (g, h, k, l) {
        var m = this.options.plotOptions, n = m.pie, s = this.canvasLeft + 0.5 * this.canvasWidth, t = this.canvasTop + 0.5 * this.canvasHeight, u = this.smartLabel, z = m.series.dataLabels, w = z.style,
m = C(Fa(parseFloat(w.lineHeight)), 12), B = la(z.placeLabelsInside, 1 === h.length ? !0 : !1), E = z.skipOverlapLabels, G = z.manageLabelOverflow, I = z.connectorPadding, J = z.distance, H = l && l.metrics || [s, t, n.size, n.innerSize || 0], K = H[1], M = H[0]; l = 0.5 * H[2]; var N = [[], [], [], []], P = this.canvasLeft, p = this.canvasTop, n = this.canvasWidth, J = k.labelsRadius || (k.labelsRadius = l + J), t = s = parseInt(w.fontSize, 10), v = t / 2, I = [I, I, -I, -I]; k = k.labelsMaxInQuadrant || (k.labelsMaxInQuadrant = Pa(J / t)); var z = z.isSmartLineSlanted, H = H[3] / 2, A, F, e, Q, O, R, S, V,
W, $, ba, aa, da, ca, fa, ga, ja, sa, ua; g || u.setStyle(w); if (1 == h.length && !H && B) H = h[0], (ca = H.dataLabel) && ca.show(), H.slicedTranslation = [P, p], ca && (ca.attr({ visibility: Ga, align: "middle", transform: ["t", M, K + v - 2] }), ca.x = M); else if (B) ua = H + (l - H) / 2, ha(h, function (a) { (ca = a.dataLabel) && ca.show(); ca && (aa = a.angle, ba = K + ua * ma(aa) + v - 2, S = M + ua * Ba(aa), ca.x = S, ca._x = S, ca.y = ba, a.sliced && (sa = a.slicedTranslation, ga = sa[0] - P, ja = sa[1] - p, S += ga, ba += ja), ca.attr({ visibility: Ga, align: "middle", transform: ["t", S, ba] })) }); else {
            ha(h, function (a) {
                (ca =
a.dataLabel) && ca.show(); ca && (aa = a.angle % yb, 0 > aa && (aa = yb + aa), fa = 0 <= aa && aa < qb ? 1 : aa < Na ? 2 : aa < bb ? 3 : 0, N[fa].push({ point: a, angle: aa }))
            }); for (h = g = 4; h--; ) { if (E && (w = N[h].length - k, 0 < w)) for (N[h].sort(a), B = N[h].splice(0, w), w = 0, Q = B.length; w < Q; w += 1) H = B[w].point, H.dataLabel.attr({ visibility: "hidden" }), H.connector && H.connector.attr({ visibility: "hidden" }); N[h].sort(b) } h = qa(N[0].length, N[1].length, N[2].length, N[3].length); da = qa(Ca(h, k) * t, J + t); N[1].reverse(); for (N[3].reverse(); g--; ) {
                B = N[g]; Q = B.length; E || (t = Q > k ? da / Q :
s, v = t / 2); H = Q * t; w = da; for (h = 0; h < Q; h += 1, H -= t) e = Ya(da * ma(B[h].angle)), w < e ? e = w : e < H && (e = H), w = (B[h].oriY = e) - t; A = c[g]; Q = da - (Q - 1) * t; w = 0; for (h = B.length - 1; 0 <= h; h -= 1, Q += t) if (H = B[h].point, aa = B[h].angle, O = H.sliced, ca = H.dataLabel, e = Ya(da * ma(aa)), e < w ? e = w : e > Q && (e = Q), w = e + t, W = (e + B[h].oriY) / 2, e = M + f[g] * J * Ba(X.asin(W / da)), W *= d[g], W += K, $ = K + l * ma(aa), R = M + l * Ba(aa), (2 > g && e < R || 1 < g && e > R) && (e = R), S = e + I[g], ba = W - v - 2, V = S + I[g], ca.x = V, ca._x = V, G && (F = 1 < g ? V - this.canvasLeft : this.canvasLeft + n - V, F = u.getSmartText(H.labelText, F, m), ca.attr({ text: F.text,
    title: F.tooltext || ""
})), ca.y = ba, O && (ga = H.transX, ja = H.transY, S += ga, e += ga, R += ga, $ += ja, V += ga), ca.attr({ visibility: Ga, "text-anchor": A, vAlign: "middle", x: V, y: W }), O = H.connector) H.connectorPath = H = ["M", R, $, "L", z ? e : R, W, S, W], O.attr({ path: H, visibility: Ga })
            } 
        } 
    } 
} ()
}, c["renderer.root"])
} ]);
FusionCharts.register("module", ["private", "modules.renderer.js-interface", function () {
    var d = this, n = d.hcLib, E = d.renderer.getRenderer("javascript"), u = n.hasModule, l = n.loadModule, b = n.getMetaSentence, P = n.moduleCmdQueue, c = n.executeWaitingCommands, J = n.injectModuleDependency, a = n.moduleDependencies, B = n.getDependentModuleName, N, t; N = function (a) {
        var k, f, h, l = {}, t; a = b(a); for (k in d.core.items) k = d.core.items[k], f = k.chartType(), h = k.options.chartTypeSourcePath + f, (f = k.jsVars) && f.waitingModule && k.__state.rendering &&
n.needsModule(a.predicate, h) && (f.waitingModuleError = !0, f = B(h).concat(f.userModules), f.length && (f = f[f.length - 1], l[f] = n.moduleCmdQueue[f])); for (t in l) c(l[t]); d.raiseError(d.core, "11171116151", "run", "HC-interface~renderer.load", "Unable to load required modules and resources: " + a.key)
    }; t = function (a, b, c) { d.hcLib.createChart(a, b, "stub", c, a.jsVars.msgStore.ChartNotSupported) }; n.eventList = d.extend(d.legacyEventList, { loaded: "FC_Loaded", dataloaded: "FC_DataLoaded", rendered: "FC_Rendered", drawcomplete: "FC_DrawComplete",
        dataxmlinvalid: "FC_DataXMLInvalid", nodatatodisplay: "FC_NoDataToDisplay", exported: "FC_Exported"
    }); n.raiseEvent = d.raiseEventWithLegacy; a.charts = d.extend(a.charts || {}, { column2d: 0, column3d: 0, bar2d: 0, bar3d: 0, pie2d: 0, pie3d: 0, line: 0, area2d: 0, doughnut2d: 0, doughnut3d: 0, pareto2d: 0, pareto3d: 0, mscolumn2d: 0, mscolumn3d: 0, msline: 0, msarea: 0, msbar2d: 0, msbar3d: 0, stackedcolumn2d: 0, marimekko: 0, stackedcolumn3d: 0, stackedarea2d: 0, stackedcolumn2dline: 0, stackedcolumn3dline: 0, stackedbar2d: 0, stackedbar3d: 0, msstackedcolumn2d: 0,
        mscombi2d: 0, mscombi3d: 0, mscolumnline3d: 0, mscombidy2d: 0, mscolumn3dlinedy: 0, stackedcolumn3dlinedy: 0, msstackedcolumn2dlinedy: 0, scatter: 0, bubble: 0, ssgrid: 0, scrollcolumn2d: 0, scrollcolumn3d: 0, scrollline2d: 0, scrollarea2d: 0, scrollstackedcolumn2d: 0, scrollcombi2d: 0, scrollcombidy2d: 0, zoomline: 0
    }); a.powercharts = d.extend(a.powercharts || {}, { spline: 0, splinearea: 0, msspline: 0, mssplinearea: 0, mssplinedy: 0, multiaxisline: 0, multilevelpie: 0, waterfall2d: 0, msstepline: 0, inversemsline: 0, inversemscolumn2d: 0, inversemsarea: 0,
        errorbar2d: 0, errorscatter: 0, errorline: 0, logmsline: 0, logmscolumn2d: 0, logstackedcolumn2d: 0, radar: 0, dragnode: 0, candlestick: 0, selectscatter: 0, dragcolumn2d: 0, dragline: 0, dragarea: 0, boxandwhisker2d: 0, kagi: 0, heatmap: 0
    }); a.widgets = d.extend(a.widgets || {}, { angulargauge: 0, bulb: 0, cylinder: 0, drawingpad: 0, funnel: 0, hbullet: 0, hled: 0, hlineargauge: 0, vlineargauge: 0, pyramid: 0, realtimearea: 0, realtimecolumn: 0, realtimeline: 0, realtimelinedy: 0, realtimestackedarea: 0, realtimestackedcolumn: 0, sparkcolumn: 0, sparkline: 0, sparkwinloss: 0,
        thermometer: 0, vbullet: 0, gantt: 0, vled: 0
    }); a.maps = d.extend(a.maps || {}, {}); d.extend(E, { render: function (a, b) {
        var c = this.chartType(), h = this.options.chartTypeSourcePath + c, l = this.jsVars, N = this.__state, m = n.chartAPI, z, H; z = B(h).concat(l.userModules); l.isResizing && (l.isResizing = clearTimeout(l.isResizing)); l.hcObj && l.hcObj.destroy && l.hcObj.destroy(); if (m[c]) {
            if (m[N.lastRenderedType] && N.lastRenderedType !== c) for (H in d.raiseEvent("chartTypeChanged", { previousType: N.lastRenderedType, newType: c }, this), m[N.lastRenderedType].eiMethods) delete this[H];
            N.lastRenderedType = c; N.lastRenderedSrc = this.src; delete l.waitingModule; delete l.waitingModuleError; delete l.drLoadAttempted; d.hcLib.createChart(this, a, c, b)
        } else {
            if (c && u(z)) { if (l.drLoadAttempted) { d.raiseError(this, 11112822001, "run", "HC-interface~renderer.render", "Chart runtimes not loaded even when resource is present"); t(this, a, b); return } J(h) && (z = B(h).concat(l.userModules)); l.drLoadAttempted = !0 } else {
                if (!z.length) { t(this, a, b); return } if (l.waitingModuleError) {
                    t(this, a, b); delete l.waitingModule; delete l.waitingModuleError;
                    return
                } 
            } (c = P[z[z.length - 1]]) ? (c.push({ cmd: "render", obj: this, args: arguments }), l.waitingModule || (d.hcLib.createChart(this, a, "stub", void 0, l.msgStore.PBarLoadingText || l.msgStore.LoadingText), E.load.call(this, a, b))) : (d.raiseError(this, 12080515551, "run", "HC-interface~renderer.render", "Unregistered module in dependentModule definition."), d.hcLib.createChart(this, a, "stub", void 0, l.msgStore.RenderChartErrorText))
        } 
    }, update: function (a) {
        var b = this.ref, c = this.jsVars; c.hcObj && c.hcObj.destroy && c.hcObj.destroy();
        c.isResizing && (c.isResizing = clearTimeout(c.isResizing)); void 0 === a.error ? (delete c.stallLoad, delete c.loadError, this.isActive() && (this.src !== this.__state.lastRenderedSrc ? this.render() : d.hcLib.createChart(this, c.container, c.type))) : (this.isActive() && "function" === typeof b.showChartMessage && b.showChartMessage("InvalidXMLText"), delete c.loadError)
    }, resize: function (a) {
        var b = this.ref, c, h = this.jsVars; b && b.resize && (h.isResizing && (h.isResizing = clearTimeout(h.isResizing)), h.isResizing = setTimeout(function () {
            c =
d.normalizeCSSDimension(a.width, a.height, b); void 0 !== a.width && (b.style.width = c.width); void 0 !== a.height && (b.style.height = c.height); b.resize(); delete h.isResizing
        }, 0))
    }, dispose: function () { var a; a = this.jsVars; a.isResizing && (a.isResizing = clearTimeout(a.isResizing)); a.instanceAPI && a.instanceAPI.dispose && (a.instanceAPI.dispose(), delete a.instanceAPI); if (a = this.ref) d.purgeDOM(a), a.parentNode && a.parentNode.removeChild(a); n.cleanupWaitingCommands(this) }, load: function (a, b) {
        var f = this.jsVars, h = this.chartType(),
s = d.hcLib.chartAPI[h], h = B(h).concat(f.userModules), u = h[h.length - 1]; s || !h || h && 0 === h.length ? (delete f.waitingModule, a && t(this, a || this.ref, b)) : f.waitingModule || (f.waitingModule = !0, delete f.waitingModuleError, l(h, function () { delete f.waitingModule; c(n.moduleCmdQueue[u]) }, N, this))
    } 
    })
} ]);
FusionCharts.register("module", ["private", "modules.api.dynamicchartattributes", function () {
    var d = this; d.extend(d.core, { setChartAttribute: function (n, E) { var u, l, b, P; if ("string" === typeof n) u = n, n = {}, n[u] = E; else if (null === n || "object" !== typeof n) return; P = 0; u = this.getChartData(d.dataFormats.JSON); b = u.chart || u.graph || u.map || {}; for (l in n) P += 1, null === n[l] ? delete b[l.toLowerCase()] : b[l.toLowerCase()] = n[l]; 0 < P && ("undefined" === typeof b.animation && (b.animation = "0"), this.setChartData(u, d.dataFormats.JSON)) }, getChartAttribute: function (n) {
        var E =
(E = this.getChartData(d.dataFormats.JSON)).chart || E.graph || E.map, u, l; if (0 === arguments.length || void 0 === n || void 0 === E) return E; if ("string" === typeof n) u = E[n.toString().toLowerCase()]; else if (n instanceof Array) for (u = {}, l = 0; l < n.length; l += 1) u[n[l]] = E[n[l].toString().toLowerCase()]; else d.raiseError(this, "25081429", "param", "~getChartAttribute()", 'Unexpected value of "attribute"'); return u
    } 
    }, !0)
} ]);
FusionCharts.register("module", ["private", "api.linkmanager", function () {
    var d = this, n = d.FusionChartsDOMInsertModes, E = {}, u = function (b, l) { this.items = {}; this.root = b; this.parent = l; l instanceof d.core ? this.level = this.parent.link.level + 1 : (E[b.id] = [{}], this.level = 0) }, l = function (b, d) { return (b.options.containerElement === d.options.containerElement || b.options.containerElementId === d.options.containerElementId) && b.options.insertMode === n.REPLACE }; d.policies.link = ["link", void 0]; u.prototype.configuration = function () {
        return E[this.root.id][this.level] ||
(E[this.root.id][this.level] = {})
    }; d.extend(d.core, { configureLink: function (b, l) {
        var c; if (b instanceof Array) { for (c = 0; c < b.length; c += 1) "object" !== typeof E[this.link.root.id][c] && (E[this.link.root.id][c] = {}), d.extend(E[this.link.root.id][c], b[c]); E[this.link.root.id].splice(b.length) } else "object" === typeof b ? ("number" !== typeof l && (l = this.link.level), void 0 === E[this.link.root.id][l] && (E[this.link.root.id][l] = {}), d.extend(E[this.link.root.id][l], b)) : d.raiseError(this, "25081731", "param", "~configureLink()",
"Unable to update link configuration from set parameters")
    } 
    }, !0); d.addEventListener("beforeInitialize", function (b) { b.sender.link instanceof u ? b.sender.link.parent instanceof d.core && (b.sender.link.parent.link.items[b.sender.id] = b.sender) : b.sender.link = new u(b.sender) }); d.addEventListener("linkedChartInvoked", function (b, n) {
        var c = b.sender, E = c.clone({ dataSource: n.data, dataFormat: n.linkType, link: new u(c.link.root, c) }, !0), a = n.alias, B; a && (!E.typeSource && E.swfUrl && (E.typeSource = E.swfUrl.replace(/(.*?)?[^\/]*\.swf.*?/ig,
"$1")), E.type = a); c.args && 0 !== parseInt(c.args.animate, 10) && delete E.animate; d.extend(E, c.link.configuration()); d.raiseEvent("beforeLinkedItemOpen", { level: c.link.level }, c.link.root, void 0, function () {
    d.core.items[E.id] instanceof d.core && d.core.items[E.id].dispose(); B = new d.core(E); l(B, c) || c.options.overlayButton && c.options.overlayButton.message || ("object" !== typeof c.options.overlayButton && (c.options.overlayButton = {}), c.options.overlayButton.message = "Close"); B.render(); d.raiseEvent("linkedItemOpened",
{ level: c.link.level, item: B }, c.link.root)
})
    }); d.addEventListener("overlayButtonClick", function (b, n) { if ("LinkManager" === n.id) { var c = b.sender, u = c.link.level - 1, a = c.link.parent, B = c.link.root; d.raiseEvent("beforeLinkedItemClose", { level: u, item: c }, B, function () { setTimeout(function () { d.core.items[c.id] && c.dispose(); d.raiseEvent("linkedItemClosed", { level: u }, B) }, 0); a.disposed || a.isActive() || !l(c, a) || a.render() }) } }); d.addEventListener("Loaded", function (b) {
        b = b.sender; var l; b && void 0 !== b.link && b.link.root !== b &&
b.link.parent instanceof d.core && (b.ref && "function" === typeof b.ref.drawOverlayButton ? (l = d.extend({ show: !0, id: "LinkManager" }, b.link.parent.options.overlayButton), d.extend(l, b.link.parent.link.configuration().overlayButton || {}), b.ref.drawOverlayButton(l)) : d.raiseWarning(b, "04091602", "run", "::LinkManager^Loaded", "Unable to draw overlay button on object. -" + b.id))
    }); d.addEventListener("beforeDispose", function (b) {
        var l = b.sender; l && l.link instanceof u && (l && l.link && l.link.parent instanceof d.core && l.link.parent.link &&
l.link.parent.link.items && delete l.link.parent.link.items[b.sender.id], delete E[l.id])
    })
} ]);