/*
FusionCharts JavaScript Library
Copyright FusionCharts Technologies LLP
License Information at <http://www.fusioncharts.com/license>
FusionCharts JavaScript Library
Copyright FusionCharts Technologies LLP
License Information at <http://www.fusioncharts.com/license>

@version 3.4.0-alpha.5
*/
FusionCharts.register("module", ["private", "modules.renderer.js-charts", function () {
    function Da(a) { var n = { left: a.offsetLeft, top: a.offsetTop }; for (a = a.offsetParent; a; ) n.left += a.offsetLeft, n.top += a.offsetTop, a !== Ia.body && a !== Ia.documentElement && (n.left -= a.scrollLeft, n.top -= a.scrollTop), a = a.offsetParent; return n } function ha(a, n) { for (var c = [], d = 0, B = a.length; d < B; d++) c[d] = n.call(a[d], a[d], d, a); return c } function ca(a, n) { var c = n ? 360 : ra; a = (a || 0) % c; return 0 > a ? c + a : a } function La(a, n) {
        return a <= $ ? a : n <= $ ? n : n > a ? 0 :
n
    } function Oa(a, n, c, d, B) { return fa((n - c[1] - d.top) / B, a - c[0] - d.left) } function Ma(a, n, c, d, B, b, v, Z, e, q) {
        "object" === typeof a && (n = a.y, c = a.r, d = a.innerR, B = a.radiusYFactor, b = a.depth, v = a.seriesGroup, Z = a.renderer, a = a.x); if (0 > B || 1 <= B) B = 0.6; a = a || 0; n = n || 0; c = c || 1; d = d || 0; b = b || 0; this.renderer = Z; this.hasOnePoint = e; this.use3DLighting = q; this.cx = a; this.cy = n; this.rx = c; this.ry = c * B; this.radiusYFactor = B; this.isDoughnut = 0 < d; this.innerRx = d; this.innerRy = d * B; this.depth = b; this.leftX = a - c; this.rightX = a + c; this.leftInnerX = a - d; this.rightInnerX =
a + d; this.depthY = n + b; this.topY = n - this.ry; this.bottomY = this.depthY + this.ry; this.bottomBorderGroup = Z.group("bottom-border", v).attr({ transform: "t0," + b }); this.outerBackGroup = Z.group("outer-back-Side", v); this.slicingWallsBackGroup = Z.group("slicingWalls-back-Side", v); this.innerBackGroup = Z.group("inner-back-Side", v); this.innerFrontGroup = Z.group("inner-front-Side", v); this.slicingWallsFrontGroup = Z.group("slicingWalls-front-Side", v); this.topGroup = Z.group("top-Side", v); this.moveCmdArr = [g]; this.lineCmdArr = [X];
        this.closeCmdArr = [x]; this.centerPoint = [a, n]; this.leftPoint = [this.leftX, n]; this.topPoint = [a, this.topY]; this.rightPoint = [this.rightX, n]; this.bottomPoint = [a, n + this.ry]; this.leftDepthPoint = [this.leftX, this.depthY]; this.rightDepthPoint = [this.rightX, this.depthY]; this.leftInnerPoint = [this.leftInnerX, n]; this.rightInnerPoint = [this.rightInnerX, n]; this.leftInnerDepthPoint = [this.leftInnerX, this.depthY]; this.rightInnerDepthPoint = [this.rightInnerX, this.depthY]; this.pointElemStore = []; this.slicingWallsArr = []; a = [l,
this.rx, this.ry, 0, 0, 1, this.rightX, n]; c = [l, this.rx, this.ry, 0, 0, 1, this.leftX, n]; d = [l, this.rx, this.ry, 0, 0, 0, this.rightX, this.depthY]; B = [l, this.rx, this.ry, 0, 0, 0, this.leftX, this.depthY]; b = [l, this.innerRx, this.innerRy, 0, 0, 0, this.rightInnerX, n]; n = [l, this.innerRx, this.innerRy, 0, 0, 0, this.leftInnerX, n]; v = [l, this.innerRx, this.innerRy, 0, 0, 1, this.rightInnerX, this.depthY]; Z = [l, this.innerRx, this.innerRy, 0, 0, 1, this.leftInnerX, this.depthY]; this.isDoughnut ? (this.topBorderPath = this.moveCmdArr.concat(this.leftPoint,
a, c, this.moveCmdArr, this.leftInnerPoint, b, n), this.topPath = this.moveCmdArr.concat(this.leftPoint, a, c, this.lineCmdArr, this.leftInnerPoint, b, n, this.closeCmdArr), this.innerFrontPath = this.moveCmdArr.concat(this.leftInnerPoint, b, this.lineCmdArr, this.rightInnerDepthPoint, Z, this.closeCmdArr), this.innerBackPath = this.moveCmdArr.concat(this.rightInnerPoint, n, this.lineCmdArr, this.leftInnerDepthPoint, v, this.closeCmdArr)) : this.topBorderPath = this.topPath = this.moveCmdArr.concat(this.leftPoint, a, c, this.closeCmdArr);
        this.outerBackPath = this.moveCmdArr.concat(this.leftPoint, a, this.lineCmdArr, this.rightDepthPoint, B, this.closeCmdArr); this.outerFrontPath = this.moveCmdArr.concat(this.rightPoint, c, this.lineCmdArr, this.leftDepthPoint, d, this.closeCmdArr); this.clipPathforOuter = [g, this.leftX, this.topY, X, this.rightX, this.topY, this.rightX, this.bottomY, this.leftX, this.bottomY, x]; this.clipPathforInner = [g, this.leftInnerX, this.topY, X, this.rightInnerX, this.topY, this.rightInnerX, this.bottomY, this.leftInnerX, this.bottomY, x]; this.clipPathforNoClip =
[g, this.leftInnerX, this.topY, X, this.leftInnerX, this.bottomY, x]; this.colorObjs = []
    } var ea = this, w = ea.hcLib, ga = w.Raphael, t = ea.window, Ia = t.document, D = w.BLANKSTRING, Xa = w.createTrendLine, k = w.pluck, ya = w.getValidValue, Ga = w.parseTooltext, h = w.pluckNumber, Na = w.getFirstValue, Ya = w.getDefinedColor, ka = w.parseUnsafeString, pa = w.FC_CONFIG_STRING, za = w.extend2, Ea = w.getDashStyle, z = w.toRaphaelColor, Za = w.toPrecision, $a = w.stubFN, aa = w.hasSVG, ta = w.each, Aa = w.TOUCH_THRESHOLD_PIXELS, Pa = w.CLICK_THRESHOLD_PIXELS, sa = w.plotEventHandler,
b = w.hasTouch ? Aa : Pa, e = "rgba(192,192,192," + (w.isIE ? 0.002 : 1E-6) + ")", f = 8 === t.document.documentMode ? "visible" : "", g = "M", X = "L", l = "A", x = "Z", s = Math, W = s.sin, F = s.cos, fa = s.atan2, Y = s.round, H = s.min, r = s.max, ua = s.abs, oa = s.PI, V = s.ceil, K = s.floor, Fa = s.sqrt, T = oa / 180, da = 180 / oa, $ = Math.PI, Qa = $ / 2, ra = 2 * $, Ua = $ + Qa, Ja = w.graphics.getColumnColor, ia = w.getFirstColor, ab = w.setLineHeight, Va = w.pluckFontSize, Ra = w.getFirstAlpha, qa = w.graphics.getDarkColor, va = w.graphics.getLightColor, wa = w.graphics.convertColor, Sa = w.COLOR_TRANSPARENT, Wa =
w.POSITION_CENTER, cb = w.POSITION_TOP, bb = w.POSITION_BOTTOM, db = w.POSITION_RIGHT, eb = w.POSITION_LEFT, m = w.chartAPI, fb = w.graphics.mapSymbolName, Aa = m.singleseries, ba = w.COMMASTRING, Ba = w.ZEROSTRING, Ka = w.ONESTRING, Ha = w.HUNDREDSTRING, Ta = w.PXSTRING, gb = w.COMMASPACE, xa = !/fusioncharts\.com$/i.test(t.location.hostname); m("column2d", { standaloneInit: !0, friendlyName: "Column Chart", creditLabel: xa, rendererId: "cartesian" }, m.column2dbase); m("column3d", { friendlyName: "3D Column Chart", defaultSeriesType: "column3d", defaultPlotShadow: 1,
    is3D: !0, defaultZeroPlaneHighlighted: !1
}, m.column2d); m("bar2d", { friendlyName: "Bar Chart", isBar: !0, defaultSeriesType: "bar", spaceManager: m.barbase }, m.column2d); m("bar3d", { friendlyName: "3D Bar Chart", defaultSeriesType: "bar3d", defaultPlotShadow: 1, is3D: !0, defaultZeroPlaneHighlighted: !1 }, m.bar2d); m("line", { friendlyName: "Line Chart", standaloneInit: !0, creditLabel: xa, rendererId: "cartesian" }, m.linebase); m("area2d", { friendlyName: "Area Chart", standaloneInit: !0, creditLabel: xa, rendererId: "cartesian" }, m.area2dbase);
    m("pie2d", { friendlyName: "Pie Chart", standaloneInit: !0, defaultSeriesType: "pie", defaultPlotShadow: 1, reverseLegend: 1, alignCaptionWithCanvas: 0, sliceOnLegendClick: !0, rendererId: "pie", point: function (a, n, c, d, B) {
        a = B[pa]; var b = this.colorManager, v = a.is3d, Z = h(d.plotborderthickness), e = h(Z, v ? 0.1 : 1), q = h(d.enablemultislicing, 1), g = h(d.use3dlighting, 1), p = g ? h(d.radius3d, d["3dradius"], 90) : 100, f = h(d.showzeropies, 1), l = h(d.showpercentintooltip, 1), S = h(d.showlabels, 1), O = h(d.showvalues, 1), m = h(d.showpercentvalues, d.showpercentagevalues,
0), y = k(d.tooltipsepchar, d.hovercapsepchar, gb), hb = k(d.labelsepchar, y), E = k(d.plotbordercolor, d.piebordercolor), C = B[pa].numberFormatter, X = c.length, F = h(d.plotborderdashed, 0), L = h(d.plotborderdashlen, 5), A = h(d.plotborderdashgap, 4), G = h(d.showvalueinlegend, 0), M = h(d.showlabelinlegend, 1), x = h(d.valuebeforelabelinlegend, 0), ib = h(d.showvalueaspercentinlegend, 1), u = h(d.reverseplotorder, 0), I = k(d.legendsepchar, ", "), Q = B.plotOptions.series.dataLabels.style, R = 0, s = [], W, P, N, Y, U, J, r, H, t, $, w, K, z, fa, V, ja, na, la, oa = -1; ja = n.centerLabelConfig =
{ label: k(d.defaultcenterlabel, ""), font: k(d.centerlabelfont, Q.fontFamily), fontSize: h(d.centerlabelfontsize, parseInt(Q.fontSize, 10)), color: ia(k(d.centerlabelcolor, d.valuefontcolor, a.inCanvasStyle.color, "555555")), alpha: h(d.centerlabelalpha, 100), bold: h(d.centerlabelbold, Q.fontWeight), italic: h(d.centerlabelitalic, Q.style), bgColor: k(d.centerlabelbgcolor, ""), bgAlpha: h(d.centerlabelbgalpha, 100), borderColor: k(d.centerlabelbordercolor, Q.borderColor), borderAlpha: h(d.centerlabelborderalpha, 100), borderThickness: h(d.centerlabelborderthickness,
Q.borderThickness), borderRadius: h(d.centerlabelborderradius, Q.borderRadius), textPadding: h(d.centerlabeltextpadding, Q.borderPadding), padding: h(d.centerlabelpadding, 2), bgOval: h(d.centerlabelbgoval, 0), shadow: h(d.showcenterlabelshadow, 0), hoverColor: d.centerlabelhovercolor && ia(k(d.centerlabelhovercolor)), hoverAlpha: h(d.centerlabelhoveralpha), toolText: k(d.centerlabeltooltext, "")
}; 100 < p && (p = 100); 0 > p && (p = 0); h(d.showlegend, 0) && (B.legend.enabled = !0, B.legend.reversed = !Boolean(h(d.reverselegend, 0)), n.showInLegend =
!0); for (Q = 0; Q < X; Q += 1) N = c[Q], P = C.getCleanValue(N.value, !0), null === P || !f && 0 === P || (s.push(N), R += P); 0 === R && (s = []); n.enableRotation = 1 < s.length ? h(d.enablerotation, 1) : 0; n.alphaAnimation = h(d.alphaanimation, 1); n.is3D = v; n.placeLabelsInside = d.placevaluesinside; n.use3DLighting = g; n.pieYScale = h(d.pieyscale, 40); 1 > n.pieYScale && (n.pieYScale = 1); 100 <= n.pieYScale && (n.pieYScale = 80); n.pieYScale /= 100; n.pieSliceDepth = h(d.pieslicedepth, 15); 1 > n.pieSliceDepth && (n.pieSliceDepth = 1); n.managedPieSliceDepth = n.pieSliceDepth; n.enableMultiSlicing =
!!q; v && d.showplotborder != Ka && !Z && (n.showBorderEffect = 1); for (Q = s.length - 1; 0 <= Q; Q -= 1) {
            N = s[Q]; P = C.getCleanValue(N.value, !0); W = ka(k(N.label, N.name, D)); X = k(N.color, b.getPlotColor(Q)); U = k(N.alpha, d.plotfillalpha); J = k(N.bordercolor, E); r = k(N.borderalpha, d.plotborderalpha, d.pieborderalpha); v && (J || void 0 !== r) && (n.showBorderEffect = 0); J = k(J, va(X, v ? 90 : 25)).split(ba)[0]; r = d.showplotborder == Ba ? Ba : k(r, U, "80"); U = k(U, Ha); f = { opacity: Math.max(U, r) / 100 }; if (c = Boolean(h(N.issliced, d.issliced, 0))) q || (-1 !== oa && (n.data[s.length -
oa - 1].sliced = !1), oa = Q), a.preSliced = c; Z = (fa = h(N.dashed, F)) ? Ea(k(N.dashlen, L), k(N.dashgap, A), e) : void 0; Y = ya(ka(k(N.tooltext, a.tooltext))); $ = C.percentValue(P / R * 100); w = C.dataLabels(P) || D; t = 1 === h(N.showlabel, S) ? W : D; H = 1 === (K = h(N.showvalue, O)) ? 1 === m ? $ : w : D; z = ya(ka(N.displayvalue)); H = void 0 !== z && K ? z : H !== D && t !== D ? t + hb + H : k(t, H); void 0 !== Y ? Y = Ga(Y, [1, 2, 3, 5, 6, 7, 14, 24, 25], { formattedValue: w, label: W, yaxisName: ka(d.yaxisname), xaxisName: ka(d.xaxisname), percentValue: $, sum: C.dataLabels(R), unformattedSum: R }, N, d) : (Y = W,
K = l ? $ : w, Y = Y != D ? Y + y + K : K); K = M ? W : D; G && (V = ib ? C.legendPercentValue(P / R * 100) : C.legendValue(P), K = x ? V + (K && I + K) : (K && K + I) + V); fa = this.pointHoverOptions(N, n, { plotType: "pie", use3DLighting: g, color: X, alpha: U, borderWidth: e, borderColor: J, borderAlpha: r, borderDashed: fa, borderDashGap: k(N.dashgap, A), borderDashLen: h(N.dashlen, L), radius3D: p, shadow: f }); W = { label: k((na = N.centerlabel || d.centerlabel) && this.replaceMacros(na, ["\\$value", "\\$percentValue", "\\$displayValue", "\\$label"], [w, $, void 0 === z ? "" : z, W]), ""), font: ja.font,
    fontSize: h(N.centerlabelfontsize, ja.fontSize), color: ia(k(N.centerlabelcolor, ja.color)), alpha: h(N.centerlabelalpha, ja.alpha), bold: h(N.centerlabelbold, ja.bold), italic: h(N.centerlabelitalic, ja.italic), bgColor: k(N.centerlabelbgcolor, ja.bgColor), bgAlpha: h(N.centerlabelbgalpha, ja.bgAlpha), borderColor: k(N.centerlabelbordercolor, ja.borderColor), borderAlpha: h(N.centerlabelborderalpha, ja.borderAlpha), borderThickness: ja.borderThickness, borderRadius: ja.borderRadius, textPadding: ja.textPadding, padding: ja.padding,
    bgOval: ja.bgOval, shadow: ja.shadow, hoverColor: (la = k(N.centerlabelhovercolor, ja.hoverColor)) && ia(la), hoverAlpha: h(N.centerlabelhoveralpha, ja.hoverAlpha), toolText: k(N.centerlabeltooltext, "")
}; n.data.push({ displayValue: H, categoryLabel: t, showInLegend: K !== D, y: P, name: K, shadow: f, toolText: Y, color: this.getPointColor(X, U, p), _3dAlpha: U, borderColor: wa(J, r), borderWidth: e, link: ya(N.link), sliced: c, dashStyle: Z, doNotSlice: k(d.enableslicing, Ka) != Ka, hoverEffects: fa.enabled && fa.options, rolloverProperties: fa.enabled &&
fa.rolloverOptions, centerLabelConfig: W
})
        } u && (n.reversePlotOrder = !0, n.data && n.data.reverse()); n.valueTotal = R; B.legend.enabled = d.showlegend === Ka ? !0 : !1; n.startAngle = h(d.startingangle, 0); B.chart.startingAngle = k(1 < s.length ? d.startingangle : 0, 0); return n
    }, replaceMacros: function (a, n, c) { for (var d = n.length || 0, B; d--; ) B = new RegExp(n[d], "gi"), a = a.replace(B, c[d]); return a }, containsMacro: function (a, n) { for (var c = n.length || 0, d; c--; ) if (d = new RegExp(n[c], "gi"), d = a.match(d)) return !0; return !1 }, getPointColor: function (a,
n, c) { var d, B; a = ia(a); n = Ra(n); 100 > c && aa ? (d = Math.floor(85 * (100 - 0.35 * c)) / 100, d = qa(a, d), B = Math.floor(50 * (100 + c)) / 100, a = va(a, B), n = { FCcolor: { color: a + ba + d, alpha: n + ba + n, ratio: c + ",100", radialGradient: !0, gradientUnits: "userSpaceOnUse"} }) : n = { FCcolor: { color: a + ba + a, alpha: n + ba + n, ratio: "0,100"} }; return n }, configureAxis: function (a, n) {
    var c = 0, d = a[pa], B = n.chart, b = a.xAxis.labels.style, v, Z; v = (v = Na(B.valuebordercolor, D)) ? wa(v, h(B.valueborderalpha, B.valuealpha, 100)) : D; b = { fontFamily: k(B.valuefont, b.fontFamily), fontSize: k(B.valuefontsize,
parseInt(b.fontSize, 10)) + Ta, lineHeight: b.lineHeight, color: wa(k(B.valuefontcolor, b.color), h(B.valuefontalpha, B.valuealpha, 100)), fontWeight: h(B.valuefontbold) ? "bold" : "normal", fontStyle: h(B.valuefontitalic) ? "italic" : "normal", border: v || B.valuebgcolor ? h(B.valueborderthickness, 1) + "px solid" : void 0, borderColor: v, borderThickness: h(B.valueborderthickness, 1), borderPadding: h(B.valueborderpadding, 2), borderRadius: h(B.valueborderradius, 0), backgroundColor: B.valuebgcolor ? wa(B.valuebgcolor, h(B.valuebgalpha, B.valuealpha,
100)) : D, borderDash: h(B.valueborderdashed, 0) ? Ea(h(B.valueborderdashlen, 4), h(B.valueborderdashgap, 2), h(B.valueborderthickness, 1)) : "none"
    }; a.plotOptions.series.dataLabels.style = b; delete d.x; delete d[0]; delete d[1]; a.chart.plotBorderColor = a.chart.plotBackgroundColor = Sa; d = d.pieDATALabels = []; if (1 === a.series.length && (Z = a.series[0].data) && 0 < (c = a.series[0].data.length) && a.plotOptions.series.dataLabels.enabled) for (; c--; ) Z[c] && void 0 !== ya(Z[c].displayValue) && d.push(Z[c].displayValue)
}, spaceManager: function (a,
n, c, d) {
    var B = a[pa], b = B.is3d, v = this.name, Z = this.colorManager, e = this.smartLabel || B.smartLabel, q = h(B.pieDATALabels && B.pieDATALabels.length, 0), g = 0, p = n.chart, f = h(p.managelabeloverflow, 0), l = B.preSliced || p.enableslicing !== Ba || p.showlegend === Ka && p.interactivelegend !== Ba ? h(p.slicingdistance, 20) : 0, S = h(p.pieradius, 0), O = h(p.enablesmartlabels, p.enablesmartlabel, 1), X = O ? h(p.skipoverlaplabels, p.skipoverlaplabel, 1) : 0, y = h(p.issmartlineslanted, 1), m = q ? h(p.labeldistance, p.nametbdistance, 5) : l, E = h(p.smartlabelclearance,
5); c -= a.chart.marginRight + a.chart.marginLeft; var C = d - (a.chart.marginTop + a.chart.marginBottom); d = H(C, c); var F = k(p.smartlinecolor, Z.getColor("plotFillColor")), x = h(p.smartlinealpha, 100), L = h(p.smartlinethickness, 0.7), A = a.plotOptions.series.dataLabels, G = A.style, M = q ? h(parseInt(G.lineHeight, 10), 12) : 0, Z = a.series[0] || {}, s = Z.pieYScale, W = Z.pieSliceDepth; d = 0 === S ? 0.15 * d : S; var u = 0, u = 2 * d, I = h("doughnut2d" === v ? 0 : p.placevaluesinside); A.connectorWidth = L; A.connectorPadding = h(p.connectorpadding, 5); A.connectorColor = wa(F,
x); O && q && (m = E + l); E = u + 2 * (M + m); C -= this.titleSpaceManager(a, n, c, r(E < C ? C - E : C / 2, parseFloat(a.title.style.lineHeight, 10))); p.showlegend === Ka && (k(p.legendposition, bb).toLowerCase() !== db ? C -= this.placeLegendBlockBottom(a, n, c, C / 2, !0) : c -= this.placeLegendBlockRight(a, n, c / 3, C, !0)); e.setStyle(G); if (1 !== q) for (; q--; ) n = e.getOriSize(B.pieDATALabels[q]), g = r(g, n.width); 0 === S && (b ? (C -= W, u = H(c / 2 - g, (C / 2 - M) / s) - m) : u = r(H(c / 2 - g, C / 2 - M) - m, 0), u >= d ? d = u : l = m = H(m - (d - u), l)); b && (q = C - 2 * (d * s + M), W > q && (Z.managedPieSliceDepth = W - q)); a.plotOptions.pie3d.slicedOffset =
a.plotOptions.pie.slicedOffset = l; a.plotOptions.pie3d.size = a.plotOptions.pie.size = 2 * d; a.plotOptions.series.dataLabels.distance = m; a.plotOptions.series.dataLabels.isSmartLineSlanted = y; a.plotOptions.series.dataLabels.enableSmartLabels = O; a.plotOptions.series.dataLabels.skipOverlapLabels = X; a.plotOptions.series.dataLabels.manageLabelOverflow = f; a.plotOptions.series.dataLabels.placeLabelsInside = I; if ("doughnut2d" === v || "doughnut3d" === v) if (v = h(p.doughnutradius, 0), q = (q = h(p.use3dlighting, 1)) ? h(p.radius3d, p["3dradius"],
50) : 100, 100 < q && (q = 100), 0 > q && (q = 0), p = 0 === v || v >= d ? d / 2 : v, a.plotOptions.pie3d.innerSize = a.plotOptions.pie.innerSize = 2 * p, 0 < q && aa && (p = parseInt(p / d * 100, 10), v = (100 - p) / 2, q = parseInt(v * q / 100, 10), p = p + ba + q + ba + 2 * (v - q) + ba + q, a.series[0] && a.series[0].data)) for (f = a.series[0].data, a = 0, q = f.length; a < q; a += 1) v = f[a], v.color.FCcolor && (v.color.FCcolor.ratio = p, v.rolloverProperties.color && (v.rolloverProperties.color.FCcolor.ratio = p))
}, creditLabel: xa, eiMethods: { isPlotItemSliced: function (a) {
    var n = this.jsVars.hcObj, c, d, B; return n &&
n.datasets && n.datasets[0] && (c = n.datasets[0].data) && (B = c.length) && c[a = B - a - 1] && (d = c[a].plot) && d.sliced
}, slicePlotItem: function (a, n) { var c = this.jsVars.hcObj, d, B, b, v; return c && c.datasets && (d = c.datasets[0]) && (B = d.data) && (v = B.length) && B[a = d.reversePlotOrder ? a : v - a - 1] && (b = B[a].plot) && ((!!n !== b.sliced || void 0 === n) && c.plotGraphicClick.call(b) || b.sliced) }, centerLabel: function (a, n) {
    var c = this.jsVars.hcObj, d = c.options, B = d.series[0], d = d.plotOptions.pie.innerSize, b = c.canvasLeft + 0.5 * c.canvasWidth, v = c.canvasTop + 0.5 *
c.canvasHeight, Z = B.centerLabelConfig, e; if ("object" !== typeof n) n = Z; else for (e in Z) void 0 === n[e] && (n[e] = Z[e]); n.label = a; B.centerLabelConfig = n; d && c.drawDoughnutCenterLabel(a || "", b, v, d, d, n, !0)
}, startingAngle: function (a, n) {
    var c = this.jsVars.hcObj, d = c.datasets[0].plot, B = "pie" === c.options.chart.defaultSeriesType, b, v = (b = c.datasets[0].startAngle) * (B ? -da : 1) + (0 > (B ? -1 : 1) * b ? 360 : 0); if (!isNaN(a)) {
        if (d.singletonCase || d.isRotating) return; a += n ? v : 0; B ? ((B = c.options.series[0]).startAngle = -a * T, c.rotate(d, B)) : c.rotate(a);
        v = a
    } return Y(100 * ((v %= 360) + (0 > v ? 360 : 0))) / 100
} 
}
    }, Aa); m.pie2d.eiMethods.togglePieSlice = m.pie2d.eiMethods.sliceDataItem = m.pie2d.eiMethods.slicePlotItem; m.pie2d.eiMethods.enableSlicingMovement = m.pie2d.eiMethods.enablelink = function () { ea.raiseWarning(this, "1301081430", "run", "JSRenderer~enablelink()", "Method deprecated.") }; m("pie3d", { friendlyName: "3D Pie Chart", defaultSeriesType: "pie3d", rendererId: "pie3d", creditLabel: xa, fireGroupEvent: !0, getPointColor: function (a) { return a }, defaultPlotShadow: 0 }, m.pie2d);
    m("doughnut2d", { friendlyName: "Doughnut Chart", getPointColor: function (a, n, c) { var d; a = ia(a); n = Ra(n); 100 > c && aa ? (d = qa(a, K(100 * (85 - 0.2 * (100 - c))) / 100), a = va(a, K(100 * (100 - 0.5 * c)) / 100), n = { FCcolor: { color: d + "," + a + "," + a + "," + d, alpha: n + "," + n + "," + n + "," + n, radialGradient: !0, gradientUnits: "userSpaceOnUse", r: c} }) : n = { FCcolor: { color: a + "," + a, alpha: n + "," + n, ratio: "0,100"} }; return n } }, m.pie2d); m("doughnut3d", { friendlyName: "3D Doughnut Chart", defaultSeriesType: "pie3d", rendererId: "pie3d", getPointColor: m.pie3d, defaultPlotShadow: 0 },
m.doughnut2d); m("pareto2d", { standaloneInit: !0, friendlyName: "Pareto Chart", point: function (a, n, c, d, B) {
    a = c.length; var b = 0, v = 0, Z = {}, e = this.colorManager, q = /3d$/.test(B.chart.defaultSeriesType), g = this.isBar, p = k(360 - d.plotfillangle, 90), f = k(d.showplotborder, q ? Ba : Ka) === Ka ? q ? 1 : h(d.plotborderthickness, 1) : 0, l = B.chart.useRoundEdges, S = k(d.tooltipsepchar, ", "), O = k(d.plotbordercolor, e.getColor("plotBorderColor")).split(ba)[0], m = d.showplotborder == Ba ? Ba : k(d.plotborderalpha, d.plotfillalpha, Ha), y = B.xAxis, X = h(d.showcumulativeline,
1), E = B[pa], C = E.axisGridManager, F = E.x, x = d.showtooltip != Ba, L = [], A = h(d.use3dlighting, 1), G = B[pa].numberFormatter, M = h(d.showlinevalues, d.showvalues), s = h(d.plotborderdashed, 0), W, u = h(d.plotborderdashlen, 5), I = h(d.plotborderdashgap, 4), Q = ka(d.xaxisname), R = ka(d.yaxisname), Y = E.numberFormatter, r = n, P, N, H, U, J, K, t, $, w, z, fa, V, oa, T, ja, na, la, ua, ma, da, ra, ca, aa, m = q ? d.showplotborder ? m : Ba : m, O = q ? k(d.plotbordercolor, "#FFFFFF") : O; H = h(d.useplotgradientcolor, 1) ? Ya(d.plotgradientcolor, e.getColor("plotGradientColor")) : D; for (ja =
N = 0; N < a; N += 1) ma = c[N], c[N].vline ? C.addVline(y, ma, ja, B) : (P = G.getCleanValue(ma.value, !0), null !== P && (v += ma.value = P, L.push(ma), ja += 1)); a = L.length; L.sort(function (a, c) { return c.value - a.value }); X && 0 < v ? (z = h(d.linedashed, 0), da = ia(k(d.linecolor, e.getColor("plotBorderColor"))), Z = k(d.linealpha, 100), fa = h(d.linedashlen, 5), U = h(d.linedashgap, 4), N = h(d.linethickness, 2), oa = { opacity: Z / 100 }, T = h(d.drawanchors, d.showanchors), void 0 === T && (T = Z != Ba), la = h(d.anchorborderthickness, 1), ua = h(d.anchorsides, 0), W = h(d.anchorradius,
3), na = ia(k(d.anchorbordercolor, da)), P = ia(k(d.anchorbgcolor, e.getColor("anchorBgColor"))), ja = Ra(k(d.anchoralpha, Ha)), c = Ra(k(d.anchorbgalpha, ja)) * ja / 100, z = z ? Ea(fa, U, N) : void 0, U = Boolean(h(ma.anchorshadow, d.anchorshadow, 0)), fa = this.pointHoverOptions(ma, n, { plotType: "anchor", anchorBgColor: P, anchorAlpha: ja, anchorBgAlpha: c, anchorAngle: k(d.anchorstartangle, 90), anchorBorderThickness: la, anchorBorderColor: na, anchorBorderAlpha: ja, anchorSides: ua, anchorRadius: W, shadow: V }), Z = { yAxis: 1, data: [], type: "line", color: { FCcolor: { color: da,
    alpha: Z
}
}, lineWidth: N, marker: { enabled: T, shadow: U && 1 <= W ? { opacity: ja / 100} : !1, fillColor: { FCcolor: { color: P, alpha: c} }, lineColor: { FCcolor: { color: na, alpha: ja} }, lineWidth: la, radius: W, symbol: fb(ua), startAngle: k(d.anchorstartangle, 90)}
}, r = [r, Z], E[1] || (E[1] = {}), E[1].stacking100Percent = !0) : ("1" !== d.showsecondarylimits && (d.showsecondarylimits = "0"), "1" !== d.showdivlinesecondaryvalue && (d.showdivlinesecondaryvalue = "0")); E[1] || (E[1] = {}); E[1].stacking100Percent = !0; for (N = 0; N < a; N += 1) ma = L[N], V = h(ma.showlabel, d.showlabels,
1), c = ka(V ? Na(ma.label, ma.name) : D), C.addXaxisCat(y, N, N, c), b += P = ma.value, U = h(ma.dashed, s), J = k(ma.dashgap, I), K = k(ma.dashlen, u), t = k(ma.color, e.getPlotColor()), $ = k(ma.alpha, d.plotfillalpha, Ha), w = k(ma.ratio, d.plotfillratio), V = { opacity: $ / 100 }, ra = k(ma.alpha, m) + D, da = Ja(t + ba + H.replace(/,+?$/, ""), $, w, p, l, O + D, ra + D, g, q), W = U ? Ea(K, J, f) : "none", ja = b / v * 100, la = G.percentValue(ja), na = null === P ? P : Y.dataLabels(P), ua = ya(ka(ma.displayvalue)), ua = h(ma.showvalue, E.showValues) ? void 0 !== ua ? ua : na : D, E.showTooltip ? void 0 !== (T = ya(ka(k(ma.tooltext,
E.tooltext)))) ? (ca = { formattedValue: na, label: c, yaxisName: R, xaxisName: Q, cumulativeValue: b, cumulativeDataValue: Y.dataLabels(b), cumulativePercentValue: la, sum: Y.dataLabels(v), unformattedSum: v }, aa = [1, 2, 3, 5, 6, 7, 20, 21, 22, 23, 24, 25], T = Ga(T, aa, ca, ma, d)) : T = null === na ? !1 : c !== D ? c + E.tooltipSepChar + na : na : T = D, J = this.pointHoverOptions(ma, n, { plotType: "column", is3d: q, isBar: g, use3DLighting: A, isRoundEdged: l, color: t, gradientColor: H, alpha: $, ratio: w, angle: p, borderWidth: f, borderColor: O, borderAlpha: ra, borderDashed: U, borderDashGap: J,
    borderDashLen: K, shadow: V
}), U = k(ma.link), n.data.push({ link: U, toolText: T, displayValue: ua, categoryLabel: c, y: P, shadow: V, color: da[0], borderColor: da[1], borderWidth: f, use3DLighting: A, dashStyle: W, tooltipConstraint: this.tooltipConstraint, hoverEffects: J.enabled && J.options, rolloverProperties: J.enabled && J.rolloverOptions }), this.pointValueWatcher(B, P), X && (P = ya(ka(k(ma.cumulativeplottooltext, d.cumulativeplottooltext))), V = 1 == M ? la : 0 === M || ua === D ? D : la, T = x ? void 0 !== P ? Ga(P, aa || [1, 2, 3, 5, 6, 7, 20, 21, 22, 23, 24, 25], ca || { formattedValue: na,
    label: c, yaxisName: R, xaxisName: Q, cumulativeValue: b, cumulativeDataValue: Y.dataLabels(b), cumulativePercentValue: la, sum: Y.dataLabels(v), unformattedSum: v
}, ma, d) : (c !== D ? c + S : D) + la : D, Z.data.push({ shadow: oa, color: Z.color, marker: Z.marker, y: ja, toolText: T, displayValue: V, categoryLabel: c, link: U, dashStyle: z, hoverEffects: fa.enabled && fa.options, rolloverProperties: fa.enabled && fa.rolloverOptions })); F.catCount = a; return r
}, defaultSeriesType: "column", isDual: !0, creditLabel: xa, rendererId: "cartesian"
}, Aa); m("pareto3d", { friendlyName: "3D Pareto Chart",
    defaultSeriesType: "column3d", defaultPlotShadow: 1, is3D: !0
}, m.pareto2d); m("mscolumn2d", { standaloneInit: !0, friendlyName: "Multi-series Column Chart", creditLabel: xa, rendererId: "cartesian" }, m.mscolumn2dbase); m("mscolumn3d", { defaultSeriesType: "column3d", friendlyName: "Multi-series 3D Column Chart", defaultPlotShadow: 1, is3D: !0, defaultZeroPlaneHighlighted: !1 }, m.mscolumn2d); m("msbar2d", { friendlyName: "Multi-series Bar Chart", isBar: !0, defaultSeriesType: "bar", spaceManager: m.barbase }, m.mscolumn2d); m("msbar3d", { defaultSeriesType: "bar3d",
    friendlyName: "Multi-series 3D Bar Chart", defaultPlotShadow: 1, is3D: !0, defaultZeroPlaneHighlighted: !1
}, m.msbar2d); m("msline", { standaloneInit: !0, friendlyName: "Multi-series Line Chart", creditLabel: xa, rendererId: "cartesian" }, m.mslinebase); m("msarea", { standaloneInit: !0, friendlyName: "Multi-series Area Chart", creditLabel: xa, rendererId: "cartesian" }, m.msareabase); m("stackedcolumn2d", { friendlyName: "Stacked Column Chart", isStacked: !0 }, m.mscolumn2d); m("stackedcolumn3d", { friendlyName: "3D Stacked Column Chart",
    isStacked: !0
}, m.mscolumn3d); m("stackedbar2d", { friendlyName: "Stacked Bar Chart", isStacked: !0 }, m.msbar2d); m("stackedbar3d", { friendlyName: "3D Stacked Bar Chart", isStacked: !0 }, m.msbar3d); m("stackedarea2d", { friendlyName: "Stacked Area Chart", isStacked: !0, areaAlpha: 100, showSum: 0 }, m.msarea); m("marimekko", { friendlyName: "Marimekko Chart", isValueAbs: !0, distributedColumns: !0, isStacked: !0, xAxisMinMaxSetter: $a, postSeriesAddition: function (a, n) {
    var c = a[pa], d = 0, B = a.xAxis, b = 100 / c.marimekkoTotal, v = [], Z = a.series, e = 0,
q = za({}, a.plotOptions.series.dataLabels.style), g = parseInt(q.fontSize, 10), p = h(n.chart.plotborderthickness, 1), f = a.chart.rotateValues, l = h(n.chart.rotatexaxispercentvalues, 0), S = -0.5 * p - (p % 2 + (l ? 1 : 0) + !a.chart.plotBorderWidth), O = l ? g / 2 * 1.2 : 0, m = f ? 270 : 0, y = c[0], X = y.stacking100Percent, E = !X, C = c.inCanvasStyle, k = this.numberFormatter, F = n.categories && n.categories[0] && n.categories[0].category || [], L = 0, A = [], G, M, x, W, u, I, Q, R, s, r, p = []; c.isXYPlot = !0; c.distributedColumns = !0; B.min = 0; B.max = 100; B.labels.enabled = !1; B.gridLineWidth =
0; B.alternateGridColor = Sa; G = y.stack; n.chart.interactivelegend = "0"; y = 0; for (M = a.xAxis.plotLines.length; y < M; y += 1) x = B.plotLines[y], x.isGrid && (x.isCat = !0, v[x.value] = x, x._hideLabel = !0); for (y = M = 0; y < F.length; y += 1) F[y].vline || (L += A[M] = k.getCleanValue(F[y].widthpercent || 0), M += 1); F = G.floatedcolumn && G.floatedcolumn[0] || []; if (100 === L && (F && F.length) !== M) for (; M--; ) F[M] || (F[M] = { p: null }); L = Y(L); if (F) for (u = 0, M = F.length; u < M; ) {
        r = F[u]; d += W = r && r.p || 0; Q = 100 === L ? A[u] : W * b; I = e + Q / 2; R = e + Q; p.push(R); for (y = 0; y < Z.length; y += 1) if (a.series[y].visible =
!0, G = a.series[y].data[u], G._FCX = e, G._FCW = Q, s = k.percentValue(G.y / W * 100), G.toolText = Ga(G.toolText, [14, 24, 25, 111, 112], { xAxisPercentValue: k.percentValue(Q), percentValue: s, sum: k.dataLabels(W), unformattedSum: W }), X) { if (G.y || 0 === G.y) x = G.y / W * 100, G.y = x, G.showPercentValues && (G.displayValue = s); if (G.previousY || 0 === G.previousY) G.previousY = G.previousY / W * 100 } c.showStackTotal && a.xAxis.plotLines.push({ value: I, width: 0, isVline: E, isTrend: !E, _isStackSum: 1, zIndex: 4, label: { align: Wa, textAlign: Wa, rotation: m, style: q, verticalAlign: cb,
    offsetScale: E ? 0 > W ? r.n : r.p : void 0, offsetScaleIndex: 0, y: 0 > W ? 270 === f ? 4 : g : -4, x: 0, text: k.yAxis(Za(W, 10))
}
}); v[u] && (v[u].value = I, v[u]._weight = Q, v[u]._hideLabel = !1); u += 1; c.showXAxisPercentValues && u < M && a.xAxis.plotLines.push({ value: R, width: 0, isVine: !0, label: { align: Wa, textAlign: l ? eb : Wa, rotation: l ? 270 : 0, backgroundColor: "#ffffff", backgroundOpacity: 1, borderWidth: "1px", borderType: "solid", borderColor: C.color, style: { color: C.color, fontSize: C.fontSize, fontFamily: C.fontFamily, lineHeight: C.lineHeight }, verticalAlign: bb,
    y: S, x: O, text: this.numberFormatter.percentValue(R)
}, zIndex: 5
}); e = R
    } u = 0; for (M = v.length; u < M; u += 1) v[u] && v[u]._hideLabel && (v[u].value = null); y = 0; for (M = a.xAxis.plotLines.length; y < M; y += 1) if (x = B.plotLines[y], x.isVline && !x._isStackSum && (c = x.value)) c = Y(c - 0.5), x.value = p[c]
}, defaultSeriesType: "floatedcolumn"
}, m.stackedcolumn2d); m("msstackedcolumn2d", { friendlyName: "Multi-series Stacked Column Chart", series: function (a, n, c) {
    var d, B, b, v, Z = n[pa], e = 0, q, g; q = []; var p; n.legend.enabled = Boolean(h(a.chart.showlegend, 1));
    if (a.dataset && 0 < a.dataset.length) {
        this.categoryAdder(a, n); d = 0; for (B = a.dataset.length; d < B; d += 1) if (p = a.dataset[d].dataset) for (b = 0, v = p.length; b < v; b += 1, e += 1) q = { hoverEffects: this.parseSeriesHoverOptions(a, n, p[b], c), visible: !h(p[b].initiallyhidden, 0), data: [], numColumns: B, columnPosition: d }, g = Math.min(Z.oriCatTmp.length, p[b].data && p[b].data.length), q = this.point(c, q, p[b], a.chart, n, g, e, d), n.series.push(q); if (this.isDual && a.lineset && 0 < a.lineset.length) for (b = 0, v = a.lineset.length; b < v; b += 1, e += 1) d = a.lineset[b],
q = { hoverEffects: this.parseSeriesHoverOptions(a, n, d, c), visible: !h(d.initiallyhidden, 0), data: [], yAxis: 1, type: "line" }, g = Math.min(Z.oriCatTmp.length, d.data && d.data.length), n.series.push(m.msline.point.call(this, "msline", q, d, a.chart, n, g, e)); this.configureAxis(n, a); a.trendlines && Xa(a.trendlines, n.yAxis, n[pa], this.isDual, this.isBar)
    } 
}, postSpaceManager: function (a, n, c) {
    var d = a[pa], B, b, v; if (this.isStacked && d.showStackTotal && (B = a.chart, a = (n = a.xAxis) && n.plotLines, B = c - B.marginLeft - B.marginRight, c = d.plotSpacePercent,
d = d[0].stack, d = d.column && d.column.length, b = (1 - 2 * c) / d, n = B / (n.max - n.min), 50 < n * b && 0.1 == c)) for (n = 50 / n, c = a && a.length, d = -((d - 1) / 2) * n, v = 0; v < c; v += 1) b = a[v], b._isStackSum && (B = b._catPosition + (d + n * b._stackIndex), b.value = B)
} 
}, m.stackedcolumn2d); m("mscombi2d", { friendlyName: "Multi-series Combination Chart", standaloneInit: !0, creditLabel: xa, rendererId: "cartesian" }, m.mscombibase); m("mscombi3d", { friendlyName: "Multi-series 3D Combination Chart", series: m.mscombi2d.series, eiMethods: function (a) {
    var n = {}; ta(a.split(","),
function (a) { n[a] = function () { ea.raiseWarning(this, "1301081430", "run", "JSRenderer~" + a + "()", "Method not applicable.") } }); return n
} ("view2D,view3D,resetView,rotateView,getViewAngles,fitToStage")
}, m.mscolumn3d); m("mscolumnline3d", { friendlyName: "Multi-series Column and Line Chart" }, m.mscombi3d); m("stackedcolumn2dline", { friendlyName: "Stacked Column and Line Chart", isStacked: !0, stack100percent: 0 }, m.mscombi2d); m("stackedcolumn3dline", { friendlyName: "Stacked 3D Column and Line Chart", isStacked: !0, stack100percent: 0 },
m.mscombi3d); m("mscombidy2d", { friendlyName: "Multi-series Dual Y-Axis Combination Chart", isDual: !0, secondarySeriesType: void 0 }, m.mscombi2d); m("mscolumn3dlinedy", { friendlyName: "Multi-series 3D Column and Line Chart", isDual: !0, secondarySeriesType: "line" }, m.mscolumnline3d); m("stackedcolumn3dlinedy", { friendlyName: "Stacked 3D Column and Line Chart", isDual: !0, secondarySeriesType: "line" }, m.stackedcolumn3dline); m("msstackedcolumn2dlinedy", { friendlyName: "Multi-series Dual Y-Axis Stacked Column and Line Chart",
    isDual: !0, stack100percent: 0, secondarySeriesType: "line"
}, m.msstackedcolumn2d); m("scrollcolumn2d", { friendlyName: "Scrollable Multi-series Column Chart", postSeriesAddition: m.scrollbase.postSeriesAddition, tooltipConstraint: "plot", canvasborderthickness: 1, avgScrollPointWidth: 40 }, m.mscolumn2d); m("scrollline2d", { friendlyName: "Scrollable Multi-series Line Chart", postSeriesAddition: m.scrollbase.postSeriesAddition, tooltipConstraint: "plot", canvasborderthickness: 1, avgScrollPointWidth: 75 }, m.msline); m("scrollarea2d",
{ friendlyName: "Scrollable Multi-series Area Chart", postSeriesAddition: m.scrollbase.postSeriesAddition, tooltipConstraint: "plot", canvasborderthickness: 1, avgScrollPointWidth: 75 }, m.msarea); m("scrollstackedcolumn2d", { friendlyName: "Scrollable Stacked Column Chart", postSeriesAddition: function (a, n, c, d) { m.base.postSeriesAddition.call(this, a, n, c, d); m.scrollbase.postSeriesAddition.call(this, a, n, c, d) }, canvasborderthickness: 1, tooltipConstraint: "plot", avgScrollPointWidth: 75 }, m.stackedcolumn2d); m("scrollcombi2d",
{ friendlyName: "Scrollable Combination Chart", postSeriesAddition: m.scrollbase.postSeriesAddition, tooltipConstraint: "plot", canvasborderthickness: 1, avgScrollPointWidth: 40 }, m.mscombi2d); m("scrollcombidy2d", { friendlyName: "Scrollable Dual Y-Axis Combination Chart", postSeriesAddition: m.scrollbase.postSeriesAddition, tooltipConstraint: "plot", canvasborderthickness: 1, avgScrollPointWidth: 40 }, m.mscombidy2d); m("scatter", { friendlyName: "Scatter Chart", isXY: !0, standaloneInit: !0, defaultSeriesType: "scatter", defaultZeroPlaneHighlighted: !1,
    creditLabel: xa
}, m.scatterbase); m("bubble", { friendlyName: "Bubble Chart", standaloneInit: !0, standaloneInut: !0, defaultSeriesType: "bubble", rendererId: "bubble", point: function (a, n, c, d, b) {
    a = h(d.ignoreemptydatasets, 0); var e = !1, v = this.colorManager, Z, g, q, f, p, l, m, S, O, X, y, x, E, C, F, W, L = h(c.showvalues, b[pa].showValues); Z = h(d.bubblescale, 1); var A = k(d.negativecolor, "FF0000"), G = b.plotOptions.bubble, M = this.numberFormatter, s = n._showRegression = h(c.showregressionline, d.showregressionline, 0), Y, u, I, Q; n.name = ya(c.seriesname);
    q = Boolean(h(c.drawanchors, c.showanchors, d.drawanchors, 1)); S = k(c.plotfillalpha, c.bubblefillalpha, d.plotfillalpha, Ha); O = h(c.showplotborder, d.showplotborder, 1); X = ia(k(c.plotbordercolor, d.plotbordercolor, "666666")); y = k(c.plotborderthickness, d.plotborderthickness, 1); x = k(c.plotborderalpha, d.plotborderalpha, "95"); O = 1 === O ? y : 0; v = k(c.color, c.plotfillcolor, d.plotfillcolor, v.getPlotColor()); n.marker = { enabled: q, fillColor: this.getPointColor(v, Ha), lineColor: { FCcolor: { color: X, alpha: x} }, lineWidth: O, symbol: "circle" };
    if (y = c.data) {
        W = y.length; G.bubbleScale = Z; if (0 === h(c.includeinlegend) || void 0 === n.name) n.showInLegend = !1; s && (n.events = { hide: this.hideRLine, show: this.showRLine }, Y = { sumX: 0, sumY: 0, sumXY: 0, sumXsqure: 0, sumYsqure: 0, xValues: [], yValues: [] }, u = h(c.showyonx, d.showyonx, 1), I = ia(k(c.regressionlinecolor, d.regressionlinecolor, v)), Q = h(c.regressionlinethickness, d.regressionlinethickness, 1), Z = Ra(h(c.regressionlinealpha, d.regressionlinealpha, 100)), I = wa(I, Z)); for (g = 0; g < W; g += 1) (f = y[g]) ? (Z = M.getCleanValue(f.y), E = M.getCleanValue(f.x),
C = M.getCleanValue(f.z, !0), null === Z ? n.data.push({ y: null, x: E }) : (e = !0, m = 0 !== h(d.use3dlighting, f.is3d, c.is3d, d.is3d), p = ia(k(f.color, 0 > f.z ? A : v)), l = k(f.alpha, S), F = this.getPointStub(f, Z, E, b, c, L), p = m ? this.getPointColor(p, l) : wa(p, l), null !== C && (G.zMax = G.zMax > C ? G.zMax : C, G.zMin = G.zMin < C ? G.zMin : C), f = this.pointHoverOptions(f, n, { plotType: "bubble", is3d: m, seriesAnchorSymbol: "circle", color: p, negativeColor: A, alpha: l, borderWidth: O, borderColor: X, borderAlpha: x, shadow: !1 }), n.data.push({ y: Z, x: E, z: C, displayValue: F.displayValue,
    toolText: F.toolText, link: F.link, hoverEffects: f.enabled && f.options, rolloverProperties: f.enabled && f.rolloverOptions, marker: { enabled: q, fillColor: p, lineColor: { FCcolor: { color: X, alpha: x} }, lineWidth: O, symbol: "circle"}
}), this.pointValueWatcher(b, Z, E, s && Y))) : n.data.push({ y: null }); s && (c = { type: "line", color: I, showInLegend: !1, lineWidth: Q, enableMouseTracking: !1, marker: { enabled: !1 }, data: this.getRegressionLineSeries(Y, u, W), zIndex: 0 }, n = [n, c])
    } a && !e && (n.showInLegend = !1); return n
}, getPointStub: function (a, n, c, d, b, e) {
    var v =
this.dataObj.chart; d = d[pa]; n = null === n ? n : d.numberFormatter.dataLabels(n); var Z, g = d.tooltipSepChar, q = ya(ka(k(a.tooltext, b.plottooltext, d.tooltext))); d.showTooltip ? void 0 !== q ? b = Ga(q, [4, 5, 6, 7, 8, 9, 10, 11, 12, 13], { yDataValue: n, xDataValue: c, yaxisName: ka(v.yaxisname), xaxisName: ka(v.xaxisname) }, a, v, b) : null === n ? b = !1 : (d.seriesNameInToolTip && (Z = k(b && b.seriesname)), b = Z ? Z + g : D, b += c ? c + g : D, b = b + n + (a.z ? g + a.z : D)) : b = D; c = h(a.showvalue, e, d.showValues) ? void 0 !== k(a.displayvalue, a.name, a.label) ? ka(k(a.displayvalue, a.name, a.label)) :
n : D; a = ya(a.link); return { displayValue: c, toolText: b, link: a}
} 
}, m.scatter); m("ssgrid", { friendlyName: "Grid Component", standaloneInit: !0, defaultSeriesType: "ssgrid", rendererId: "ssgrid", chart: function (a, n) {
    var c = this.containerElement, d = za({}, this.dataObj), b = d.chart || (d.chart = d.graph || {}), e = this.chartInstance, v = 0, Z = [], g = d.data, q = g && g.length, f = this.smartLabel, p = this.numberFormatter, l = c.offsetHeight, X = c.offsetWidth, S = this.colorManager, O, x, y, F, E, C, W, s, L, A, G, M, Y, r, u, I, Q, R, H, K, P, N, $, U, J, t = 0; x = 0; var c = { _FCconf: { 0: { stack: {} },
        1: { stack: {} }, x: { stack: {} }, noWrap: !1, marginLeftExtraSpace: 0, marginRightExtraSpace: 0, marginBottomExtraSpace: 0, marginTopExtraSpace: 0, marimekkoTotal: 0
    }, chart: { renderTo: c, ignoreHiddenSeries: !1, events: {}, spacingTop: 0, spacingRight: 0, spacingBottom: 0, spacingLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0, marginLeft: 0, borderRadius: 0, borderColor: "#000000", borderWidth: 1, defaultSeriesType: "ssgrid", style: { fontFamily: k(b.basefont, "Verdana,sans"), fontSize: Va(b.basefontsize, 20) + Ta, color: k(b.basefontcolor, S.getColor("baseFontColor")).replace(/^#?([a-f0-9]+)/ig,
"#$1")
    }, plotBackgroundColor: Sa
    }, labels: { smartLabel: f }, colors: "AFD8F8 F6BD0F 8BBA00 FF8E46 008E8E D64646 8E468E 588526 B3AA00 008ED6 9D080D A186BE CC6600 FDC689 ABA000 F26D7D FFF200 0054A6 F7941C CC3300 006600 663300 6DCFF6".split(" "), credits: { href: w.CREDIT_HREF, text: w.CREDIT_STRING, enabled: xa }, legend: { enabled: !1 }, series: [], subtitle: { text: D }, title: { text: D }, tooltip: { enabled: !1 }, exporting: { buttons: { exportButton: {}, printButton: { enabled: !1}}}
    }, fa = c[pa], V = O = x = t = 0, T = v = r = 0; J = e.jsVars.cfgStore; e = c.chart;
    E = e.toolbar = { button: {} }; C = E.button; delete d.graph; ab(c.chart.style); e.events.click = this.linkClickFN; C.scale = h(b.toolbarbuttonscale, 1.15); C.width = h(b.toolbarbuttonwidth, 15); C.height = h(b.toolbarbuttonheight, 15); C.radius = h(b.toolbarbuttonradius, 2); C.spacing = h(b.toolbarbuttonspacing, 5); C.fill = wa(k(b.toolbarbuttoncolor, "ffffff")); C.labelFill = wa(k(b.toolbarlabelcolor, "cccccc")); C.symbolFill = wa(k(b.toolbarsymbolcolor, "ffffff")); C.hoverFill = wa(k(b.toolbarbuttonhovercolor, "ffffff")); C.stroke = wa(k(b.toolbarbuttonbordercolor,
"bbbbbb")); C.symbolStroke = wa(k(b.toolbarsymbolbordercolor, "9a9a9a")); C.strokeWidth = h(b.toolbarbuttonborderthickness, 1); C.symbolStrokeWidth = h(b.toolbarsymbolborderthickness, 1); d = C.symbolPadding = h(b.toolbarsymbolpadding, 5); C.symbolHPadding = h(b.toolbarsymbolhpadding, d); C.symbolVPadding = h(b.toolbarsymbolvpadding, d); C = E.position = k(b.toolbarposition, "tr").toLowerCase(); switch (C) { case "tr": case "tl": case "br": case "bl": break; default: C = "tr" } d = E.hAlign = "left" === (D + b.toolbarhalign).toLowerCase() ? "l" : C.charAt(1);
    C = E.vAlign = "bottom" === (D + b.toolbarvalign).toLowerCase() ? "b" : C.charAt(0); E.hDirection = h(b.toolbarhdirection, "r" === d ? -1 : 1); E.vDirection = h(b.toolbarvdirection, "b" === C ? -1 : 1); E.vMargin = h(b.toolbarvmargin, 6); E.hMargin = h(b.toolbarhmargin, 10); E.x = h(b.toolbarx, "l" === d ? 0 : a); E.y = h(b.toolbary, "t" === C ? 0 : n); void 0 !== k(b.clickurl) && (e.link = b.clickurl, e.style.cursor = "pointer"); O = h(J.showpercentvalues, b.showpercentvalues, 0); x = k(J.numberitemsperpage, b.numberitemsperpage); h(J.showshadow, b.showshadow, 0); v = k(J.basefont,
b.basefont, "Verdana,sans"); y = Va(J.basefontsize, b.basefontsize, 10); y += Ta; F = ia(k(J.basefontcolor, b.basefontcolor, S.getColor("baseFontColor"))); d = ia(k(J.alternaterowbgcolor, b.alternaterowbgcolor, S.getColor("altHGridColor"))); E = k(J.alternaterowbgalpha, b.alternaterowbgalpha, S.getColor("altHGridAlpha")) + D; C = h(J.listrowdividerthickness, b.listrowdividerthickness, 1); W = ia(k(J.listrowdividercolor, b.listrowdividercolor, S.getColor("borderColor"))); s = h(J.listrowdivideralpha, b.listrowdivideralpha, S.getColor("altHGridAlpha")) +
15 + D; L = h(J.colorboxwidth, b.colorboxwidth, 8); A = h(J.colorboxheight, b.colorboxheight, 8); G = h(J.navbuttonradius, b.navbuttonradius, 7); M = ia(k(J.navbuttoncolor, b.navbuttoncolor, S.getColor("canvasBorderColor"))); Y = ia(k(J.navbuttonhovercolor, b.navbuttonhovercolor, S.getColor("altHGridColor"))); r = h(J.textverticalpadding, b.textverticalpadding, 3); u = h(J.navbuttonpadding, b.navbuttonpadding, 5); I = h(J.colorboxpadding, b.colorboxpadding, 10); Q = h(J.valuecolumnpadding, b.valuecolumnpadding, 10); R = h(J.namecolumnpadding, b.namecolumnpadding,
5); H = h(J.borderthickness, b.borderthickness, 1); K = ia(k(J.bordercolor, b.bordercolor, S.getColor("borderColor"))); P = k(J.borderalpha, b.borderalpha, S.getColor("borderAlpha")) + D; N = k(J.bgcolor, b.bgcolor, "FFFFFF"); $ = k(J.bgalpha, b.bgalpha, Ha); U = k(J.bgratio, b.bgratio, Ha); J = k(J.bgangle, b.bgangle, Ba); e.borderRadius = H / 16; e.borderWidth = H; e.borderColor = z({ FCcolor: { color: K, alpha: P} }); e.backgroundColor = { FCcolor: { color: N, alpha: $, ratio: U, angle: J} }; e.borderRadius = h(b.borderradius, 0); J = { fontFamily: v, fontSize: y, color: F };
    ab(J); f.setStyle(J); for (v = 0; v < q; v += 1) if (y = g[v], H = p.getCleanValue(y.value), K = ka(Na(y.label, y.name)), F = ia(k(y.color, S.getPlotColor())), k(y.alpha, b.plotfillalpha, Ha), K != D || null != H) Z.push({ value: H, label: K, color: F }), t += H, T += 1; for (v = 0; v < T; v += 1) y = Z[v], H = y.value, y.dataLabel = y.label, y.displayValue = O ? p.percentValue(H / t * 100) : p.dataLabels(H), g = f.getOriSize(y.displayValue), V = Math.max(V, g.width + Q); x ? x >= T ? (O = l / T, x = T) : (p = l - 2 * (u + G), O = p / x) : (t = parseInt(J.lineHeight, 10), t = Math.max(t + 2 * r, A), x = l / t, x >= T ? (O = l / T, x = T) : (p =
l - 2 * (u + G), x = Math.floor(p / t), O = p / x)); r = X - I - L - R - V - Q; v = I + L + R; p = k(b.basefont, "Verdana,sans"); V = Va(b.basefontsize, 10); S = k(b.basefontcolor, S.getColor("baseFontColor")); g = k(b.outcnvbasefont, p); y = Va(b.outcnvbasefontsize, V); q = y + Ta; b = k(b.outcnvbasefontcolor, S).replace(/^#?([a-f0-9]+)/ig, "#$1"); V += Ta; S = S.replace(/^#?([a-f0-9]+)/ig, "#$1"); fa.trendStyle = fa.outCanvasStyle = { fontFamily: g, color: b, fontSize: q }; ab(fa.trendStyle); fa.inCanvasStyle = { fontFamily: p, fontSize: V, color: S }; c.tooltip.style = { fontFamily: p, fontSize: V,
    lineHeight: void 0, color: S
}; c.tooltip.shadow = !1; e.height = l; e.width = X; e.rowHeight = O; e.labelX = v; e.colorBoxWidth = L; e.colorBoxHeight = A; e.colorBoxX = I; e.valueX = I + L + R + r + Q; e.valueColumnPadding = Q; e.textStyle = J; e.listRowDividerAttr = { "stroke-width": C, stroke: { FCcolor: { color: W, alpha: s}} }; e.alternateRowColor = { FCcolor: { color: d, alpha: E} }; e.navButtonRadius = G; e.navButtonPadding = u; e.navButtonColor = M; e.navButtonHoverColor = Y; e.lineHeight = parseInt(J.lineHeight, 10); l = []; X = 0; fa = !0; for (v = 0; v < T & 0 !== x; v += 1) 0 === v % x && (l.push({ data: [],
    visible: fa
}), fa = !1, X += 1), y = Z[v], b = f.getSmartText(y.dataLabel, r, O), l[X - 1].data.push({ label: b.text, originalText: b.tooltext, displayValue: y.displayValue, y: y.value, color: y.color }); c.series = l; m.base.parseExportOptions.call(this, c); c.tooltip.enabled = !!c.exporting.enabled; return c
}, creditLabel: xa
}, m.base); m("renderer.bubble", { drawPlotBubble: function (a, n) {
    var c = this, d = c.options, B = d.chart, g = d.plotOptions.series, v = c.paper, Z = c.elements, f = a.items, q = a.graphics = a.graphics || [], l = c.xAxis[n.xAxis || 0], p = c.yAxis[n.yAxis ||
0], X = a.data, m = !1 !== (d.tooltip || {}).enabled, S, O, g = isNaN(+g.animation) && g.animation.duration || 1E3 * g.animation, x = !1 === n.visible ? "hidden" : "visible", d = d.plotOptions.bubble, y = d.zMax, d = d.bubbleScale, F = H(c.canvasHeight, c.canvasWidth) / 8, y = Fa(y), E, C, k, W, L, A, G, M, s, r, u, I = c.layers; E = I.dataset = I.dataset || v.group("dataset-orphan"); var Q = I.tracker, R, t, K = function (a) { sa.call(this, c, a) }, P = function (a, b, d) { return function (n) { a.attr(b); sa.call(this, c, n, d) } }; I.datalabels || (I.datalabels = v.group("datalables").insertAfter(E));
    I = E.bubble = E.bubble || v.group("bubble", E); B.clipBubbles && !I.attrs["clip-rect"] && I.attr({ "clip-rect": Z["clip-canvas"] }); E = 0; for (C = X.length; E < C; E += 1) {
        k = X[E]; r = u = t = null; s = k.marker; if (null !== k.y && s && s.enabled) {
            W = k.link; B = k.toolText; L = h(k.x, E); A = k.y; Z = { index: E, link: W, value: A, y: A, x: L, z: k.z, displayValue: k.displayValue, toolText: k.toolText, id: a.userID, datasetIndex: a.index, datasetName: a.name, visible: a.visible }; M = p.getAxisPosition(A); G = l.getAxisPosition(L); O = Fa(k.z); R = Y(O * F / y) * d || 0; O = S = {}; k.hoverEffects && (O =
{ fill: z(s.fillColor), "stroke-width": s.lineWidth, stroke: z(s.lineColor), r: R }, S = k.rolloverProperties, S = { fill: z(S.fillColor), "stroke-width": S.lineWidth, stroke: z(S.lineColor), r: R * S.scale }); r = v.circle(G, M, 0, I).attr({ fill: z(s.fillColor), "stroke-width": s.lineWidth, stroke: z(s.lineColor), visibility: x }).animate({ r: R || 0 }, g, "easeOut", c.getAnimationCompleteFn()); if (W || m) R < b && (R = b), u = v.circle(G, M, R, Q).attr({ cursor: W ? "pointer" : "", stroke: e, "stroke-width": s.lineWidth, fill: e, ishot: !!W, visibility: x }); (u || r).data("eventArgs",
Z).click(K).hover(P(r, S, "DataPlotRollOver"), P(r, O, "DataPlotRollOut")).tooltip(B); f[E] = { index: E, x: L, y: A, z: k.z, value: A, graphic: r, dataLabel: t, tracker: u }; t = c.drawPlotLineLabel(a, n, E, G, M)
        } else f[E] = { index: E, x: L, y: A }; t && q.push(t); r && q.push(r); u && q.push(u)
    } a.visible = !1 !== n.visible; return a
} 
}, m["renderer.cartesian"]); m("renderer.ssgrid", { drawGraph: function () {
    var a = this.options.series, b = this.elements, c = b.plots, d = a.length, B; c || (c = this.plots = this.plots || [], b.plots = c); this.drawSSGridNavButton(); for (B = 0; B < d; B++) (b =
c[B]) || c.push(b = { items: [], data: a[B].data }), a[B].data && a[B].data.length && this.drawPlot(b, a[B]); 1 < d && this.nenagitePage(0)
}, drawPlot: function (a) {
    var b = a.data, c = this.paper, d = this.options.chart, B = d.colorBoxHeight, e = d.colorBoxWidth, v = d.colorBoxX, Z = d.labelX, f = d.valueX, q = d.rowHeight, l = d.width, p = d.listRowDividerAttr, h = p["stroke-width"], p = z(p.stroke), m = h % 2 / 2, x = d.textStyle, O = this.layers, O = O.dataset = O.dataset || c.group("dataset-orphan"), d = z(d.alternateRowColor); a = a.items; var k = 0, y, F, E, C; b && b.length || (b = []); p =
{ stroke: p, "stroke-width": h }; C = 0; for (h = b.length; C < h; C += 1) E = b[C], F = E.y, y = a[C] = { index: C, value: F, graphic: null, dataLabel: null, dataValue: null, alternateRow: null, listRowDivider: null, hot: null }, null !== F && void 0 !== F && (0 === C % 2 && (y.alternateRow = c.rect(0, k, l, q, 0, O).attr({ fill: d, "stroke-width": 0 })), F = Y(k) + m, y.listRowDivider = c.path([g, 0, F, X, l, F], O).attr(p), y.graphic = c.rect(v, k + q / 2 - B / 2, e, B, 0, O).attr({ fill: E.color, "stroke-width": 0, stroke: "#000000" }), F = y.dataLabel = c.text().attr({ text: E.label, title: E.originalText || "",
    x: Z, y: k + q / 2, fill: x.color, "text-anchor": "start"
}).css(x), O.appendChild(F), y = y.dataValue = c.text().attr({ text: E.displayValue, title: E.originalText || "", x: f, y: k + q / 2, fill: x.color, "text-anchor": "start" }).css(x), O.appendChild(y), k += q); F = Y(k) + m; c.path([g, 0, F, X, l, F], O).attr(p)
}, drawSSGridNavButton: function () {
    var a = this, b = a.paper, c = a.options, d = c.chart, B = c.series, e = d.navButtonColor, v = d.navButtonHoverColor, c = d.navButtonRadius, f = 0.67 * c, l = d.navButtonPadding + f + (B && B[0].data && B[0].data.length * d.rowHeight) + 0.5 * c, d =
d.width - 20, q, h, p, x; 1 < B.length && (x = a.naviigator = b.group("navigation"), a.navElePrv = B = b.group(x), q = b.path([g, 20, l, X, 20 + c + f, l - f, 20 + c, l, 20 + c + f, l + f, "Z"]).attr({ fill: e, "stroke-width": 0, cursor: "pointer" }), B.appendChild(q), p = b.circle(20 + c, l, c).attr({ fill: Sa, "stroke-width": 0, cursor: "pointer" }).mouseover(function () { q.attr({ fill: v, cursor: "pointer" }) }).mouseout(function () { q.attr({ fill: e }) }).click(function () { a.nenagitePage(-1) }), B.appendChild(p), a.navEleNxt = B = b.group(x), h = b.path([g, d, l, X, d - c - f, l - f, d - c, l, d - c - f,
l + f, "Z"]).attr({ fill: e, "stroke-width": 0, cursor: "pointer" }), B.appendChild(h), b = b.circle(d - c, l, c).attr({ fill: Sa, "stroke-width": 0, cursor: "pointer" }).mouseover(function () { h.attr({ fill: v }) }).mouseout(function () { h.attr({ fill: e }) }).click(function () { a.nenagitePage(1) }), B.appendChild(b))
}, nenagitePage: function (a) {
    var b = this.plots, c = b.length; a = (this.currentSeriesIndex || 0) + (a || 0); var d, e = function (a) {
        a.graphic && a.graphic.hide(); a.dataLabel && a.dataLabel.hide(); a.dataValue && a.dataValue.hide(); a.alternateRow && a.alternateRow.hide();
        a.listRowDivider && a.listRowDivider.hide()
    }; if (b[a]) { for (d = c; d--; ) ta(b[d].items, e); ta(b[a].items, function (a) { a.graphic && a.graphic.show(); a.dataLabel && a.dataLabel.show(); a.dataValue && a.dataValue.show(); a.alternateRow && a.alternateRow.show(); a.listRowDivider && a.listRowDivider.show() }); this.currentSeriesIndex = a; ea.raiseEvent("pageNavigated", { pageId: a, data: this.options.series[a].data }, this.logic.chartInstance); 0 === a ? this.navElePrv.hide() : this.navElePrv.show(); a === c - 1 ? this.navEleNxt.hide() : this.navEleNxt.show() } 
} 
},
m["renderer.root"]); Ma.prototype = { getArcPath: function (a, b, c, d, e, f, v, g, h, q) { return c == e && d == f ? [] : [l, v, g, 0, q, h, e, f] }, parseColor: function (a, b) {
    var c, d, e, f, v, g, l, q, h, p, x = b / 2, X, k, O, m, y; y = 3; this.use3DLighting ? (c = qa(a, 80), d = qa(a, 75), g = va(a, 85), l = va(a, 70), q = va(a, 40), h = va(a, 50), va(a, 30), p = va(a, 65), qa(a, 85), e = qa(a, 69), f = qa(a, 75), v = qa(a, 95)) : (y = 10, c = qa(a, 90), d = qa(a, 87), g = va(a, 93), l = va(a, 87), q = va(a, 80), p = h = va(a, 85), va(a, 80), v = qa(a, 85), e = qa(a, 75), f = qa(a, 80)); X = d + ba + g + ba + l + ba + g + ba + d; O = b + ba + b + ba + b + ba + b + ba + b; k = d +
ba + a + ba + g + ba + a + ba + d; m = x + ba + x + ba + x + ba + x + ba + x; q = d + ba + a + ba + q + ba + a + ba + d; e = f + ba + g + ba + h + ba + g + ba + e; f = "FFFFFF" + ba + "FFFFFF" + ba + "FFFFFF" + ba + "FFFFFF" + ba + "FFFFFF"; y = 0 + ba + x / y + ba + b / y + ba + x / y + ba + 0; return { frontOuter: { FCcolor: { gradientUnits: "userSpaceOnUse", x1: this.leftX, y1: 0, x2: this.rightX, y2: 0, color: e, alpha: O, angle: 0, ratio: "0,20,15,15,50"} }, backOuter: { FCcolor: { gradientUnits: "userSpaceOnUse", x1: this.leftX, y1: 0, x2: this.rightX, y2: 0, color: q, alpha: m, angle: 0, ratio: "0,62,8,8,22"} }, frontInner: { FCcolor: { gradientUnits: "userSpaceOnUse",
    x1: this.leftInnerX, y1: 0, x2: this.rightInnerX, y2: 0, color: k, alpha: m, angle: 0, ratio: "0,25,5,5,65"
}
}, backInner: { FCcolor: { gradientUnits: "userSpaceOnUse", x1: this.leftInnerX, y1: 0, x2: this.rightInnerX, y2: 0, color: X, alpha: O, angle: 0, ratio: "0,62,8,8,22"} }, topBorder: { FCcolor: { gradientUnits: "userSpaceOnUse", x1: this.leftX, y1: 0, x2: this.rightX, y2: 0, color: f, alpha: y, angle: 0, ratio: "0,20,15,15,50"} }, topInnerBorder: { FCcolor: { gradientUnits: "userSpaceOnUse", x1: this.leftInnerX, y1: 0, x2: this.rightInnerX, y2: 0, color: f, alpha: y, angle: 0,
    ratio: "0,50,15,15,20"
}
}, top: aa ? { FCcolor: { gradientUnits: "userSpaceOnUse", radialGradient: !0, cx: this.cx, cy: this.cy, r: this.rx, fx: this.cx - 0.3 * this.rx, fy: this.cy + 1.2 * this.ry, color: p + ba + v, alpha: b + ba + b, ratio: "0,100"}} : { FCcolor: { gradientUnits: "objectBoundingBox", color: l + ba + l + ba + g + ba + d, alpha: b + ba + b + ba + b + ba + b, angle: -72, ratio: "0,8,15,77"} }, bottom: z(wa(a, x)), startSlice: z(wa(c, b)), endSlice: z(wa(c, b))
}
}, rotate: function (a) {
    if (!this.hasOnePoint) {
        for (var b = this.pointElemStore, c = 0, d = b.length, e; c < d; c += 1) e = b[c], e = e._confObject,
e.start += a, e.end += a, this.updateSliceConf(e); this.refreshDrawing()
    } 
}, refreshDrawing: function () {
    return function () {
        var a = this.slicingWallsArr, b = 0, c, d = a.length, e, g, v, f, l = this.slicingWallsFrontGroup, q = this.slicingWallsBackGroup; a: { var h = a[0] && a[0]._conf.index, p, x; f = h <= $; e = 1; for (c = a.length; e < c; e += 1) if (x = a[e]._conf.index, p = x <= $, p != f || x < h) break a; e = 0 } for (; b < d; b += 1, e += 1) e === d && (e = 0), c = a[e], f = c._conf.index, f < Qa ? l.appendChild(c) : f <= $ ? (g ? c.insertBefore(g) : l.appendChild(c), g = c) : f < Ua ? (v ? c.insertBefore(v) : q.appendChild(c),
v = c) : q.appendChild(c)
    } 
} (), updateSliceConf: function (a, b) {
    var c = this.getArcPath, d = a.start, e = a.end, f = ca(d), v = ca(e), h, m, q, k, p, s, r, S, O, Y, y, H, E, C, t, K, L = this.cx, A = this.cy, G = this.rx, M = this.ry, fa = G + (aa ? -1 : 2), V = M + (aa ? -1 : 2), u = this.innerRx, I = this.innerRy, Q = this.depth, R = this.depthY, T = a.elements, w, P, N, z, U, J, ba; h = F(f); m = W(f); q = F(v); k = W(v); p = L + G * h; s = A + M * m; r = L + fa * h; S = A + V * m; w = s + Q; P = L + G * q; N = A + M * k; O = L + fa * q; Y = A + V * k; z = N + Q; this.isDoughnut ? (y = L + u * h, H = A + I * m, t = H + Q, E = L + u * q, C = A + I * k, K = C + Q, a.startSlice = [g, p, s, X, p, w, y, t, y, H, x],
a.endSlice = [g, P, N, X, P, z, E, K, E, C, x]) : (a.startSlice = [g, p, s, X, p, w, L, R, L, A, x], a.endSlice = [g, P, N, X, P, z, L, R, L, A, x]); aa ? (c = (f > v ? ra : 0) + v - f, a.clipTopPath = this.isDoughnut ? [g, p, s, l, G, M, 0, c > $ ? 1 : 0, 1, P, N, X, E, C, l, u, I, 0, c > $ ? 1 : 0, 0, y, H, x] : [g, p, s, l, G, M, 0, c > $ ? 1 : 0, 1, P, N, X, this.cx, this.cy, x], a.clipOuterFrontPath1 = this.clipPathforNoClip, a.clipTopBorderPath = [g, r, S, l, fa, V, 0, c > $ ? 1 : 0, 1, O, Y, X, P, N, P, N + 1, l, G, M, 0, c > $ ? 1 : 0, 0, p, s + 1, X, p, s, x], d != e ? f > v ? f < $ ? (a.clipOuterFrontPath = [g, this.rightX, A, l, G, M, 0, 0, 1, P, N, "v", Q, l, G, M, 0, 0, 0, this.rightX,
A + Q, x], a.clipOuterFrontPath1 = [g, this.leftX, A, l, G, M, 0, 0, 0, p, s, "v", Q, l, G, M, 0, 0, 1, this.leftX, A + Q, x], a.clipOuterBackPath = [g, this.rightX, A, l, G, M, 0, 1, 0, this.leftX, A, "v", Q, l, G, M, 0, 1, 1, this.rightX, A + Q, x], this.isDoughnut && (a.clipInnerBackPath = [g, this.rightInnerX, A, l, u, I, 0, 1, 0, this.leftInnerX, A, "v", Q, l, u, I, 0, 1, 1, this.rightInnerX, A + Q, x], a.clipInnerFrontPath = [g, this.rightInnerX, A, l, u, I, 0, 0, 1, E, C, "v", Q, l, u, I, 0, 0, 0, this.rightInnerX, A + Q, x, g, this.leftInnerX, A, l, u, I, 0, 0, 0, y, H, "v", Q, l, u, I, 0, 0, 1, this.leftInnerX, A + Q,
x])) : v > $ ? (a.clipOuterFrontPath = [g, this.rightX, A, l, G, M, 0, 1, 1, this.leftX, A, "v", Q, l, G, M, 0, 1, 0, this.rightX, A + Q, x], a.clipOuterBackPath = [g, this.leftX, A, l, G, M, 0, 0, 1, P, N, "v", Q, l, G, M, 0, 0, 0, this.leftX, A + Q, x, g, this.rightX, A, l, G, M, 0, 0, 0, p, s, "v", Q, l, G, M, 0, 0, 1, this.rightX, A + Q, x], this.isDoughnut && (a.clipInnerFrontPath = [g, this.rightInnerX, A, l, u, I, 0, 1, 1, this.leftInnerX, A, "v", Q, l, u, I, 0, 1, 0, this.rightInnerX, A + Q, x], a.clipInnerBackPath = [g, this.leftInnerX, A, l, u, I, 0, 0, 1, E, C, "v", Q, l, u, I, 0, 0, 0, this.leftInnerX, A + Q, x, g, this.rightInnerX,
A, l, u, I, 0, 0, 0, y, H, "v", Q, l, u, I, 0, 0, 1, this.rightInnerX, A + Q, x])) : (a.clipOuterFrontPath = [g, this.rightX, A, l, G, M, 0, 0, 1, P, N, "v", Q, l, G, M, 0, 0, 0, this.rightX, A + Q, x], a.clipOuterBackPath = [g, p, s, l, G, M, 0, 0, 1, this.rightX, A, "v", Q, l, G, M, 0, 0, 0, p, w, x], this.isDoughnut && (a.clipInnerFrontPath = [g, this.rightInnerX, A, l, u, I, 0, 0, 1, E, C, "v", Q, l, u, I, 0, 0, 0, this.rightInnerX, A + Q, x], a.clipInnerBackPath = [g, y, H, l, u, I, 0, 0, 1, this.rightInnerX, A, "v", Q, l, u, I, 0, 0, 0, y, t, x])) : f < $ ? v > $ ? (a.clipOuterFrontPath = [g, p, s, l, G, M, 0, 0, 1, this.leftX, A, "v",
Q, l, G, M, 0, 0, 0, p, w, x], a.clipOuterBackPath = [g, this.leftX, A, l, G, M, 0, 0, 1, P, N, "v", Q, l, G, M, 0, 0, 0, this.leftX, A + Q, x], this.isDoughnut && (a.clipInnerFrontPath = [g, y, H, l, u, I, 0, 0, 1, this.leftInnerX, A, "v", Q, l, u, I, 0, 0, 0, y, t, x], a.clipInnerBackPath = [g, this.leftInnerX, A, l, u, I, 0, 0, 1, E, C, "v", Q, l, u, I, 0, 0, 0, this.leftInnerX, A + Q, x])) : (a.clipOuterFrontPath = [g, p, s, l, G, M, 0, 0, 1, P, N, "v", Q, l, G, M, 0, 0, 0, p, w, x], a.clipOuterBackPath = this.clipPathforNoClip, this.isDoughnut && (a.clipInnerFrontPath = [g, y, H, l, u, I, 0, 0, 1, E, C, "v", Q, l, u, I, 0, 0,
0, y, t, x], a.clipInnerBackPath = this.clipPathforNoClip)) : (a.clipOuterFrontPath = this.clipPathforNoClip, a.clipOuterBackPath = [g, p, s, l, G, M, 0, 0, 1, P, N, "v", Q, l, G, M, 0, 0, 0, p, w, x], this.isDoughnut && (a.clipInnerFrontPath = this.clipPathforNoClip, a.clipInnerBackPath = [g, y, H, l, u, I, 0, 0, 1, E, C, "v", Q, l, u, I, 0, 0, 0, y, t, x])) : a.clipOuterFrontPath = a.clipOuterBackPath = a.clipInnerBackPath = a.clipInnerFrontPath = this.clipPathforNoClip, b || (a.elements.startSlice._conf.index = f, a.elements.endSlice._conf.index = v, a.elements.frontOuter._conf.index =
La(v, f), a.elements.frontOuter1 && (a.elements.frontOuter1._conf.index = f, a.elements.frontOuter1.attr("litepath", [a.clipOuterFrontPath1])), a.thisElement.attr("litepath", [a.clipTopPath]), a.elements.bottom.attr("litepath", [a.clipTopPath]), a.elements.bottomBorder.attr("litepath", [a.clipTopPath]), a.elements.topBorder && a.elements.topBorder.attr("litepath", [a.clipTopBorderPath]), a.elements.frontOuter.attr("litepath", [a.clipOuterFrontPath]), a.elements.backOuter.attr("litepath", [a.clipOuterBackPath]), this.isDoughnut &&
(a.elements.backInner.attr("litepath", [a.clipInnerBackPath]), a.elements.frontInner.attr("litepath", [a.clipInnerFrontPath]), a.elements.backInner._conf.index = La(v, f)), this.hasOnePoint ? (a.elements.startSlice.hide(), a.elements.endSlice.hide()) : (a.elements.startSlice.attr("litepath", [a.startSlice]).show(), a.elements.endSlice.attr("litepath", [a.endSlice]).show()))) : (r = this.moveCmdArr, S = this.lineCmdArr, O = this.closeCmdArr, U = this.centerPoint, Y = this.leftPoint, fa = this.topPoint, V = this.rightPoint, Q = this.bottomPoint,
J = this.leftDepthPoint, ba = this.rightDepthPoint, h = this.leftInnerPoint, m = this.rightInnerPoint, q = this.leftInnerDepthPoint, k = this.rightInnerDepthPoint, a.clipOuterFrontPath1 = [], d != e ? (f > v ? f < $ ? (d = c(L, A, p, s, this.leftX, A, G, M, 1, 0), e = c(L, A, this.leftX, A, this.rightX, A, G, M, 1, 0), N = c(L, A, this.rightX, A, P, N, G, M, 1, 0), a.clipOuterBackPath = r.concat(Y, e, S, ba, c(L, R, this.rightX, R, this.leftX, R, G, M, 0, 0), O), a.clipOuterFrontPath1 = r.concat([p, s], d, S, J, c(L, R, this.leftX, R, p, w, G, M, 0, 0), O), a.clipOuterFrontPath = r.concat(V, N, S, [P, z],
c(L, R, P, z, this.rightX, R, G, M, 0, 0), O), a.clipTopBorderPath = r.concat([p, s], d, e, N), this.isDoughnut ? (p = c(L, A, E, C, this.rightInnerX, A, u, I, 0, 0), s = c(L, A, this.rightInnerX, A, this.leftInnerX, A, u, I, 0, 0), H = c(L, A, this.leftInnerX, A, y, H, u, I, 0, 0), a.clipInnerBackPath = r.concat(m, s, S, q, c(L, R, this.leftInnerX, R, this.rightInnerX, R, u, I, 1, 0), O), a.clipInnerFrontPath = r.concat(h, H, S, [y, t], c(L, R, y, t, this.leftInnerX, R, u, I, 1, 0), O, r, [E, C], p, S, k, c(L, R, this.rightInnerX, R, E, K, u, I, 1, 0), O), a.clipTopPath = a.clipTopBorderPath.concat(S, [E,
C], p, s, H, O), a.clipTopBorderPath = a.clipTopBorderPath.concat(r, [E, C], p, s, H)) : a.clipTopPath = a.clipTopBorderPath.concat(S, U, O)) : v > $ ? (d = c(L, A, p, s, this.rightX, A, G, M, 1, 0), e = c(L, A, this.rightX, A, this.leftX, A, G, M, 1, 0), N = c(L, A, this.leftX, A, P, N, G, M, 1, 0), a.clipOuterFrontPath = r.concat(V, e, S, J, c(L, R, this.leftX, R, this.rightX, R, G, M, 0, 0), O), a.clipOuterBackPath = r.concat([p, s], d, S, ba, c(L, R, this.rightX, R, p, w, G, M, 0, 0), O, r, Y, N, S, [P, z], c(L, R, P, z, this.leftX, R, G, M, 0, 0), O), a.clipTopBorderPath = r.concat([p, s], d, e, N), this.isDoughnut ?
(p = c(L, A, E, C, this.leftInnerX, A, u, I, 0, 0), s = c(L, A, this.leftInnerX, A, this.rightInnerX, A, u, I, 0, 0), H = c(L, A, this.rightInnerX, A, y, H, u, I, 0, 0), a.clipInnerFrontPath = r.concat(h, s, S, k, c(L, R, this.rightInnerX, R, this.leftInnerX, R, u, I, 1, 0), O), a.clipInnerBackPath = r.concat(m, H, S, [y, t], c(L, R, y, t, this.rightInnerX, R, u, I, 1, 0), O, r, [E, C], p, S, q, c(L, R, this.leftInnerX, R, E, K, u, I, 1, 0), O), a.clipTopPath = a.clipTopBorderPath.concat(S, [E, C], p, s, H, O), a.clipTopBorderPath = a.clipTopBorderPath.concat(r, [E, C], p, s, H)) : a.clipTopPath = a.clipTopBorderPath.concat(S,
U, O)) : (d = c(L, A, p, s, this.rightX, A, G, M, 1, 0), e = c(L, A, this.rightX, A, P, N, G, M, 1, 0), a.clipOuterFrontPath = r.concat(V, e, S, [P, z], c(L, R, P, z, this.rightX, R, G, M, 0, 0), O), a.clipOuterBackPath = r.concat([p, s], d, S, ba, c(L, R, this.rightX, R, p, w, G, M, 0, 0), O), a.clipTopBorderPath = r.concat([p, s], d, e), this.isDoughnut ? (p = c(L, A, E, C, this.rightInnerX, A, u, I, 0, 0), s = c(L, A, this.rightInnerX, A, y, H, u, I, 0, 0), a.clipInnerFrontPath = r.concat([E, C], p, S, k, c(L, R, this.rightInnerX, R, E, K, u, I, 1, 0), O), a.clipInnerBackPath = r.concat(m, s, S, [y, t], c(L, R, y,
t, this.rightInnerX, R, u, I, 1, 0), O), a.clipTopPath = a.clipTopBorderPath.concat(S, [E, C], p, s, O), a.clipTopBorderPath = a.clipTopBorderPath.concat(r, [E, C], p, s)) : a.clipTopPath = a.clipTopBorderPath.concat(S, U, O)) : f < $ ? v > $ ? (d = c(L, A, p, s, this.leftX, A, G, M, 1, 0), e = c(L, A, this.leftX, A, P, N, G, M, 1, 0), a.clipOuterBackPath = r.concat(Y, e, S, [P, z], c(L, R, P, z, this.leftX, R, G, M, 0, 0), O), a.clipOuterFrontPath = r.concat([p, s], d, S, J, c(L, R, this.leftX, R, p, w, G, M, 0, 0), O), a.clipTopBorderPath = r.concat([p, s], d, e), this.isDoughnut ? (p = c(L, A, E, C, this.leftInnerX,
A, u, I, 0, 0), s = c(L, A, this.leftInnerX, A, y, H, u, I, 0, 0), a.clipInnerBackPath = r.concat([E, C], p, S, q, c(L, R, this.leftInnerX, R, E, K, u, I, 1, 0), O), a.clipInnerFrontPath = r.concat(h, s, S, [y, t], c(L, R, y, t, this.leftInnerX, R, u, I, 1, 0), O), a.clipTopPath = a.clipTopBorderPath.concat(S, [E, C], p, s, O), a.clipTopBorderPath = a.clipTopBorderPath.concat(r, [E, C], p, s)) : a.clipTopPath = a.clipTopBorderPath.concat(S, U, O)) : (d = c(L, A, p, s, P, N, G, M, 1, 0), a.clipOuterBackPath = r.concat([p, s]), a.clipTopBorderPath = a.clipOuterBackPath.concat(d), a.clipOuterFrontPath =
a.clipTopBorderPath.concat(S, [P, z], c(L, R, P, z, p, w, G, M, 0, 0), O), this.isDoughnut ? (p = c(L, A, E, C, y, H, u, I, 0, 0), a.clipInnerBackPath = r.concat([E, C]), a.clipTopPath = a.clipTopBorderPath.concat(S, [E, C], p, O), a.clipTopBorderPath = a.clipTopBorderPath.concat(r, [E, C], p), a.clipInnerFrontPath = a.clipInnerBackPath.concat(p, S, [y, t], c(L, R, y, t, E, K, u, I, 1, 0), O)) : a.clipTopPath = a.clipTopBorderPath.concat(S, U, O)) : (d = c(L, A, p, s, P, N, G, M, 1, 0), a.clipOuterFrontPath = r.concat([p, s]), a.clipTopBorderPath = a.clipOuterFrontPath.concat(d), a.clipOuterBackPath =
a.clipTopBorderPath.concat(S, [P, z], c(L, R, P, z, p, w, G, M, 0, 0), O), this.isDoughnut ? (p = c(L, A, E, C, y, H, u, I, 0, 0), a.clipInnerFrontPath = r.concat([E, C]), a.clipTopPath = a.clipTopBorderPath.concat(S, [E, C], p, O), a.clipTopBorderPath = a.clipTopBorderPath.concat(a.clipInnerFrontPath, p), a.clipInnerBackPath = a.clipInnerFrontPath.concat(p, S, [y, t], c(L, R, y, t, E, K, u, I, 1, 0), O)) : a.clipTopPath = a.clipTopBorderPath.concat(S, U, O)), d = r.concat(Y, S, V), p = r.concat(fa, S, Q), a.clipTopPath = a.clipTopPath.concat(d, p), a.clipOuterFrontPath = a.clipOuterFrontPath.concat(d),
a.clipOuterFrontPath1 = a.clipOuterFrontPath1.concat(d), a.clipOuterBackPath = a.clipOuterBackPath.concat(d), this.isDoughnut && (p = r.concat(h, S, m), a.clipInnerFrontPath = a.clipInnerFrontPath.concat(p), a.clipInnerBackPath = a.clipInnerBackPath.concat(p))) : (a.clipTopPath = a.clipOuterFrontPath = a.clipOuterBackPath = [], this.isDoughnut && (a.clipInnerFrontPath = a.clipInnerBackPath = [])), b || (a.elements.startSlice._conf.index = f, a.elements.endSlice._conf.index = v, a.elements.frontOuter._conf.index = La(v, f), a.elements.frontOuter1 &&
(a.elements.frontOuter1._conf.index = f, T.frontOuter1.attr({ path: a.clipOuterFrontPath1 })), a.thisElement.attr({ path: a.clipTopPath }), T.topBorder.attr({ path: a.clipTopBorderPath }), T.bottom.attr({ path: a.clipTopPath }), T.bottomBorder.attr({ path: a.clipTopBorderPath }), T.frontOuter.attr({ path: a.clipOuterFrontPath }), T.backOuter.attr({ path: a.clipOuterBackPath }), this.isDoughnut && (T.frontInner.attr({ path: a.clipInnerFrontPath }), T.backInner.attr({ path: a.clipInnerBackPath })), this.hasOnePoint ? (a.elements.startSlice.hide(),
a.elements.endSlice.hide()) : (a.elements.startSlice.attr({ path: a.startSlice }).show(), a.elements.endSlice.attr({ path: a.endSlice }).show())))
}, onPlotHover: function (a, b) {
    var c = this.pointElemStore[a]._confObject, d = c.thisElement, e = c.elements, f = this.colorObjs[a], v = f.hoverProps, g = b ? v.hoverColorObj : f.color, l = f.showBorderEffect, q = b ? v.borderColor : f.borderColor, f = b ? v.borderWidth : f.borderWidth; aa ? (v = { fill: z(g.top), "stroke-width": 0 }, 1 !== l && (v.stroke = q, v["stroke-width"] = f), d._attr(v), l && e.topBorder.attr({ fill: z(g.topBorder),
        "stroke-width": 0
    })) : (d._attr({ fill: z(g.top), "stroke-width": 0 }), e.topBorder.attr({ stroke: q, "stroke-width": f })); e.bottom.attr({ fill: z(g.bottom), "stroke-width": 0 }); e.bottomBorder.attr({ stroke: q, "stroke-width": f }); e.frontOuter.attr({ fill: z(g.frontOuter), "stroke-width": 0 }); e.backOuter.attr({ fill: z(g.backOuter), "stroke-width": 0 }); e.startSlice.attr({ fill: z(g.startSlice), stroke: q, "stroke-width": f }); e.endSlice.attr({ fill: z(g.endSlice), stroke: q, "stroke-width": f }); d = ca(c.start); c = ca(c.end); (d > c ? ra : 0) + c - d > $ &&
e.frontOuter1.attr({ fill: z(g.frontOuter), "stroke-width": 0 }); this.isDoughnut && (e.frontInner.attr({ fill: z(g.frontInner), "stroke-width": 0 }), e.backInner.attr({ fill: z(g.backInner), "stroke-width": 0 }))
}, createSlice: function () {
    var a = { stroke: !0, strokeWidth: !0, "stroke-width": !0, dashstyle: !0, "stroke-dasharray": !0, translateX: !0, translateY: !0, "stroke-opacity": !0, transform: !0, fill: !0, opacity: !0, ishot: !0, start: !0, end: !0, cursor: !0 }, b = function (b, c) {
        var d, e, n = this, f = n._confObject, g, l = f.elements, h, B, s = f.Pie3DManager;
        "string" === typeof b && void 0 !== c && null !== c && (d = b, b = {}, b[d] = c); if (b && "string" !== typeof b) {
            void 0 !== b.cx && (b.start = b.cx); void 0 !== b.cy && (b.end = b.cy); for (d in b) if (e = b[d], a[d]) if (f[d] = e, "ishot" === d || "cursor" === d) { g = {}; g[d] = e; for (h in l) l[h].attr(g); n._attr(g) } else if ("transform" === d) { for (h in l) l[h].attr({ transform: b[d] }); n._attr({ transform: b[d] }) } else "stroke" === d || "strokeWidth" === d || "stroke-width" === d || "dashstyle" === d || "stroke-dasharray" === d ? (g = {}, g[d] = e, l.topBorder && l.topBorder.attr(g), l.startSlice.attr(g),
l.endSlice.attr(g), l.bottomBorder.attr(g)) : "fill" === d || "start" !== d && "end" !== d || (B = !0); else n._attr(d, e); B && (s.updateSliceConf(f), s.refreshDrawing())
        } else n = n._attr(b); return n
    }, c = function (a, b, c, d) { var e = this._confObject.elements, n; for (n in e) if (c) e[n].drag(b, c, d); else e[n].on(a, b); return c ? this.drag(b, c, d) : this._on(a, b) }, d = function () { var a = this._confObject.elements, b; for (b in a) a[b].hide(); return this._hide() }, e = function () { var a = this._confObject.elements, b; for (b in a) a[b].show(); return this._show() },
f = function () { var a = this._confObject, b = a.elements, c; for (c in b) b[c].destroy(); aa && (a.clipTop.destroy(), a.clipOuterFront.destroy(), a.clipOuterBack.destroy(), a.clipOuterFront1 && a.clipOuterFront1.destroy(), a.clipInnerFront && a.clipInnerFront.destroy(), a.clipInnerBack && a.clipInnerBack.destroy()); return this._destroy() }; return function (a, g, l, q, h, p, s, x, m, k) {
    var X = this.renderer; l = this.parseColor(l, q); a = { start: a, end: g, elements: {}, Pie3DManager: this }; g = this.slicingWallsArr; q = a.elements; var y, r = aa ? "litepath" :
"path"; k && (this.colorObjs[s] = { color: l, borderColor: h, borderWidth: p, showBorderEffect: !1 }, k.hoverColorObj = this.parseColor(k.color, k.alpha), this.colorObjs[s].hoverProps = k); this.updateSliceConf(a, !0); aa ? (k = { fill: z(l.top), "stroke-width": 0 }, 1 !== m && (k.stroke = h, k["stroke-width"] = p), k = X[r](a.clipTopPath, this.topGroup).attr(k), m && (q.topBorder = X[r](a.clipTopBorderPath, this.topGroup).attr({ fill: z(l.topBorder), "stroke-width": 0 }))) : (k = X[r](a.clipTopPath, this.topGroup).attr({ fill: z(l.top), "stroke-width": 0 }), q.topBorder =
X[r](a.clipTopBorderPath, this.topGroup).attr({ stroke: h, "stroke-width": p })); q.bottom = X[r](a.clipTopPath, this.bottomBorderGroup).attr({ fill: z(l.bottom), "stroke-width": 0 }); q.bottomBorder = X[r](aa ? a.clipTopPath : a.clipTopBorderPath, this.bottomBorderGroup).attr({ stroke: h, "stroke-width": p }); q.frontOuter = X[r](a.clipOuterFrontPath, this.slicingWallsFrontGroup).attr({ fill: z(l.frontOuter), "stroke-width": 0 }); q.backOuter = X[r](a.clipOuterBackPath, this.outerBackGroup).attr({ fill: z(l.backOuter), "stroke-width": 0 });
    q.startSlice = X[r](a.startSlice, this.slicingWallsFrontGroup).attr({ fill: z(l.startSlice), stroke: h, "stroke-width": p }); q.endSlice = X[r](a.endSlice, this.slicingWallsFrontGroup).attr({ fill: z(l.endSlice), stroke: h, "stroke-width": p }); h = ca(a.start); p = ca(a.end); m = (h > p ? ra : 0) + p - h; m > $ && (q.frontOuter1 = X[r](a.clipOuterFrontPath1, this.slicingWallsFrontGroup).attr({ fill: z(l.frontOuter), "stroke-width": 0 }), q.frontOuter1._conf = { index: h, isStart: 0.5, pIndex: s }, aa && (a.clipOuterFront1 = a.clipOuterFrontPath1)); q.frontOuter._conf =
{ index: La(p, h), isStart: 0.5, pIndex: s }; q.startSlice._conf = { index: h, isStart: 0, pIndex: s }; q.endSlice._conf = { index: p, isStart: 1, pIndex: s }; this.hasOnePoint && (q.startSlice.hide(), q.endSlice.hide()); this.isDoughnut ? (q.frontInner = X[r](a.clipInnerFrontPath, this.innerFrontGroup).attr({ fill: z(l.frontInner), "stroke-width": 0 }), q.backInner = X[r](a.clipInnerBackPath, this.innerBackGroup).attr({ fill: z(l.backInner), "stroke-width": 0 }), q.backInner._conf = { index: La(p, h), isStart: 0.5, pIndex: s }, m > $ ? aa ? g.push(q.startSlice, q.frontOuter1,
q.frontOuter, q.backInner, q.endSlice) : g.push(q.startSlice, q.frontOuter1, q.frontOuter, q.endSlice) : aa ? g.push(q.startSlice, q.frontOuter, q.backInner, q.endSlice) : g.push(q.startSlice, q.frontOuter, q.endSlice)) : m > $ ? g.push(q.startSlice, q.frontOuter1, q.frontOuter, q.endSlice) : g.push(q.startSlice, q.frontOuter, q.endSlice); if (void 0 !== x) { for (y in q) q[y].tooltip(x); k.tooltip(x) } aa && (a.clipTop = a.clipTopPath, a.clipOuterFront = a.clipOuterFrontPath, a.clipOuterBack = a.clipOuterBackPath, this.isDoughnut && (a.clipInnerFront =
a.clipInnerFrontPath, a.clipInnerBack = a.clipInnerBackPath)); k._confObject = a; a.thisElement = k; k._destroy = k.destroy; k.destroy = f; k._show = k.show; k.show = e; k._hide = k.hide; k.hide = d; k._on = k.on; k.on = c; k._attr = k.attr; k.attr = b; this.pointElemStore.push(k); return k
} 
} ()
}; Ma.prototype.constructor = Ma; m("renderer.pie3d", { type: "pie3d", isHovered: !1, translate: function () {
    var a = 0, b = this.options, c = b.series[0], d = b.plotOptions.series.dataLabels, e = b.plotOptions.pie3d, f = k(c.startAngle, 0) % 360, g = c.managedPieSliceDepth, l = c.slicedOffset =
e.slicedOffset, x = this.canvasWidth, q = this.canvasHeight, m = [this.canvasLeft + 0.5 * x, this.canvasTop + 0.5 * q - 0.5 * g], p, X, r, S, O, b = c.data, t, y = H(x, q), w, E, C, fa = d.distance, z = c.pieYScale, L = c.pieSliceDepth, A = c.slicedOffsetY = l * z; m.push(e.size, e.innerSize || 0); m = ha(m, function (a, b) { return (w = /%$/.test(a)) ? [x, q - g, y, y][b] * parseInt(a, 10) / 100 : a }); m[2] /= 2; m[3] /= 2; m.push(m[2] * z); m.push((m[2] + m[3]) / 2); m.push(m[5] * z); c.getX = function (a, b) { r = s.asin((a - m[1]) / (m[2] + fa)); return m[0] + (b ? -1 : 1) * F(r) * (m[2] + fa) }; c.center = m; ta(b, function (b) {
    a +=
b.y
}); c.labelsRadius = m[2] + fa; c.labelsRadiusY = c.labelsRadius * z; c.quadrantHeight = (q - g) / 2; c.quadrantWidth = x / 2; S = -f * T; S = Y(1E3 * S) / 1E3; O = S + ra; e = h(parseInt(d.style.fontSize, 10), 10) + 4; c.maxLabels = K(c.quadrantHeight / e); c.labelFontSize = e; c.connectorPadding = h(d.connectorPadding, 5); c.isSmartLineSlanted = k(d.isSmartLineSlanted, !0); c.connectorWidth = h(d.connectorWidth, 1); c.enableSmartLabels = d.enableSmartLabels; c.Pie3DManager || (c.Pie3DManager = new Ma(m[0], m[1], m[2], m[3], z, L, this.layers.dataset, this.paper, 1 === c.data.length,
c.use3DLighting)); ta(b, function (b) { p = S; t = a ? b.y / a : 0; S = Y(1E3 * (S + t * ra)) / 1E3; S > O && (S = O); X = S; b.shapeArgs = { start: Y(1E3 * p) / 1E3, end: Y(1E3 * X) / 1E3 }; b.centerAngle = r = (X + p) / 2 % ra; b.slicedTranslation = [Y(F(r) * l), Y(W(r) * A)]; E = F(r) * m[2]; c.radiusY = C = W(r) * m[4]; b.tooltipPos = [m[0] + 0.7 * E, m[1] + C]; b.percentage = 100 * t; b.total = a })
}, drawPlotPie3d: function (a, b) {
    this.translate(); var c = this, d = a.items, e = a.data, f = c.options, g = f.plotOptions, l = g.series, m = c.layers, q = c.elements.plots[0], k = c.datasets[0], g = g.series.dataLabels, p = l.dataLabels.style,
l = h(a.moveDuration, l.animation.duration), s = c.paper, x = f.tooltip || {}, x = x && !1 !== x.enabled, r, X = k.slicedOffset, H = k.slicedOffsetY, y = c.plotGraphicClick, t = c.plotDragMove, E = c.plotDragStart, C = c.plotDragEnd, Y = c.plotMouseDown, K = c.plotMouseUp, L = c.plotRollOver, A = c.plotRollOut, G = !!c.datasets[0].enableRotation, M = b.showBorderEffect, fa = e.length, f = f.chart.usePerPointLabelColor, w = { fontFamily: p.fontFamily, fontSize: p.fontSize, lineHeight: p.lineHeight, fontWeight: p.fontWeight, fontStyle: p.fontStyle }, u, I, Q, R, V, T, P, N, $, U, J,
ba = function (a) { return function () { c.legendClick(a, !0, !1) } }, ua = function (a) { return function () { return c.getEventArgs(a) } }, oa = function (a) { return function () { y.call(a) } }, D = function (a) { return function (b, c, d, e, n) { t.call(a, b, c, d, e, n) } }, da = function (a) { return function (b, c, d) { E.call(a, b, c, d) } }, ia = function (a) { return function () { C.call(a) } }, ra = function (a) { return function () { Y.call(a) } }, ca = function (a) { return function (b) { K.call(a, b) } }, aa = function (a) { return function (b) { A.call(a, b) } }, ja = function (a) {
    return function (b) {
        L.call(a,
b)
    } 
}; e && fa || (e = []); q.singletonCase = 1 === fa; q.chartPosition = Da(c.container); q.pieCenter = k.center; q.timerThreshold = 30; for (J = -1; ++J < fa; ) if (I = e[J], Q = I.y, R = I.displayValue, T = I.sliced, U = I.shapeArgs, N = I.centerAngle, r = I.toolText, P = (V = !!I.link) || G || !I.doNotSlice, null !== Q && void 0 !== Q && !(u = d[J])) {
        b.data[J].plot = u = d[J] = { chart: c, index: J, seriesData: q, value: Q, angle: N, link: I.link, shapeArgs: U, slicedX: T && !q.singletonCase ? F(N) * X : 0, slicedY: T && !q.singletonCase ? W(N) * H : 0, sliced: T, labelText: R, name: I.name, label: I.name, percentage: I.percentage,
            toolText: r, originalIndex: fa - J - 1, graphic: k.Pie3DManager.createSlice(U.start, U.end, I.color, I._3dAlpha, I.borderColor, I.borderWidth, J, x ? r : "", M, I.rolloverProperties)
        }; b.data[J].legendClick = ba(u); b.data[J].getEventArgs = ua(u); u.graphic.plotItem = u; u.graphic.data("plotItem", u); u.transX = F(N) * X; u.transY = W(N) * H; u.slicedTranslation = "t" + u.transX + "," + u.transY; u.graphic.attr({ transform: "t" + u.slicedX + "," + u.slicedY, ishot: P, cursor: V ? "pointer" : "" }); if (!I.doNotSlice) u.graphic.on("click", oa(u.graphic)); u.graphic.on("drag",
D(u), da(u), ia(u)); u.graphic.on("mousedown", ra(u.graphic)); u.graphic.on("mouseup", ca(u.graphic)); r = { index: b.reversePlotOrder ? J : fa - 1 - J, link: I.link, value: I.y, displayValue: I.displayValue, categoryLabel: I.categoryLabel, isSliced: I.sliced, toolText: I.toolText }; u.graphic.data("groupId", J).data("eventArgs", r); u.graphic.on("mouseover", ja(u)); u.graphic.on("mouseout", aa(u)); void 0 !== R && (u.dataLabel = s.text(m.dataset).css(w).attr({ text: R, title: I.originalText || "", fill: (f ? z(I.color) : p.color) || "#000000", "text-bound": [p.backgroundColor,
p.borderColor, p.borderThickness, p.borderPadding, p.borderRadius, p.borderDash], visibility: "hidden", ishot: P, cursor: V ? "pointer" : ""
}).data("eventArgs", r).hover(ja(u), aa(u)), u.dataLabel.click(y, u.dataLabel), u.dataLabel.mousedown(Y, u.dataLabel), u.dataLabel.mouseup(K, u.dataLabel), u.dataLabel.data("plotItem", u), 0 < g.distance && ($ = g.connectorWidth) && g.enableSmartLabels && (u.connector = s.path("M 0 0 l 0 0", m.dataset).attr({ "stroke-width": $, stroke: g.connectorColor || "#606060", visibility: "hidden", ishot: P, cursor: V ?
"pointer" : ""
}), u.connector.click(y, u.connector), u.connector.mousedown(Y, u.connector), u.connector.mouseup(K, u.connector), u.connector.data("plotItem", u)))
    } k.Pie3DManager.refreshDrawing(); 0 < l ? c.animate(d, l) : c.placeDataLabels(!1, d)
}, rotate: function (a) {
    var b = this.datasets[0], c = this.elements.plots[0].items, d = b.slicedOffset, e = b.slicedOffsetY, f = b.startAngle, g; a = isNaN(a) ? -b._lastAngle : a; g = (a - f) % 360; b.startAngle = h(a, b.startAngle) % 360; g = -(g * oa) / 180; b.Pie3DManager && b.Pie3DManager.rotate(g); ta(c, function (a) {
        var b =
a.graphic, c = a.shapeArgs, n = c.start += g, c = c.end += g, f = a.angle = ca((n + c) / 2), n = a.sliced, c = F(f), f = W(f); a.slicedTranslation = [Y(c * d), Y(f * e)]; a.transX = a.slicedTranslation[0]; a.transY = a.slicedTranslation[1]; a.slicedX = n ? F(g) * d : 0; a.slicedY = n ? W(g) * e : 0; b && n && a.graphic.attr({ transform: "t" + a.slicedTranslation[0] + "," + a.slicedTranslation[1] })
    }); this.placeDataLabels(!0, c)
}, plotRollOver: function (a) {
    var b = this.chart, c = b.datasets[0].Pie3DManager; this.seriesData.isRotating || (sa.call(this.graphic, b, a, "DataPlotRollOver"), c.colorObjs[this.index] &&
c.onPlotHover(this.index, !0)); b.isHovered = !0
}, plotRollOut: function (a) { var b = this.chart, c = b.datasets[0].Pie3DManager; this.seriesData.isRotating || (sa.call(this.graphic, b, a, "DataPlotRollOut"), c.colorObjs[this.index] && c.onPlotHover(this.index, !1)); b.isHovered = !1 }, plotDragStart: function (a, b, c) { var d = this.seriesData, e = this.chart.datasets[0]; e.enableRotation && (a = Oa.call(c, a, b, d.pieCenter, d.chartPosition, e.pieYScale), e.dragStartAngle = a, e._lastAngle = -e.startAngle, e.startingAngleOnDragStart = e.startAngle) },
    plotDragEnd: function () { var a = this.chart, b = a.datasets[0], c = b.Pie3DManager, d = b.startAngle, e = this.seriesData, f = { hcJSON: { series: [{ startAngle: d}]} }; a.disposed || za(a.logic.chartInstance.jsVars._reflowData, f, !0); e.isRotating && (setTimeout(function () { e.isRotating = !1 }, 0), ea.raiseEvent("rotationEnd", { startingAngle: ca(d, !0), changeInAngle: d - b.startingAngleOnDragStart }, a.logic.chartInstance), !a.isHovered && c.colorObjs[this.index] && c.onPlotHover(this.index, !1)) }, plotDragMove: function (a, b, c, d, e) {
        var f = this.chart;
        a = f.datasets[0]; b = this.seriesData; f.options.series[0].enableRotation && !b.singletonCase && (b.isRotating || (b.isRotating = !0, ea.raiseEvent("rotationStart", { startingAngle: ca(a.startAngle, !0) }, f.logic.chartInstance)), c = Oa.call(e, c, d, b.pieCenter, b.chartPosition, a.pieYScale), d = c - a.dragStartAngle, a.dragStartAngle = c, b.moveDuration = 0, a._lastAngle += 180 * d / oa, c = (new Date).getTime(), !a._lastTime || a._lastTime + b.timerThreshold < c) && (a._lastTime || f.rotate(), b.timerId = setTimeout(function () { f.disposed && f.disposing || f.rotate() },
b.timerThreshold), a._lastTime = c)
    }, animate: function (a, b) {
        var c, d, e, f = a.length, g, l, h, q = this, m, p = function () { q.disposed || q.disposing || q.placeDataLabels(!1, a) }; if (q.datasets[0].alphaAnimation) q.layers.dataset.attr({ opacity: 0 }), q.layers.dataset.animate({ opacity: 1 }, b, "ease-in", function () { q.disposed || q.disposing || q.placeDataLabels(!1, a) }); else for (c = 0; c < f; c++) g = a[c], l = g.graphic, h = g.shapeArgs, g = 2 * oa, l && (l.attr({ start: g, end: g }), m = h.start, h = h.end, d ? l.animateWith(d, e, { cx: m - g, cy: h - g }, b, "ease-in") : (e = ga.animation({ cx: m -
g, cy: h - g
        }, b, "ease-in", p), d = l.animate(e)))
    }, placeDataLabels: function () {
        var a = function (a, b) { return a.point.value - b.point.value }, b = function (a, b) { return a.angle - b.angle }, c = ["start", "start", "end", "end"], d = [-1, 1, 1, -1], e = [1, 1, -1, -1]; return function (l, m) {
            var k = this.datasets[0], x = this.smartLabel, q = this.options.plotOptions.series.dataLabels, t = q.style, p = h(V(parseFloat(t.lineHeight)), 12), K = Na(q.placeInside, !1), fa = q.skipOverlapLabels, S = q.manageLabelOverflow, O = q.connectorPadding, z = q.connectorWidth, y, w, E = 0 < q.distance,
C = k.center, T = C[1], ba = C[0], L = C[2], A = C[4], G = [[], [], [], []], M, oa, D, u = this.canvasLeft, I = this.canvasTop, Q = this.canvasWidth, R, da, ia, P, N, ca, U, J, aa, ga, ea, ka = k.labelsRadius, ha = Y(100 * k.labelsRadiusY) / 100, Ja = k.labelFontSize, Ca = Ja, Fa = Ca / 2, O = [O, O, -O, -O], qa = k.maxLabels, ja = k.isSmartLineSlanted, na = k.enableSmartLabels, la, k = k.pieSliceDepth / 2; l || x.setStyle(t); if (1 == m.length) P = m[0], la = P.dataLabel, P.slicedTranslation = [u, I], la && (la.attr({ visibility: f, "text-anchor": "middle", x: ba, y: T + Fa - 2 }), la.x = ba); else if (K) ta(m, function (a) {
    if (la =
a.dataLabel) { ea = a.angle; ga = T + C[6] * W(ea) + Fa - 2; U = ba + C[5] * F(ea); la.x = U; la._x = U; la.y = ga; if (a.sliced) { a = a.slicedTranslation; var b = a[1] - I; U += a[0] - u; ga += b } la.attr({ visibility: f, align: "middle", x: U, y: ga }) } 
}); else {
                ta(m, function (a) { if (la = a.dataLabel) ea = a.angle, 0 > ea && (ea = ra + ea), M = 0 <= ea && ea < Qa ? 1 : ea < $ ? 2 : ea < Ua ? 3 : 0, G[M].push({ point: a, angle: ea }) }); for (D = K = 4; D--; ) {
                    if (fa && (P = G[D].length - qa, 0 < P)) for (G[D].sort(a), oa = G[D].splice(0, P), da = 0, ia = oa.length; da < ia; da += 1) P = oa[da].point, P.dataLabel.attr({ visibility: "hidden" }),
P.connector && P.connector.attr({ visibility: "hidden" }); G[D].sort(b)
                } D = r(G[0].length, G[1].length, G[2].length, G[3].length); ha = r(H(D, qa) * Ca, ha + Ca); G[1].reverse(); G[3].reverse(); for (x.setStyle(t); K--; ) {
                    da = G[K]; ia = da.length; fa || (Ca = ia > qa ? ha / ia : Ja, Fa = Ca / 2); P = ia * Ca; t = ha; for (D = 0; D < ia; D += 1, P -= Ca) w = ua(ha * W(da[D].angle)), t < w ? w = t : w < P && (w = P), t = (da[D].oriY = w) - Ca; oa = c[K]; ia = ha - (ia - 1) * Ca; t = 0; for (D = da.length - 1; 0 <= D; D -= 1, ia += Ca) P = da[D].point, ea = da[D].angle, N = P.sliced, la = P.dataLabel, w = ua(ha * W(ea)), w < t ? w = t : w > ia && (w = ia),
t = w + Ca, J = (w + da[D].oriY) / 2, w = ba + e[K] * ka * F(s.asin(J / ha)), J *= d[K], J += T, aa = T + A * W(ea), ca = ba + L * F(ea), (2 > K && w < ca || 1 < K && w > ca) && (w = ca), U = w + O[K], ga = J + Fa - 2, y = U + O[K], la.x = y, la._x = y, S && (R = 1 < K ? y - this.canvasLeft : this.canvasLeft + Q - y, R = x.getSmartText(P.labelText, R, p), la.attr({ text: R.text, title: R.tooltext || "" })), ea < $ && (J += k, aa += k, ga += k), la.y = ga, N && (N = P.transX, R = P.transY, U += N, w += N, ca += N, aa += R, y += N), la.attr({ visibility: f, "text-anchor": oa, x: y, y: J }), E && z && na && (y = P.connector, P.connectorPath = w = [g, ca, aa, X, ja ? w : ca, J, U, J],
y ? (y.attr({ path: w }), y.attr("visibility", f)) : P.connector = y = this.paper.path(w).attr({ "stroke-width": z, stroke: q.connectorColor || "#606060", visibility: f }))
                } 
            } 
        } 
    } ()
}, m["renderer.piebase"]); m("renderer.pie", { drawDoughnutCenterLabel: function (a, b, c, d, e, f, g) {
    var l = this.options.series[0]; f = f || l.lastCenterLabelConfig; var h = this.paper, k = this.smartLabel, m = this.layers.dataset, p = f.padding, s = 2 * f.textPadding, x = { fontFamily: f.font, fontSize: f.fontSize + "px", lineHeight: 1.2 * f.fontSize + "px", fontWeight: f.bold ? "bold" : "", fontStyle: f.italic ?
"italic" : ""
    }, r = 1.414 * (0.5 * d - p) - s; e = 1.414 * (0.5 * e - p) - s; var X; k.setStyle(x); k = k.getSmartText(a, r, e); (e = l.doughnutCenterLabel) ? e.attr("text") !== a && this.centerLabelChange(a) : (f.bgOval && (X = h.circle(b, c, 0.5 * d - p, m)), e = l.doughnutCenterLabel = h.text(m).hover(this.centerLabelRollover, this.centerLabelRollout).click(this.centerLabelClick), e.chart = this); e.css(x).attr({ x: b, y: c, text: k.text, title: k.tooltext || "", fill: z({ FCcolor: { color: f.color, alpha: f.alpha} }), "text-bound": f.bgOval ? [] : [z({ FCcolor: { color: f.bgColor, alpha: f.bgAlpha} }),
z({ FCcolor: { color: f.borderColor, alpha: f.borderAlpha} }), f.borderThickness, f.textPadding, f.borderRadius]
    }).tooltip(f.toolText); f.bgOval && X && X.attr({ fill: "#" + f.bgColor, "fill-opacity": f.bgAlpha / 100, stroke: "#" + f.borderColor, "stroke-width": f.borderThickness, "stroke-opacity": f.borderAlpha / 100 }); g && (l.lastCenterLabelConfig = f)
}, centerLabelRollover: function () {
    var a = this.chart, b = a.fusionCharts, c = a.options.series[0].lastCenterLabelConfig, b = { height: b.args.height, width: b.args.width, pixelHeight: b.ref.offsetHeight,
        pixelWidth: b.ref.offsetWidth, id: b.args.id, renderer: b.args.renderer, container: b.options.containerElement, centerLabelText: c && c.label
    }; this.attr("text") && ea.raiseEvent("centerLabelRollover", b, a.logic.chartInstance, this, a.hoverOnCenterLabel)
}, centerLabelRollout: function () {
    var a = this.chart, b = a.fusionCharts, c = a.options.series[0].lastCenterLabelConfig, b = { height: b.args.height, width: b.args.width, pixelHeight: b.ref.offsetHeight, pixelWidth: b.ref.offsetWidth, id: b.args.id, renderer: b.args.renderer, container: b.options.containerElement,
        centerLabelText: c && c.label
    }; this.attr("text") && ea.raiseEvent("centerLabelRollout", b, a.logic.chartInstance, this, a.hoverOffCenterLabel)
}, centerLabelClick: function () {
    var a = this.chart, b = a.fusionCharts, c = a.options.series[0].lastCenterLabelConfig, b = { height: b.args.height, width: b.args.width, pixelHeight: b.ref.offsetHeight, pixelWidth: b.ref.offsetWidth, id: b.args.id, renderer: b.args.renderer, container: b.options.containerElement, centerLabelText: c && c.label }; this.attr("text") && ea.raiseEvent("centerLabelClick", b,
a.logic.chartInstance)
}, centerLabelChange: function (a) { var b = this.fusionCharts; ea.raiseEvent("centerLabelChanged", { height: b.args.height, width: b.args.width, pixelHeight: b.ref.offsetHeight, pixelWidth: b.ref.offsetWidth, id: b.args.id, renderer: b.args.renderer, container: b.options.containerElement, centerLabelText: a }, this.logic.chartInstance) }, hoverOnCenterLabel: function () {
    var a = this.chart.options.series[0].lastCenterLabelConfig; (a.hoverColor || a.hoverAlpha) && this.attr({ fill: z({ FCcolor: { color: a.hoverColor || a.color,
        alpha: a.hoverAlpha || a.alpha
    }
    })
    })
}, hoverOffCenterLabel: function () { var a = this.chart.options.series[0].lastCenterLabelConfig; (a.hoverColor || a.hoverAlpha) && this.attr({ fill: z({ FCcolor: { color: a.color, alpha: a.alpha} }) }) }, drawPlotPie: function (a, b) {
    var c = this, d = a.items, e = a.data, g = c.options, l = g.series[0], k = g.plotOptions, m = k.pie, q = k.series, s = c.layers, p = s.dataset, x = c.elements.plots[0], k = k.series.dataLabels, r = q.dataLabels.style, X = q.shadow, q = h(a.moveDuration, q.animation.duration), t = c.paper, H = g.tooltip || {}, H = H &&
!1 !== H.enabled, y, w = ((b.startAngle *= -$ / 180) || 0) % ra, E = m.slicedOffset, C = b.valueTotal, Y = ra / C, K = c.canvasLeft + 0.5 * c.canvasWidth, L = c.canvasTop + 0.5 * c.canvasHeight, A = 0.5 * m.size, m = 0.5 * (m.innerSize || 0), G = c.plotGraphicClick, M = c.plotDragMove, fa = c.plotDragStart, T = c.plotDragEnd, u = c.plotMouseDown, I = c.plotMouseUp, Q = c.plotRollOver, R = c.plotRollOut, V = !!c.datasets[0].enableRotation, D = e.length, g = g.chart.usePerPointLabelColor, P = l.centerLabelConfig, N = P.label, ba = { fontFamily: r.fontFamily, fontSize: r.fontSize, lineHeight: r.lineHeight,
    fontWeight: r.fontWeight, fontStyle: r.fontStyle
}, U, J, oa, da, ia, ua, ca, ea, aa, ha, Fa, ja = a.shadowGroup, na, la, ka, ma, Ja, qa = function (a) { return function () { c.legendClick(a, !0, !1) } }, Qa = function (a) { return function () { return c.getEventArgs(a) } }, Ua = function () { c.disposed || c.disposing || c.paper.ca.redrawDataLabels || (c.placeDataLabels(!1, d, a), c.paper.ca.redrawDataLabels = c.redrawDataLabels) }; e && D || (e = []); ja || (ja = a.shadowGroup = t.group(p).toBack()); x.singletonCase = 1 === D; x.chartPosition || (x.chartPosition = Da(c.container));
    x.pieCenter = [K, L]; x.timerThreshold = 30; ha = aa = w; for (na = D; na--; ) J = e[na], oa = J.y, da = J.displayValue, ua = J.sliced, y = J.toolText, ca = (ia = !!J.link) || V || !J.doNotSlice, null !== oa && void 0 !== oa && (U = J.color.FCcolor, U.r = A, U.cx = K, U.cy = L, J.rolloverProperties && (U = J.rolloverProperties.color.FCcolor, U.r = A, U.cx = K, U.cy = L), ha = aa, aa -= x.singletonCase ? ra : oa * Y, ea = 0.5 * (aa + ha), q ? ma = Ja = w : (ma = aa, Ja = ha), (U = d[na]) || (b.data[na].plot = U = d[na] = { chart: c, index: na, seriesData: x, value: oa, angle: ea, slicedX: F(ea) * E, slicedY: W(ea) * E, sliced: ua, labelText: da,
        toolText: y, label: J.name, link: J.link, percentage: C ? oa * C / 100 : 0, originalIndex: D - na - 1, color: J.color, borderColor: J.borderColor, borderWidth: J.borderWidth, rolloverProperties: J.rolloverProperties, center: [K, L], innerDiameter: 2 * m, centerLabelConfig: J.centerLabelConfig, graphic: t.ringpath(K, L, A, m, ma, Ja, s.dataset).attr({ "stroke-width": J.borderWidth, "stroke-linejoin": "round", stroke: J.borderColor, fill: z(J.color), "stroke-dasharray": J.dashStyle, redrawDataLabels: w, ishot: ca, cursor: ia ? "pointer" : "" }).shadow(X && J.shadow,
ja).drag(M, fa, T).mousedown(u).mouseup(I).hover(Q, R)
    }, J.doNotSlice || U.graphic.click(G), H && U.graphic.tooltip(y), b.data[na].legendClick = qa(U), b.data[na].getEventArgs = Qa(U), U.graphic.data("plotItem", U), y = { index: b.reversePlotOrder ? na : D - 1 - na, link: J.link, value: J.y, displayValue: J.displayValue, categoryLabel: J.categoryLabel, isSliced: J.sliced, toolText: J.toolText }, U.graphic.data("eventArgs", y), void 0 !== da && (U.dataLabel = t.text(p).css(ba).attr({ x: -c.chartWidth, y: -c.chartHeight, text: da, fill: (g ? z(J.color) : r.color) ||
"#000000", "text-bound": [r.backgroundColor, r.borderColor, r.borderThickness, r.borderPadding, r.borderRadius, r.borderDash], ishot: ca
    }).click(G).drag(M, fa, T).mousedown(u).mouseup(I).hover(Q, R).data("eventArgs", y).hide(), U.dataLabel.data("plotItem", U), 0 < k.distance && (Fa = k.connectorWidth) && k.enableSmartLabels && (U.connector = t.path("M 0 0 l 0 0", p).attr({ "stroke-width": Fa, stroke: k.connectorColor || "#606060", visibility: f, ishot: !0 }).click(G).drag(M, fa, T).mousedown(u).mouseup(I).hover(Q, R), U.connector.data("plotItem",
U)))), U.angle = ea, U.transX = F(ea) * E, U.transY = W(ea) * E, U.slicedTranslation = "t" + F(ea) * E + "," + W(ea) * E, q ? la ? U.graphic.animateWith(la, ka, { ringpath: [K, L, A, m, aa, ha], transform: U.sliced ? U.slicedTranslation : "" }, q, "easeIn") : (ka = ga.animation({ ringpath: [K, L, A, m, aa, ha], redrawDataLabels: c, transform: U.sliced ? U.slicedTranslation : "" }, q, "easeIn", Ua), la = U.graphic.animate(ka)) : U.graphic.attr({ transform: U.sliced ? U.slicedTranslation : "" })); N && m && c.drawDoughnutCenterLabel(N, K, L, 2 * m, 2 * m, P, !0); l.lastCenterLabelConfig = P; q ? l.doughnutCenterLabel &&
l.doughnutCenterLabel.attr({ "fill-opacity": 0 }).animate(ga.animation({ "fill-opacity": 100 }, 100).delay(100 < q ? q - 100 : 0)) : c.placeDataLabels(!1, d, a)
}, rotate: function (a, b) {
    var c = a.items, d = a.data, e = this.options.plotOptions.pie, f = e.slicedOffset, g = ra / b.valueTotal, l = this.canvasLeft + 0.5 * this.canvasWidth, h = this.canvasTop + 0.5 * this.canvasHeight, k = 0.5 * e.size, e = 0.5 * (e.innerSize || 0), m, p, r, x, s; r = (b.startAngle || 0) % ra; for (s = d.length; s--; ) m = d[s], p = m.y, null !== p && void 0 !== p && (m = c[s], x = r, r -= m.seriesData.singletonCase ? ra : p *
g, p = 0.5 * (r + x), m.angle = p, m.transX = F(p) * f, m.transY = W(p) * f, m.slicedTranslation = "t" + F(p) * f + "," + W(p) * f, m.graphic.attr({ ringpath: [l, h, k, e, r, x], transform: m.sliced ? m.slicedTranslation : "" })); this.placeDataLabels(!0, c, a)
} 
}, m["renderer.piebase"])
}, [3, 2, 2, "sr4"]]);
FusionCharts.register("module", ["private", "modules.renderer.js-zoomline", function () {
    var Da = this, ha = Da.hcLib, ca = Da.window, La = /msie/i.test(ca.navigator.userAgent) && !ca.opera, Oa = ha.chartAPI, Ma = ha.chartAPI, ea = ha.extend2, w = ha.raiseEvent, ga = ha.pluck, t = ha.pluckNumber, Ia = ha.getFirstColor, D = ha.graphics.convertColor, Xa = ha.bindSelectionEvent, k = ha.createTrendLine, ya = ha.parseUnsafeString, Ga = ha.regescape, h = ha.Raphael, Na = ha.hasTouch, Ya = ha.getMouseCoordinate, ka = ha.FC_CONFIG_STRING, pa = "rgba(192,192,192," + (La ? 0.002 :
1E-6) + ")", za = ca.Math, Ea = za.ceil, z = za.floor, Za = za.max, $a = za.min, aa = za.cos, ta = za.sin, Aa = ca.parseFloat, Pa = ca.parseInt, sa; ea(ha.eventList, { zoomed: "FC_Zoomed", pinned: "FC_Pinned", resetzoomchart: "FC_ResetZoomChart" }); Oa("zoomline", { friendlyName: "Zoomable and Panable Multi-series Line Chart", rendererId: "zoomline", standaloneInit: !0, hasVDivLine: !0, defaultSeriesType: "stepzoom", canvasborderthickness: 1, defaultPlotShadow: 1, chart: function () {
    var b = this.base.chart.apply(this, arguments), e = b[ka], f = this.dataObj.chart,
g = this.colorManager.getColor("canvasBorderColor"); ea(b.chart, { animation: !1, zoomType: "x", canvasPadding: t(f.canvaspadding, 0), scrollColor: Ia(ga(f.scrollcolor, this.colorManager.getColor("altHGridColor"))), scrollBtnWidth: t(f.scrollbtnwidth, f.scrollheight, 16), scrollHeight: t(f.scrollheight, 16) || 16, allowPinMode: t(f.allowpinmode, 1), skipOverlapPoints: t(f.skipoverlappoints, 1), showToolBarButtonTooltext: t(f.showtoolbarbuttontooltext, 1), btnResetChartTooltext: ga(f.btnresetcharttooltext, "Reset Chart"), btnZoomOutTooltext: ga(f.btnzoomouttooltext,
"Zoom out one level"), btnSwitchToZoomModeTooltext: ga(f.btnswitchtozoommodetooltext, "<strong>Switch to Zoom Mode</strong><br/>Select a subset of data to zoom into it for detailed view"), btnSwitchToPinModeTooltext: ga(f.btnswitchtopinmodetooltext, "<strong>Switch to Pin Mode</strong><br/>Select a subset of data and compare with the rest of the view"), pinPaneFill: D(ga(f.pinpanebgcolor, g), t(f.pinpanebgalpha, 15)), zoomPaneFill: D(ga(f.zoompanebgcolor, "#b9d5f1"), t(f.zoompanebgalpha, 30)), zoomPaneStroke: D(ga(f.zoompanebordercolor,
"#3399ff"), t(f.zoompaneborderalpha, 80)), crossline: { enabled: t(f.showcrossline, 1), line: { "stroke-width": t(f.crosslinethickness, 1), stroke: Ia(ga(f.crosslinecolor, "#000000")), "stroke-opacity": t(f.crosslinealpha, 20) / 100 }, labelEnabled: t(f.showcrosslinelabel, f.showcrossline, 1), labelstyle: { fontSize: Aa(f.crosslinelabelsize) ? Aa(f.crosslinelabelsize) + "px" : e.outCanvasStyle.fontSize, fontFamily: ga(f.crosslinelabelfont, e.outCanvasStyle.fontFamily) }, valueEnabled: t(f.showcrosslinevalues, f.showcrossline, 1), valuestyle: { fontSize: Aa(f.crosslinevaluesize) ?
Aa(f.crosslinevaluesize) + "px" : e.inCanvasStyle.fontSize, fontFamily: ga(f.crosslinevaluefont, e.inCanvasStyle.fontFamily)
}
}
}); return b
}, preSeriesAddition: function () {
    var b = this.dataObj, e = b.chart, f = this.hcJSON, g = f[ka], h = this.smartLabel, l = t(e.compactdatamode, 0), k = ga(e.dataseparator, "|"), s = t(e.showlabels, 1), W = e.labeldisplay && e.labeldisplay.toLowerCase(), F = s && t(e.labelheight), w = "rotate" === W ? 270 : t(e.rotatelabels, 1) ? 270 : 0, Y = f.xAxis.labels.style, H = Aa(Y.lineHeight), r = f.chart.labelPadding = t(e.labelpadding, 2) + f.chart.plotBorderWidth,
z, D, V, K = 0, aa = -1, T, da, $; 0 > F && (F = void 0); 0 > r && (r = (f.chart.plotBorderWidth || 0) + 2); z = (z = b.categories) && z[0] || {}; b = z.category; delete z.category; f.categories = W = ea({ data: D = l && b && b.split && b.split(k) || b || [], rotate: w, wrap: "none" !== W }, z); void 0 !== b && (z.category = b); z = D.length || 0; if (T = !l && s && 0 !== F && z || 0) { for (; T--; ) D[T] = D[T] && (V = D[T].label || "") && ((da = V.length) > K && (K = da, aa = T, V) || V) || ""; K && (V = D[aa]) } else if (l && z && !F) if (w) {
        l = ca.document.createElement("div"); F = ca.document.createElement("span"); l.setAttribute("class",
"fusioncharts-zoomline-localsmartlabel"); l.style.cssText = "display:block;width:1px;position:absolute;"; for ($ in Y) l.style[$] = Y[$]; F.innerHTML = b.replace(/\s*/g, "").replace(/\{br\}/ig, "<br />").replace(new RegExp(Ga(k), "g"), " "); l.appendChild(F); ca.document.body.appendChild(l); F = F.offsetWidth || void 0; l.parentNode.removeChild(l)
    } else V = D[z - 1] || D[0]; void 0 !== F && 0 !== F || !s || (V ? (h.setStyle(Y), V = h.getSmartText(V), F = w ? V.width : V.height) : F = H * (w && 3 || 1)); F > 0.3 * g.height && (F = 0.3 * g.height); W.labelHeight = F && F + 6 || 0;
    W.show = F && s || 0; W.css = ea({}, Y); w ? (W.css.rotation = w, W.css["text-anchor"] = "end") : W.css["vertical-align"] = "top"; f.xAxis.min = 0; f.xAxis.max = z && z - 1 || 0; F += t(e.scrollheight, 16) || 16; f.chart.marginBottom += r; g.marginBottomExtraSpace += F + 5; ga(e.caption, e.subcaption) || (g.marginTopExtraSpace += 16)
}, series: function () {
    var b = this.dataObj, e = b.chart, f = b.dataset, g = this.hcJSON, h = g[ka], l = h[0], x = g.series, s = t(e.yaxismaxvalue), W = t(e.yaxisminvalue), F = t(e.forceyaxislimits, 0), w = t(e.compactdatamode, 0), Y = ga(e.dataseparator, "|"),
H = Ga(e.indecimalseparator), r = Ga(e.inthousandseparator), z = t(e.drawanchors, e.showanchors, 1), D = !!t(e.showlegend, 1), V, K, ea, T, da, $ = Infinity, aa = -Infinity, ca; da = g.categories.data.length; if (f && f.length && da) {
        H && (H = new RegExp(H, "g")); r && (r = new RegExp(r, "g")); !r && !H && w && F && void 0 !== s && void 0 !== W ? (F = !0, aa = Za(s, W), $ = $a(W, s)) : F = !1; s = 0; for (W = f.length; s < W; s++) {
            V = f[s]; ea = V.data; delete V.data; w ? (T = ea || "", r && (T = T.replace(r, "")), H && (T = T.replace(H, ".")), T = T.split(Y)) : T = ea || []; T.length > da && (T.length = da); ca = T.length; if (w) {
                if (!F) for (; ca--; ) K =
Aa(T[ca]), isNaN(K) && (K = void 0), K > aa && (aa = K), K <= $ && ($ = K), T[ca] = K
            } else for (; ca--; ) K = T[ca] && T[ca].value || "", r && (K = K.replace(r, "")), H && (K = K.replace(H, ".")), K = Aa(K), isNaN(K) && (K = void 0), K > aa && (aa = K), K <= $ && ($ = K), T[ca] = K; x.push(K = { index: s, type: "zoomline", data: T, name: V.seriesname || "", showInLegend: V.seriesname && t(V.includeinlegend, 1) && D || !1, showAnchors: t(V.drawanchors, V.showanchors, z), visible: !t(V.initiallyhidden, 0), lineWidth: 2 }); T.length = da; void 0 !== ea && (V.data = ea); K.attrs = this.seriesGraphicsAttrs(V, s); V =
K.attrs.anchors; K.color = K.attrs.graphics.stroke; K.ancorRadius = V.r + V["stroke-width"] / 2; K.marker = { fillColor: V.fill, lineColor: V.stroke, lineWidth: 1, symbol: "circle"}
        } -Infinity !== aa && Infinity !== $ || (aa = $ = void 0); F = Pa(t(e.displaystartindex, 1), 10) - 1; Y = Pa(t(e.displayendindex, da || 2), 10) - 1; 1 > (f = t(e.pixelsperpoint, 15)) && (f = 1); (x = t(e.pixelsperlabel, e.xaxisminlabelwidth, g.categories.rotate ? 20 : 60)) < f && (x = f); (0 > F || F >= (da - 1 || 1)) && (F = 0); (Y <= F || Y > (da - 1 || 1)) && (Y = da - 1 || 1); g.stepZoom = { cnd: t(e.connectnulldata, 0), amrd: t(e.anchorminrenderdistance,
20), nvl: t(e.numvisiblelabels, 0), cdm: w, oppp: f, oppl: x, dsi: F, dei: Y, vdl: Y - F, dmax: l.max = aa, dmin: l.min = $, clen: da, offset: 0, step: 1, llen: 0, alen: 0, ddsi: F, ddei: Y, ppc: 0
        }; this.configureAxis(g, b); b.trendlines && k(b.trendlines, g.yAxis, h, !1, this.isBar)
    } 
}, seriesGraphicsAttrs: function (b, e) {
    var f = this.dataObj.chart, g = this.hcJSON.colors, k = "0" != (b.dashed || f.linedashed || "0"), l, g = { "stroke-width": t(b.linethickness, f.linethickness, 2), stroke: Ia(ga(b.color, f.linecolor, g[e % g.length])), "stroke-opacity": t(b.alpha, f.linealpha, 100) /
100, "stroke-dasharray": k ? [t(b.linedashlen, f.linedashlen, 5), t(b.linedashgap, f.linedashgap, 4)] : "none", "stroke-linejoin": "round", "stroke-linecap": "round"
    }, k = ea({}, g); l = g["stroke-width"] + t(f.pinlinethicknessdelta, 1); k["stroke-width"] = 0 < l && l || 0; k["stroke-dasharray"] = [3, 2]; return { graphics: g, pin: k, shadow: { opacity: g["stroke-opacity"], apply: t(f.showshadow, +!h.vml) }, anchors: { "stroke-linejoin": "round", "stroke-linecap": "round", r: t(b.anchorradius, f.anchorradius, g["stroke-width"] + 2), stroke: Ia(ga(b.anchorbordercolor,
f.anchorbordercolor, g.stroke)), "stroke-opacity": t(b.anchorborderalpha, f.anchorborderalpha, 100) / 100, "stroke-width": t(b.anchorborderthickness, f.anchorborderthickness, g["stroke-width"]), fill: Ia(ga(b.anchorbgcolor, f.anchorbgcolor, "#ffffff")), "fill-opacity": t(b.anchorbgalpha, f.anchorbgalpha, 100) / 100, opacity: t(b.anchoralpha, f.anchoralpha, 100) / 100
    }, anchorShadow: t(f.anchorshadow, f.showshadow, +!h.vml) && { apply: !0, opacity: t(b.anchoralpha, f.anchoralpha, 100) / 100}
    }
}, eiMethods: { zoomOut: function () {
    var b = this.jsVars,
e; if (b && (e = b.hcObj)) return e.zoomOut && b.hcObj.zoomOut()
}, zoomTo: function (b, e) { var f = this.jsVars, g; if (f && (g = f.hcObj)) return g.zoomRange && f.hcObj.zoomRange(b, e - 2) }, resetChart: function () { var b = this.jsVars, e; b && (e = b.hcObj) && (e.pinRangePixels && b.hcObj.pinRangePixels(), e.resetZoom && b.hcObj.resetZoom()) }, setZoomMode: function (b) { var e = this.jsVars, f; e && (f = e.hcObj) && f.activatePin && f.activatePin(!b) }, getViewStartIndex: function () { var b = this.jsVars, e; if (b && b.hcObj && (e = b.hcObj._zoominfo)) return e.ddsi + 1 }, getViewEndIndex: function () {
    var b =
this.jsVars, e; if (b && b.hcObj && (e = b.hcObj._zoominfo)) return b = e.ddei - 1, b > e.clen ? e.clen : b
} 
}
}, Oa.msline); Ma("renderer.zoomline", { resetZoom: function () { var b = this._zoomhistory, e = this.options.stepZoom; if (!b.length) return !1; b.length = 0; this.zoomTo(e.dsi, e.dei) && w("zoomReset", this._zoomargs, this.fusionCharts, [this.fusionCharts.id]); return !0 }, zoomOut: function () {
    var b = this._zoomhistory.pop(), e = this.options.stepZoom, f, g, h; b ? (f = b.dsi, g = b.dei) : this._prezoomed && (f = 0, g = e.clen - 1); (h = this.zoomTo(f, g)) && Da.raiseEvent("zoomedout",
h, this.fusionCharts); return !0
}, zoomRangePixels: function (b, e) { var f = this._zoomhistory, g = this._zoominfo, h = g.ppp, g = g.ddsi, l; f.push(this._zoominfo); (l = this.zoomTo(g + z(b / h), g + z(e / h))) ? Da.raiseEvent("zoomedin", l, this.fusionCharts) : f.pop() }, zoomRange: function (b, e) { var f = this._zoomhistory, g; f.push(this._zoominfo); (g = this.zoomTo(+b - 1, +e + 1)) ? Da.raiseEvent("zoomedin", g, this.fusionCharts) : f.pop() }, zoomTo: function (b, e) {
    var f = this.xlabels.data, g = this._zoominfo, h = this._zoomhistory, l = g.clen; 0 > b && (b = 0); b >= l - 1 && (b =
l - 1); e <= b && (e = b + 1); e > l - 1 && (e = l - 1); if (b === e || b === g.dsi && e === g.dei) return !1; this.pinRangePixels(); g = ea({}, g); g.dsi = b; g.dei = e; g = this._zoominfo = g; this.updatePlotZoomline(); this.zoomOutButton[g.vdl === g.clen - 1 ? "hide" : "show"](); this.resetButton[h.length ? "show" : "hide"](); this.elements.zoomscroller.attr({ "scroll-ratio": g.vdl / (l - !!l), "scroll-position": [g.dsi / (l - g.vdl - 1), !0] }); f = { level: h.length + 1, startIndex: b, startLabel: f[b], endIndex: e, endLabel: f[e] }; w("zoomed", f, this.fusionCharts, [this.fusionCharts.id, b, e,
f.startLabel, f.endLabel, f.level]); return f
}, activatePin: function (b) { var e = this._zoominfo, f = this.options.chart, g = this.pinButton; if (g && e.pinned ^ (b = !!b)) return b || this.pinRangePixels(), w("zoomModeChanged", { pinModeActive: b }, this.fusionCharts, []), f.showToolBarButtonTooltext && g.tooltip(f[b && "btnSwitchToZoomModeTooltext" || "btnSwitchToPinModeTooltext"] || ""), g.attr("button-active", b), e.pinned = b }, pinRangePixels: function (b, e) {
    var f = this.paper, g = this.elements, k = this.xlabels.data, l = this._zoominfo, x = this.layers.zoompin,
s = g.pinrect, t = g["clip-pinrect"], F = this._pingrouptransform, z = this.plots, Y = e - b, H, r; if (l && x && s) {
        if (b === e) return x.hide(), g.pintracker.hide(), this.pinButton.attr("button-active", !1), l.pinned = !1; for (r = z.length; r--; ) s = z[r], H = s.pinline, H || (H = s.pinline = f.path(void 0, x).attr(s.attrPin)), H.attr("path", s.graphic.attrs.path); t[0] = b + (h.svg ? this.canvasLeft : 0); t[2] = Y; x.attr({ "clip-rect": t, transform: F }).show(); g.pintracker.__pindragdelta = 0; g.pintracker.show().attr({ transform: F, x: b, width: Y }); b = this.getValuePixel(b);
        e = this.getValuePixel(e); w("pinned", { startIndex: b, endIndex: e, startLabel: k[b], endLabel: k[e] }, this.fusionCharts, [this.fusionCharts.id, b, e, k[b], k[e]]); return l.pinned = !0
    } 
}, getValuePixel: function (b) { var e = this._zoominfo; return e.ddsi + z(b / e.ppp) }, getParsedLabel: function (b) { var e = this.xlabels; return e.parsed[b] || (e.parsed[b] = ya(e.data[b] || "")) }, drawGraph: function () {
    var b = this, e = b.paper, f = b.canvasLeft, g = b.canvasTop, k = b.canvasWidth, l = b.canvasHeight, x = b.options, s = x.chart, t = s.plotBorderWidth, F = s.useRoundEdges,
w = s.showToolBarButtonTooltext, Y = s.crossline, H = b.layers, r = b.toolbar, z = b.elements, D = s.allowPinMode, V, K = x.categories, aa = !1, T, da, $, ca, ha, ga; ga = b._zoominfo = ea({}, x.stepZoom); b._zoomhistory = []; ga.clen && (aa = b._prezoomed = ga.dei - ga.dsi < ga.clen - 1, ha = b._visw = b.canvasWidth - 2 * s.canvasPadding, ca = b._visx = b.canvasLeft + s.canvasPadding, b._visout = -(b.chartHeight + b.canvasHeight + 1E3), b.base.drawGraph.apply(b, arguments), b._ypvr = b.yAxis[0] && b.yAxis[0].pixelValueRatio || 0, V = b._yzero || 0, x = H.dataset.attr("clip-rect", [b._visx,
b.canvasTop, b._visw, b.canvasHeight]), $ = H.scroll || (H.scroll = e.group("scroll").insertAfter(H.layerAboveDataset)), b.xlabels = [], b.xlabels.show = K.show, b.xlabels.height = K.labelHeight, b.xlabels.wrap = K.wrap, b.xlabels.rotate = K.rotate, b.xlabels.data = K.data || [], b.xlabels.parsed = [], b.xlabels.css = K.css, b.xlabels.group = e.group("zoomline-plot-xlabels", H.datalabels), H.datalabels.transform(["T", ca, g + l + s.scrollHeight + s.labelPadding]), b._lcmd = K.rotate ? "y" : "x", D && (D = h.crispBound(0, g - V, 0, l, t), T = z["clip-pinrect"] = [D.x,
h.svg ? g : D.y, D.width, D.height], da = H.zoompin = e.group("zoompin").insertBefore(x).transform(b._pingrouptransform = ["T", ca, V]).hide(), z.pinrect = e.rect(0, g - V, b._visw, l, H.zoompin).attr({ "stroke-width": 0, stroke: "none", fill: s.pinPaneFill, "shape-rendering": "crisp", ishot: !0 }), z.pintracker = e.rect(H.tracker).attr({ transform: da.transform(), x: 0, y: g - V, width: 0, height: l, stroke: "none", fill: pa, ishot: !0, cursor: h.svg && "ew-resize" || "e-resize" }).drag(function (b) {
    var e = ca + b + this.__pindragdelta, f = this.__pinboundleft, g = this.__pinboundright;
    e < f ? e = f : e > g && (e = g); da.transform(["T", e, V]); z.pintracker.transform(da.transform()); this.__pindragoffset = b
}, function () { this.__pinboundleft = 0 - T[0] + ca + (h.svg && f || 0); this.__pinboundright = this.__pinboundleft + ha - T[2]; da._.clipispath = !0 }, function () { da._.clipispath = !1; this.__pindragdelta = this.__pindragoffset; delete this.__pindragoffset; delete this.__pinboundleft; delete this.__pinboundright }), b.pinButton = r.add("pinModeIcon", function () { b.activatePin(!b._zoominfo.pinned) }, { tooltip: w && s.btnSwitchToPinModeTooltext ||
""
})), t++, D = h.crispBound(f - t, g + l + t, k + t + t, s.scrollHeight, t), t--, z.zoomscroller = e.scroller(D.x + (F && -1 || t % 2), D.y - (F && 4 || 2), D.width - (!F && 2 || 0), D.height, !0, { showButtons: !0, scrollRatio: ga.vdl / (ga.clen - !!ga.clen), scrollPosition: [ga.dsi / (ga.clen - ga.vdl - 1), !1] }, $).attr({ fill: s.scrollColor, r: F && 2 || 0 }).scroll(b.updatePlotZoomline, b), F && z.zoomscroller.shadow(!0), function () {
    var e; h.eve.on("raphael.scroll.start." + z.zoomscroller.id, function (f) { e = f; Da.raiseEvent("scrollstart", { scrollPosition: f }, b.logic.chartInstance) });
    h.eve.on("raphael.scroll.end." + z.zoomscroller.id, function (f) { Da.raiseEvent("scrollend", { prevScrollPosition: e, scrollPosition: f }, b.logic.chartInstance) })
} (), Xa(b, { attr: { stroke: s.zoomPaneStroke, fill: s.zoomPaneFill, strokeWidth: 0 }, selectionStart: function () { }, selectionEnd: function (e) { var g = e.selectionLeft - f; e = g + e.selectionWidth; b.crossline && b.crossline.hide(); b[b._zoominfo.pinned ? "pinRangePixels" : "zoomRangePixels"](g, e) } }), b.zoomOutButton = r.add("zoomOutIcon", function () { b.zoomOut() }, { tooltip: w && s.btnZoomOutTooltext ||
""
})[aa && "show" || "hide"](), b.resetButton = r.add("resetIcon", function () { b.resetZoom() }, { tooltip: w && s.btnResetChartTooltext || "" }).hide(), D = b.resetButton.attr("fill"), D[2] = "rgba(255,255,255,0)", b.resetButton.attr("fill", [D[0], D[1], D[2], D[3]]), Y && 0 !== Y.enabled && (b.crossline = new sa(b, Y)), b.updatePlotZoomline())
}, drawPlotZoomline: function (b, e) {
    var f = this.paper, g = this._yzero || (this._yzero = this.yAxis[0].getAxisPosition(0)), h = e.attrs, l = e.visible, k = l ? "show" : "hide", s = this.layers.dataset, t = b.group || (b.group = f.group("plot-zoomline-dataset",
s)), s = b.anchorGroup || (b.anchorGroup = f.group("plot-zoomline-anchors", s)), f = b.graphic || (b.graphic = f.path(void 0, t)), g = ["T", this._visx, g]; t.transform(g)[k](); s.transform(g)[k](); b.graphic = f.attr(h.graphics).shadow(h.shadow); b.attrPin = h.pin; b.visible = l; b.anchors = []; b.anchors.show = e.showAnchors; b.anchors.attrs = h.anchors; b.anchors.attrsShadow = h.anchorShadow; b.anchors.left = -(h.anchors.r + 0.5 * h.anchors["stroke-width"]); b.anchors.right = this._visw - b.anchors.right
}, updatePlotZoomline: function (b, e) {
    var f = this.paper,
g = this._ypvr, h = this._visw, l = this.xlabels, k = l.css, s = l.group, t = this.plots, F, w, z, H, r, D, aa; !e && (e = this._zoominfo); z = e.oppp; H = e.vdl = e.dei - e.dsi; r = e.ppl = e.nvl ? h / e.nvl : e.oppl; h = e.step = (w = e.ppp = h / H) < z ? Ea(z / w) : 1; r = e.lskip = Ea(r / w / h); void 0 !== b ? (z = (e.clen - H - 1) * b, e.offset = (z - (z = Pa(z))) * w, D = z + H) : (z = e.dsi, D = e.dei, e.offset = 0); H = e.norm = z % h; e.ddsi = z -= H; e.ddei = D = D + 2 * h - H; e.pvr = g; g = l.show ? Ea((D - z) / h / r) : 0; H = e.llen - 1; e.llen = g; aa = e.ppc = w * r * h; if (g > H) for (r = H, H = g; r < H; r++) (F = l[r]) && F.show() || (l[r] = f.text(0, 0, "", s).css(k));
    else for (r = g, H += 1; r < H; r++) l[r].hide(); g = w * h < e.amrd ? 0 : Ea((D - z) / h); k = g - e.alen; e.alen = g; l.wrap && (l.rotate ? (l._width = l.height, l._height = aa) : (l._width = aa, l._height = l.height)); for (h = t.length; h--; ) { s = t[h]; F = s.anchors; if (F.show && k) { w = F.attrs; r = 0; for (H = g; r < H; r++) F[r] = F[r] && F[r].show() || f.circle(0, 0, 0, s.anchorGroup).attr(w); r = g; for (H = F.length; r < H; r++) F[r] && F[r].hide() } this.drawPlotZoomlineGraphics(e, s.data, s.graphic, F, !h && l) } ca.FC_DEV_ENVIRONMENT && (FusionCharts["debugger"].enable() ? (this.debug = this.debug ||
(ca.jQuery("#fc-zoominfo").length || ca.jQuery("body").append('<pre id="fc-zoominfo">'), ca.jQuery("#fc-zoominfo").css({ position: "absolute", left: "10px", top: "0", "pointer-events": "none", opacity: 0.7, width: "250px", zIndex: "999", border: "1px solid #cccccc", "box-shadow": "1px 1px 3px #cccccc", background: "#ffffff" })), this.debug.text(JSON.stringify(e, 0, 2))) : (ca.jQuery("#fc-zoominfo").remove(), delete this.debug))
}, drawPlotZoomlineGraphics: function (b, e, f, g, h) {
    var l = this.smartLabel, k = [], s = !b.cnd, t = b.ddei, F = b.clen,
w = b.step, z = b.lskip, H = b.ppp, r = b.offset, D = b.pvr, aa = this._visw, V = this._visout, K = this._lcmd, ca = "M", T, da, $ = h && h[0], ea, ga; g = g[0]; var ha = {}, ka = {}, ia, pa = 0, sa, ta, qa = -b.norm; b = b.ddsi; var va = 0; $ && (h.group.transform(["T", -r, 0]), ta = h.wrap, ea = h._height, ga = h._width); for (; b <= t; b += w, qa += w) sa = pa / 3 + va, ia = qa * H, void 0 === (T = e[b]) ? (s && (ca = "M"), da = V, h = ia - r, T = V, va++) : (k[pa++] = ca, k[pa++] = da = h = ia - r, k[pa++] = T *= D, ca = "L"), g && (g = g.attr((ha.cx = da, ha.cy = T, ha)).next), !$ || sa % z || (sa = $.attrs, da = this.getParsedLabel(b), h = 0 > h || h > aa ? V : ia,
$._prevtext === da ? delete ka.text : ka.text = $._prevtext = da, sa[K] === h ? delete ka[K] : ka[K] = h, ta && da && (ka.text = l.getSmartText(da, ga, ea).text), $ = $.attr(ka).next); t >= F && (void 0 !== (T = e[F - 1]) && (k[pa++] = "L", k[pa++] = (qa - (t - F)) * H - r, k[pa++] = T * D), g && g.attr((ha.cx = V, ha.cy = V, ha))); f.attr("path", k)
}, legendClick: function (b) { var e = !b.visible, f = e ? "show" : "hide"; b.group[f](); b.anchorGroup[f](); this.base.legendClick.apply(this, arguments); return b.visible = e }, dispose: function () {
    var b; this.crossline && (this.crossline.dispose(),
delete this.crossline); (b = this.elements.pintracker) && (b.undrag(), delete this.elements.pintracker); delete this.zoomOutButton; delete this.resetButton; delete this.pinButton; this.xlabels.length = 0; delete this.xlabels; this.base.dispose.apply(this)
} 
}, Ma["renderer.cartesian"]); sa = function (b, e) {
    var f = b.paper, g = this.left = b._visx, h = this.width = b._visw, l = b.canvasTop, k = b.canvasHeight, s = this._visout = b._visout, t = this.plots = b.plots, w = b.layers.dataset, z, D = e.labelstyle, H = e.valuestyle; z = this.group = f.group("crossline-labels",
w).attr({ transform: ["T", g, b._yzero] }); this.tracker = f.rect(g, l, h, k, w).attr({ stroke: "none", "stroke-width": 0, fill: pa }).toFront().mousedown(this.onMouseDown, this).mouseup(this.onMouseUp, this, !0).mouseout(this.onMouseOut, this).mousemove(this.onMouseMove, this); Na && this.tracker.touchstart(this.onMouseMove, this); this.container = b.container; this.line = f.path(void 0, w).attr(ea({ path: ["M", g, l, "l", 0, k] }, e.line)).toBack(); g = this.labels = e.valueEnabled && f.set(); e.labelEnabled && (this.positionLabel = f.text(s, l + k + (b.options.chart.scrollHeight ||
0) + 2.5, "").insertAfter(b.xlabels.group.parent).css(D).attr({ "vertical-align": "top", "text-bound": ["rgba(255,255,255,1)", "rgba(0,0,0,1)", 1, 2.5] })); this.hide(); this.pixelRatio = b._ypvr; this.positionLabels = b.xlabels || { data: [], parsed: [] }; this.getZoomInfo = function () { return b._zoominfo }; this.getDataIndexFromPixel = function (e) { return b.getValuePixel(e) }; this.getPositionLabel = function (e) { return b.getParsedLabel(e) }; if (e.valueEnabled) for (l = 0, k = t.length; l < k; l++) D = t[l], D = D.graphic.attrs.stroke, g.push(f.text(0,
s, "", z).css(H).attr({ fill: D, "text-bound": ["rgba(255,255,255,0.8)", "rgba(0,0,0,0.2)", 1, 2.5] }))
}; sa.prototype.onMouseOut = function () { this.hide() }; sa.prototype.onMouseDown = function () { this.hide(); this._mouseIsDown = !0 }; sa.prototype.onMouseUp = function () { this.hide(); delete this._mouseIsDown }; sa.prototype.onMouseMove = function (b) {
    if (!this._mouseIsDown || Na) {
        var e = this.getZoomInfo(), f = this.line, g = this.left, h = e.step, l = e.ppp * h; b = Ya(this.container, b).chartX - g; var k; b = (b += l / 2 + e.offset) - b % l; k = (k = this.getDataIndexFromPixel(Ea(b))) +
k % h; b -= e.offset; f.transform(["T", z(b), 0]); this.hidden && this.show(); if (k !== this.position || this.hidden) this.position = k, this.lineX = b, this.updateLabels()
    } 
}; sa.prototype.updateLabels = function () {
    var b = this.labels, e = this.plots, f = this.width, g = this.position, h = this.lineX, l = z(h), k = this.pixelRatio, s = this._visout, t, w; b && b.forEach(function (b, z) { t = e[z]; w = t.data[g]; b.attr({ text: w + "", x: l, y: void 0 !== w && t.visible ? w * k : s, "text-anchor": 0 >= h && "start" || h >= f && "end" || "middle" }) }); this.positionLabel && this.positionLabel.attr({ x: h +
this.left, text: this.getPositionLabel(g)
    })
}; sa.prototype.show = function () { this.hidden = !1; this.group.attr("visibility", "visible"); this.line.attr("visibility", "visible"); this.positionLabel && this.positionLabel.attr("visibility", "visible") }; sa.prototype.hide = function () { this.hidden = !0; this.group.attr("visibility", "hidden"); this.line.attr("visibility", "hidden"); this.positionLabel && this.positionLabel.attr("visibility", "hidden") }; sa.prototype.dispose = function () { for (var b in this) this.hasOwnProperty(b) && delete this[b] };
    h.addSymbol({ pinModeIcon: function (b, e, f) { var g = 0.5 * f, h = b - f, l = b + f, k = b - g, s = b + g, t = b + 0.5, w = t + 1, z = t + 1.5, D = e - f, H = e + g, r = e - g, g = e + (f - g); return ["M", h, D, "L", k, r, k, g, h, H, b - 0.5, H, b, e + f + 0.5, t, H, l, H, s, g, s, r, l, D, z, D, z, r, z, g, w, g, w, r, z, r, z, D, "Z"] }, zoomOutIcon: function (b, e, f) {
        b -= 0.2 * f; e -= 0.2 * f; var g = 0.8 * f, k = h.rad(43), l = h.rad(48), t = b + g * aa(k), k = e + g * ta(k), s = b + g * aa(l), l = e + g * ta(l), w = h.rad(45), z = t + f * aa(w), D = k + f * ta(w), Y = s + f * aa(w); f = l + f * ta(w); return ["M", t, k, "A", g, g, 0, 1, 0, s, l, "Z", "M", t + 1, k + 1, "L", z, D, Y, f, s + 1, l + 1, "Z", "M", b - 2,
e, "L", b + 2, e, "Z"]
    }, resetIcon: function (b, e, f) { var g = b - f, h = (za.PI / 2 + za.PI) / 2; b += f * aa(h); var h = e + f * ta(h), k = 2 * f / 3; return ["M", g, e, "A", f, f, 0, 1, 1, b, h, "L", b + k, h - 1, b + 2, h + k - 0.5, b, h] } 
    })
} ]);